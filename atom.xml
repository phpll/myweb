<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newdy.cf</id>
    <title>Gridea</title>
    <updated>2020-02-21T19:10:51.309Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newdy.cf"/>
    <link rel="self" href="https://newdy.cf/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://newdy.cf/images/avatar.png</logo>
    <icon>https://newdy.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[unraid的优点及缺点大全]]></title>
        <id>https://newdy.cf/post/unraid-de-you-dian-ji-que-dian-da-quan/</id>
        <link href="https://newdy.cf/post/unraid-de-you-dian-ji-que-dian-da-quan/">
        </link>
        <updated>2020-02-21T19:10:13.000Z</updated>
        <content type="html"><![CDATA[<p>UNRAID的介绍：</p>
<p>什么是UNRAID，UNRAID是基于LINUX slackware的RAID系统，其本质总结成一句话就是带有校验盘（即容错功能）的JBOD。</p>
<p>UNRAID的优点:</p>
<p>1.unraid有现成的很多plugin支持 支持docker 也支持 vm 虚拟机，还有现成的应用市场直接下载. 同时作为nas服务器 docker服务器 虚拟机服务器 插件 应用 等多种功能。</p>
<p>2.web界面管理，非常轻量（一个u盘加载到内存运行) ，直接samba共享，windows连接nas很方便</p>
<p>3.有现成的Deluge和Plex的docker，Linux新手也能很快运用，比Ubuntu用VNC方便很多（VNC或者teamviewer不流畅而且经常有些莫名其妙的问题）<br>
4.最重要硬盘的管理方式是随便加硬盘，可以不同大小不同速度(我爱帮助网)，最后都是一个存储池，但比windows好处只要一个硬盘做冗余就行，有硬盘坏了就从那个冗余盘，对我来说比折腾RAID可靠多了。缺点是60美元的价格。<br>
5.支持硬盘无访问自动休眠（SPINDOWN）省电，毕竟一个10/20块硬盘的家用阵列，不是每时每刻都有访问需求的。节能、降噪。<br>
6.阵列中每个硬盘容量可以不一样。</p>
<p>7.只需要一个校验盘，要求其容量是阵列里面最大的(即：容量≥阵列中任意一个硬盘)。</p>
<p>8.允许1个硬盘倒下，不影响阵列数据完整。即使第2个硬盘倒下，也只损失这个硬盘上的数据。而不会损失整个阵列数据。举例：一个阵列ABCD 4块硬盘+校验盘E。如果A-E盘中的任意一块坏了，对数据没有影响，用同容量或者更大容量（容量≤校验盘）的硬盘替换坏的硬盘即可。如果两块硬盘坏了，如A/E，那只会丢失A盘中的内容，B/C/D盘中的内容仍然可以访问，只要把盘拿出来，用LINUX LIVE CD启动，即可访问其中内容。<br>
9.扩容方便，直接往阵列里添加硬盘就可以了。唯一要求是容量≤校验盘。此外对容量没有要求（见第6点）。如果新加入的硬盘容量比校验盘大，需要先用这个硬盘替换校验盘，然后再把替换下来的校验盘作为新盘加入以增大阵列容量。</p>
<p>10.UNRAID，不仅可以快速的组磁盘阵列、快速的创建共享文件夹、快速的使用DOCKER容器跑各种服务，还可以创建各种各样的虚拟机，而且占用率极低<br>
11.使用体验比PVE好。比vmware esxi 使用简单，比黑群晖安装方便，且对硬盘要求不高</p>
<p>官网列出的Unraid的优点（tmtony翻译）</p>
<ol>
<li>unRAIDServer可以确保您的数据安全<br>
unRAID与传统RAID有所不同，原因有很多。在大多数情况下，RAID是在将文件写入RAID阵列时旋转的多个驱动器，并且数据分布在多个驱动器中。因此，即使一个文件也可以存在于多个磁盘上。<br>
unRAID中的共享网络资源可以跨越多个磁盘，但是它以与传统RAID完全不同的方式管理数据（tmtony翻译）。可以将unRAID配置为最多使用两个奇偶校验磁盘。与传统RAID一样，如果最多两个驱动器死机，这将防止数据丢失，从而确保数据安全。</li>
<li>unRAID有效<br>
unRAID可能不如传统RAID有效，但效率更高。由于所有驱动器都不会旋转以读取和写入数据，因此大大降低了功耗。<br>
unRAID对增加阵列的大小也有效。您可以添加任何大小的磁盘，即使该磁盘与其他磁盘的大小不匹配，也会以该大小增加阵列的大小。只要确保您的奇偶校验磁盘等于或大于阵列中的最大磁盘，数据就将是安全的。<br>
3.虚拟机支持<br>
unRAID具有内置的虚拟化支持，因此计算机上任何剩余的资源都可用于启动虚拟机。</li>
<li>unRAID具有出色的应用程序支持<br>
unRAID是从支持Docker的组中编译的。简而言之，Docker是一个容器平台(我爱帮助网)，允许应用程序在自己的安全环境中运行。它是目前全球数百万开发人员中最广泛使用的容器平台，它为数以千计的应用程序提供了UnRAID破解访问。<br>
5.硬件预算较低<br>
unRAID Server Pro最重要的好处之一就是它可以在常规PC硬件上运行。这意味着，只要您有适当的预算，就可以使自己的装配多么强大。如果您需要没有虚拟化或资源密集型应用程序的NAS，您甚至可以重新分配您拥有的旧计算机。</li>
</ol>
<p>unRAID Server Pro的适应场景</p>
<p>unRAID Server Pro是用于个人和小型企业的操作系统，它具有企业级功能，可让您使用应用程序，VM，存储设备和硬件的任意组合来配置计算机系统，以最大化性能和容量。<br>
突出优点<br>
简单性。柔韧性 可扩展性。模块化 Unraid使您能够使用首选的硬件，软件和操作系统来构建您一直想要的系统。<br>
控制您的数据<br>
打破单个操作系统的局限。Unraid允许您对系统资源进行分区，以存储和保护数据（tmtony翻译），运行任何应用程序和/或在隔离的环境中创建虚拟机。<br>
网络附加存储<br>
我们采用与硬件无关的方法来连接网络存储。在几乎所有具有x86 64位功能的系统上引导(我爱帮 助网)，并管理大小，速度，品牌和协议不同的磁盘阵列。按需缩放。添加更多磁盘，而无需重新平衡数据。通过运行更少的麻烦，运行更多应用程序，<br>
Application Server<br>
Unraid可使您从硬件中获得更多价值。使用任何基于Linux或Windows的x86应用程序。将应用程序放置在隔离的运行时环境中以防止冲突。通过我们的Web界面轻松控制应用程序。<br>
虚拟主机<br>
Unraid作为虚拟化主机运行，利用管理程序以安全和隔离的方式将资源划分给虚拟化来宾（tmtony翻译）。与Docker容器相比，可以为VM分配更多的资源，但仍提供隔离的访问。<br>
使您的系统专业化<br>
数字媒体特立独行者<br>
视频制作人，带有大量视频库的流媒体，媒体编辑，摄影师，音乐家和音乐收藏家使用Unraid降低了初始成本。从最少两个驱动器开始，然后一次使用一个或多个驱动器进行扩展。<br>
硬核游戏<br>
玩家也拥有媒体服务器并喜欢构建自己的自定义系统的游戏玩家使用Unraid来做所有事情而不会失去优势（tmtony翻译）。<br>
数据存储用户<br>
需要大量存储空间的设计师，3D动画师，开发人员，摄影师和其他用户使用Unraid在本地存储资产以便快速访问。与Apple Time Machine和Windows备份服务一起使用，可以从本地设备中存档大量不经常访问的数据。<br>
多操作系统用户<br>
软件工程师，游戏开发工作室，AR / VR设计师和大学实验室使用Unraid在多个平台上以及跨操作系统和设备上测试软件，并允许多个用户访问一个系统。</p>
<p>UNRAID的缺点：<br>
1.UNRAID是要授权的，一个Pro版本授权119美刀，可支持21块硬盘（7月10日的RC6版本支持24块硬盘，正好适合24盘位的机箱）。免费版本支持3块硬盘（1校验盘+2数据盘）。<br>
2. 读写速度不快，在30-40MB/S。个人认为家用够了。（有网友测试可达到70-90Mb/s左右，不同的硬件配置速度不同）</p>
<p>有网友 弄一个8盘位的服务器。软件方面决定用UnRaid系统<br>
而unRAID可以掉盘以后实时模拟故障盘上的数据</p>
<p>网友们的相关讨论</p>
<p>1 我感觉unraid还是有两把刷子的 系统非常轻量，现成的docker也很丰富，阵列设置也非常傻瓜<br>
2.玩 一样跑了Plex和PT之类的玩意 我现在觉得Docker真的很不错，我那些虚拟机太笨重了<br>
unRAID在U盘上只占用几百MB，内存也吃的很少 (我爱帮助网) 另外unRAID硬解编解码可以用8700k的核显，我发现那张1050Ti完全是浪费（不过可以Steam串流用）ESXi只要设置了初始化核显，独显直通必定Code 43报错，不知道unRAID这种基于KVM的虚拟化会不会有这个问题<br>
3.远程的话 unraid 和plex本来就都是网页图形界面管理的 本机和远程管理没区别 你就理解成unraid跟群晖差不多的一个nas操作系统 也能安装app 灵活度更高 但没有那么傻瓜而已<br>
4.docker好评，之前一直不理解，用了之后才发现让linux易用性提高了太多，本来一堆东西要装<br>
5.这个要看实时功耗，纸面并不准确。我有个朋友也是8700k做的nas，读取时，功耗44w，有下载任务的话再涨几w。<br>
plex 观看原盘负载也会增加，不过没有单独测试过。<br>
6.unraid 是挺好的方案。我是分批搞的，现在 nas 和 plex server 分开俩机器，nas负责下载和存储，pc干粗活<br>
7.unraid可以为vm和docker单独配置vlan，但我失败了，不知道问题在哪里<br>
8.请教下，unRaid能挂载 白群晖iSCSI 硬盘吗？</p>
<p>可点击链接加入群聊【Nas及矿渣交流】有更多交流和免费资源：</p>
<p>https://jq.qq.com/?_wv=1027&amp;k=5aw6p1W</p>
<p>相关扩展知识：</p>
<ol>
<li>
<p>unRAID Server nas的优点介绍及教程帮助<br>
http://www.52help.net/unraid/286.html</p>
</li>
<li>
<p>unRAIDServer 6.8.1 最新版本-unRAID NAS Server Pro 6.8.1 开心版以及保姆级安装教程帮助<br>
http://www.52help.net/unraid/266.html</p>
</li>
<li>
<p>unRAID Server-6.8.1-x86_64 汉化包<br>
http://www.52help.net/unraid/282.html</p>
</li>
<li>
<p>Unraid Server安装 apps 应用中心（Community Applications）以及apps及VMS虚拟机菜单不出现解决办法<br>
http://www.52help.net/unraid/270.html</p>
</li>
<li>
<p>unraid docker加速-修改unraid docker的镜像源（含国内网易等镜像源）<br>
http://www.52help.net/unraid/251.html</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unRAIDServer 6.8.1 最新版本-unRAID NAS Server Pro 6.8.1 开心版以及保姆级安装教程帮助]]></title>
        <id>https://newdy.cf/post/unraidserver-681-zui-xin-ban-ben-unraid-nas-server-pro-681-kai-xin-ban-yi-ji-bao-mu-ji-an-zhuang-jiao-cheng-bang-zhu/</id>
        <link href="https://newdy.cf/post/unraidserver-681-zui-xin-ban-ben-unraid-nas-server-pro-681-kai-xin-ban-yi-ji-bao-mu-ji-an-zhuang-jiao-cheng-bang-zhu/">
        </link>
        <updated>2020-02-21T18:57:29.000Z</updated>
        <content type="html"><![CDATA[<p>unraid server启动盘详细制作过程如下，总结一下主要几个关键步骤：</p>
<p>一、当然是先下载unRaidServer 6.8.1安装包</p>
<p>unRaidServer681（unRAID NAS Server Pro 6.8.1 专业版) 安装文件直接下载（无须从国外网站低速下载）国内网盘直接下载，网速快</p>
<p>外链:https://www.lanzous.com/b00z7ufjc 密码:hqb5<br>
因为云盘不支持 分卷压缩上传，所以改名了。</p>
<p>切记：下载后, 请将<br>
unRAIDServer-6.8.1-x86_64_k_fu11.A.rar 修改为 unRAIDServer-6.8.1-x86_64_k_fu11.part1.rar<br>
unRAIDServer-6.8.1-x86_64_k_fu11.B.rar 修改为 unRAIDServer-6.8.1-x86_64_k_fu11.part2.rar<br>
unRAIDServer-6.8.1-x86_64_k_fu11.C.rar 修改为 unRAIDServer-6.8.1-x86_64_k_fu11.part3.rar</p>
<p>然后打开任何一个 文件即可解压了。解压密码：52help.net</p>
<p>二、unRaidServer 6.8.1 启动优盘制作 及详细安装步骤要点，以及经验总强</p>
<p>1.尽量使用真正的优盘（U盘）（不要使用读卡器+TF卡），优盘容量要大于1G，一般选用8G 16G 即可。<br>
因为优盘只是用于启动和插件配置，其它是保存在你的机械硬盘中。<br>
2.如果你的优盘不是windows文件格式，请先将优盘(U盘）格式化 Fat32 分区，并且将U盘名称改为 UNRAID  (大写）<br>
3.如果你的优盘已经是Fat32分区格式，但有文件内容，请先清空内容<br>
4.将unRAIDServer-6.8.1-x86_64_k_fu11解压出来，将整个目录下的所有文件复制到U盘<br>
5.用管理员身份运行U盘上的 make_bootable.bat  （右键，选择用管理员身份执行）这样就可设置U盘可以启动<br>
正常你提示是选择 Y/N  选择 Y,  如果出错，则建议使用win7 系统来打开这个优盘(我爱帮助网源创)，右键管理员身份执行这个文件<br>
在win10下有部分优盘执行提示拒绝写入，但多数可以。而在win7下基本上都可以<br>
6. 将优盘插入要安装UnRaid的电脑USB接口，设置U盘启动或选择U盘启动<br>
7. 开机时可选择默认第1项（命令界面） 或第2项 （带UI界面），默认是不选择 ，2秒后自动加载第1项<br>
8. 如果正常的话，最后会显示启动完成，显示Unraid的版本号，并显示ipv4的IP地址<br>
如果是选择第2项 图形UI界面，需要输入 root 用户名，密码为空，登录后自动打开 unraid webUi 管理界面<br>
9.在其他电脑网页浏览器上(我爱帮助网源创) 输入刚才的IP地下，如http://192.168.0.114   登录这个IP, 也可直接输入http://tower （其中tower为unraid 服务器的默认名称）<br>
打开UnRaid server 管理界面（我是绑定了域名，直接用www.52help.net域名登录），进去后，就会提示激活，这时候不要选择试用及一个试用注册码</p>
<pre><code>只需要记录下来U盘的GUID：即Flash GUID即可，复制下来
</code></pre>
<p>10.在第一个页面 选择 关机按钮，把unRAID Server关机，把U盘再插回其它windows电脑，在dos命令状态<br>
使用keymaker.exe  你的flash guid号， 如  keymaker 0951-1643-3504-BB50F70D0138<br>
会在根目录 生成注册文件，将这个注册文件 改名为 BTRS.key  剪切到到U盘的config目录下即可</p>
<p>11.再把优盘重新插回需要使用unRaid Server的电脑，启动后，UNRAID就会显示 Pro版本了</p>
<ol start="12">
<li>如果优盘 有多个分区，则要将所有分区删除，重新分为一个分区才行</li>
</ol>
<p>Dos下注册的步骤<br>
1.用制作 了的优盘启动<br>
2. 抄下flash guid<br>
3. 关机拔下优盘<br>
4. 将优盘插入其它电脑<br>
5. 进入dos界面（管理员身份）如win10 不行，建议win7<br>
6. 输入 keymaker 你的GUID<br>
7. 把生成的key文件复制到config目录 下</p>
<p>按以上步骤即可安装成功。非常简单</p>
<p>安装成功后的界面<br>
<img src="https://newdy.cf/post-images/1582311539932.png" alt="" loading="lazy"><br>
使用的界面<br>
<img src="https://newdy.cf/post-images/1582311646140.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311653539.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311663424.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311669736.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311674921.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311682772.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311687825.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1582311693257.png" alt="" loading="lazy"><br>
三、unRAID Server 6.8.1 版本更新内容</p>
<p>Changes</p>
<p>Version 6.8.1 2020-01-10</p>
<p>Base distro:</p>
<ul>
<li>
<p>libuv: version 1.34.0</p>
</li>
<li>
<p>libvirt: version 5.10.0</p>
</li>
<li>
<p>mozilla-firefox: version 72.0.1 (CVE-2019-17026, CVE-2019-17015, CVE-2019-17016, CVE-2019-17017, CVE-2019-17018, CVE-2019-17019, CVE-2019-17020, CVE-2019-17021, CVE-2019-17022, CVE-2019-17023, CVE-2019-17024, CVE-2019-17025)</p>
</li>
<li>
<p>php: version 7.3.13 (CVE-2019-11044 CVE-2019-11045 CVE-2019-11046 CVE-2019-11047 CVE-2019-11049 CVE-2019-11050)</p>
</li>
<li>
<p>qemu: version 4.2.0</p>
</li>
<li>
<p>samba: version 4.11.4</p>
</li>
<li>
<p>ttyd: version 20200102</p>
</li>
<li>
<p>wireguard-tools: version 1.0.20200102</p>
</li>
</ul>
<p>Linux kernel:</p>
<ul>
<li>
<p>version 4.19.94</p>
</li>
<li>
<p>kernel_firmware: version 20191218_c4586ff (with additional Intel BT firmware)</p>
</li>
<li>
<p>CONFIG_THUNDERBOLT: Thunderbolt support</p>
</li>
<li>
<p>CONFIG_INTEL_WMI_THUNDERBOLT: Intel WMI thunderbolt force power driver</p>
</li>
<li>
<p>CONFIG_THUNDERBOLT_NET: Networking over Thunderbolt cable</p>
</li>
<li>
<p>oot: Highpoint rr3740a: version v1.19.0_19_04_04</p>
</li>
<li>
<p>oot: Highpoint r750: version v1.2.11-18_06_26 [restored]</p>
</li>
<li>
<p>oot: wireguard: version 0.0.20200105</p>
</li>
</ul>
<p>Management:</p>
<ul>
<li>
<p>add cache-busting params for noVNC url assets</p>
</li>
<li>
<p>emhttpd: fix cryptsetup passphrase input</p>
</li>
<li>
<p>network: disable IPv6 for an interface when its settings is &quot;IPv4 only&quot;.</p>
</li>
<li>
<p>webgui: Management page: fixed typos in help text</p>
</li>
<li>
<p>webgui: VM settings: fixed Apply button sometimes not working</p>
</li>
<li>
<p>webgui: Dashboard: display CPU load full width when no HT</p>
</li>
<li>
<p>webgui: Docker: show 'up-to-date' when status is unknown</p>
</li>
<li>
<p>webgui: Fixed: handle race condition when updating share access rights in Edit User</p>
</li>
<li>
<p>webgui: Docker: allow to set container port for custom bridge networks</p>
</li>
<li>
<p>webgui: Better support for custom themes (not perfect yet)</p>
</li>
<li>
<p>webgui: Dashboard: adjusted table positioning</p>
</li>
<li>
<p>webgui: Add user name and user description verification</p>
</li>
<li>
<p>webgui: Edit User: fix share access assignments</p>
</li>
<li>
<p>webgui: Management page: remove UPnP conditional setting</p>
</li>
<li>
<p>webgui: Escape shell arg when logging csrf mismatch</p>
</li>
<li>
<p>webgui: Terminal button: give unsupported warning when Edge/MSIE is used</p>
</li>
<li>
<p>webgui: Patched vulnerability in auth_request</p>
</li>
<li>
<p>webgui: Docker: added new setting &quot;Host access to custom networks&quot;</p>
</li>
<li>
<p>webgui: Patched vulnerability in template.php</p>
</li>
</ul>
<p>版本变化 中文说明</p>
<pre><code> 变化
</code></pre>
<p>版本6.8.1 2020-01-10</p>
<p>发行版基础：<br>
-libuv：版本1.34.0</p>
<p>-libvirt：版本5.10.0</p>
<p>-mozilla-firefox：版本72.0.1（CVE-2019-17026，CVE-2019-17015，CVE-2019-17016，CVE-2019-17017，CVE-2019-17018，CVE-2019-17019，CVE-2019- 17020，CVE-2019-17021，CVE-2019-17022，CVE-2019-17023，CVE-2019-17024，CVE-2019-17025）</p>
<p>-php：版本7.3.13（CVE-2019-11044 CVE-2019-11045 CVE-2019-11046 CVE-2019-11047 CVE-2019-11049 CVE-2019-11050）</p>
<p>-qemu：版本4.2.0</p>
<p>-samba：版本4.11.4</p>
<p>-ttyd：版本20200102</p>
<p>-线卫工具：版本1.0.20200102</p>
<p>Linux内核：<br>
-版本4.19.94</p>
<p>-kernel_firmware：版本20191218_c4586ff（带有其他Intel BT固件）</p>
<p>-CONFIG_THUNDERBOLT：Thunderbolt支持</p>
<p>-CONFIG_INTEL_WMI_THUNDERBOLT：英特尔WMI雷电强制电源驱动器</p>
<p>-CONFIG_THUNDERBOLT_NET：通过Thunderbolt电缆联网</p>
<p>-oot：Highpoint rr3740a：版本v1.19.0_19_04_04</p>
<p>-oot：Highpoint r750：v1.2.11-18_06_26版[已恢复]</p>
<p>-等待：wireguard：版本0.0.20200105</p>
<p>管理：<br>
-为noVNC网址资产添加缓存清除参数</p>
<p>-emhttpd：修复cryptsetup密码输入</p>
<p>-网络：当接口的设置为“仅IPv4”时，禁用该接口的IPv6。</p>
<p>-webgui：管理页面：修复了帮助文本中的错别字</p>
<p>-webgui：VM设置：修复了“应用”按钮有时不起作用</p>
<p>-webgui：仪表板：无HT时显示CPU负载全宽</p>
<p>-webgui：Docker：状态未知时显示“最新”</p>
<p>-webgui：已修复：在“编辑用户”中更新共享访问权限时处理竞争情况</p>
<p>-webgui：Docker：允许为自定义桥网络设置容器端口</p>
<p>-webgui：更好地支持自定义主题（尚不完善）</p>
<p>-webgui：控制板：调整表位置</p>
<p>-webgui：添加用户名和用户描述验证</p>
<p>-webgui：编辑用户：修复共享访问分配</p>
<p>-webgui：管理页面：删除UPnP条件设置</p>
<p>-webgui：记录csrf不匹配时转义shell arg</p>
<p>-webgui：终端按钮：使用Edge / MSIE时发出不受支持的警告</p>
<p>-webgui：auth_request中的修补漏洞</p>
<p>-webgui：Docker：添加了新设置“对自定义网络的主机访问”</p>
<p>-webgui：template.php中的已修补漏洞</p>
<p>注意：使用usb3.0 usb3.1 的u盘可能不支持。建议用2.0的优盘</p>
<p>unRAID Server-6.8.1-x86_64 汉化包</p>
<ol>
<li>
<p>先下载 unRAID Server-6.8.1-x86_64 汉化包 网盘下载地址</p>
<p>外链: https://www.lanzous.com/b00z80brc  密码:e9qr</p>
</li>
<li>
<p>切记，下载后请将：</p>
<p>unRAIDServer-6.8.1-x86_64汉化包.A.rar   改为 unRAIDServer-6.8.1-x86_64汉化包.part1.rar<br>
unRAIDServer-6.8.1-x86_64汉化包.B.rar   改为 unRAIDServer-6.8.1-x86_64汉化包.part2.rar</p>
</li>
<li>
<p>然后再进行解压. 把2个汉化包文件 解压覆盖原文件即可（最好先备份旧英文版文件，以防万一）</p>
</li>
</ol>
<p>压缩包解压密码为：52help.net</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[unraid6.7.2安装]]></title>
        <id>https://newdy.cf/post/unraid672-an-zhuang/</id>
        <link href="https://newdy.cf/post/unraid672-an-zhuang/">
        </link>
        <updated>2020-02-21T18:24:15.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://newdy.cf/post-images/1582309503734.png" alt="" loading="lazy"><br>
注意 4 help 打开复制翻译 ,它就是一教程<br>
<img src="https://newdy.cf/post-images/1582309522668.png" alt="" loading="lazy"><br>
大佬说话简而言之，这里啰嗦一下<br>
格式化U盘 格式FAT32 卷标 UNRAID 大写<br>
用第一张图的第6个工具把unraid安装到U盘中<br>
<img src="https://newdy.cf/post-images/1582309546445.png" alt="" loading="lazy"><br>
将crack目录中的文件复制到U盘根目录，拔U盘，插到服务器，启动<br>
找到服务器IP，浏览器直接IP进入，按图打开，找到 Flash GUID 后面的ID<br>
<img src="https://newdy.cf/post-images/1582309577402.png" alt="" loading="lazy"><br>
用第一张图中的第5个行成key,如第一张图中的3就是。<br>
服务器关机，拔U盘插到操作电脑，把刚生成的BTRS.key复制到U盘的config文件中。完事<br>
有大佬做了视频 53，对我这小白太有用处了，https://space.bilibili.com/28457?share_medium=android&amp;share_source=more&amp;bbid=ehksHyZDIRMmHn8dYR1hVmdVJF46SXpJek14infoc&amp;ts=1573127133669</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Watchtower - 自动更新 Docker 镜像与容器]]></title>
        <id>https://newdy.cf/post/watchtower-zi-dong-geng-xin-docker-jing-xiang-yu-rong-qi/</id>
        <link href="https://newdy.cf/post/watchtower-zi-dong-geng-xin-docker-jing-xiang-yu-rong-qi/">
        </link>
        <updated>2020-02-20T13:17:14.000Z</updated>
        <summary type="html"><![CDATA[<p>前言<br>
在早前部署Awesome TTRSS时,作者在docker-compose里配置了Watchtower,于是找到 Github 官方项目研究了下,根据官方文档简单整理了一下常用参数以备用.</p>
<p>Watchtower 是一款实现自动化更新 Docker 镜像与容器的实用工具.它监控着所有正在运行的容器以及相关镜像,当检测本地镜像与镜像仓库中的镜像有差异时,会自动拉取最新镜像并使用最初部署时的参数重新启动相应的容器.</p>
]]></summary>
        <content type="html"><![CDATA[<p>前言<br>
在早前部署Awesome TTRSS时,作者在docker-compose里配置了Watchtower,于是找到 Github 官方项目研究了下,根据官方文档简单整理了一下常用参数以备用.</p>
<p>Watchtower 是一款实现自动化更新 Docker 镜像与容器的实用工具.它监控着所有正在运行的容器以及相关镜像,当检测本地镜像与镜像仓库中的镜像有差异时,会自动拉取最新镜像并使用最初部署时的参数重新启动相应的容器.</p>
<!-- more -->
<p>containrrr/watchtower</p>
<!-- more -->
<p>部署<br>
快速启动<br>
以容器的方式启动 Watch­tower</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower<br>
清理旧镜像<br>
镜像在更新后旧镜像标签会变为none,长期自动更新会导致过多的none镜像占用空间,加入--cleanup参数可以在每次更新后自动删除none镜像.</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup<br>
指定容器更新<br>
如无需自动更新所有稳定运行的容器,可以配置仅更新指定容器,只需要在命令后加上容器名.例如只更新nginx和redis.</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup <br>
nginx redis<br>
注意指定容器需填写 容器名 ,并非镜像名.由于启动容器时可能没有定义 --name 参数,请执行 docker ps 查询核对容器名.<br>
指定容器排除更新<br>
如需要更新大部分容器,而排除掉少数容器不更新,可以加上 --label=com.centurylinklabs.watchtower.enable=false 的参数.命令结尾加上不更新的容器名.例如希望自动更新所有容器,而不更新nginx和redis.</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
--label=com.centurylinklabs.watchtower.enable=false <br>
containrrr/watchtower <br>
--cleanup <br>
nginx redis<br>
注意指定容器需填写 容器名 ,并非镜像名.由于启动容器时可能没有定义 --name 参数,请执行 docker ps 查询核对容器名.<br>
配置自动更新频率<br>
Watch­tower 默认每 5 分钟轮询一次,可以使用以下参数配置更新的频率.</p>
<p>--interval,-i 配置更新周期,默认300秒.<br>
--schedule,-s 配置定时更新,使用Cron表达式,例如&quot;0 0 4 * * *&quot;.即每天凌晨4点更新.<br>
每小时更新一次</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup <br>
-i 3600<br>
每天凌晨4点更新</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup <br>
-s &quot;0 0 4 * * *&quot;<br>
手动更新<br>
使用手动更新的方式,运行一次Watch­tower容器来更新所需的容器,更新后会自动删除本次运行的Watch­tower容器.只需要加上--rm和--run-once参数即可.同时也可以配合以上指定容器或指定排除容器的参数来使用.</p>
<p>docker run --rm <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
--label=com.centurylinklabs.watchtower.enable=false <br>
containrrr/watchtower <br>
--cleanup <br>
--run-once <br>
nginx redis<br>
注意指定容器需填写 容器名 ,并非镜像名.由于启动容器时可能没有定义 --name 参数,请执行 docker ps 查询核对容器名.<br>
手动运行更新时会出现以下消息,表示正在更新,请耐心等待几分钟.</p>
<p>time=&quot;2020-02-18T03:58:24Z&quot; level=info msg=&quot;Running a one time update.&quot;<br>
随后提示找到更新镜像,停止容器,更新镜像,重启容器并移除旧镜像.至此更新完毕.</p>
<p>time=&quot;2020-02-18T04:02:45Z&quot; level=info msg=&quot;Found new xxxx/xxxx:latest image (sha256:10383f5b5720d7e1fxxxx137034c69b7f6xxxxxxafcc4e9d508b561af77)&quot;<br>
time=&quot;2020-02-18T04:02:45Z&quot; level=info msg=&quot;Stopping /xxxx (2e9ce1ebe319f3a35d80bxxxxxxxxxx6763ada155da957acb24fe76fc8a8c5) with SIGTERM&quot;<br>
time=&quot;2020-02-18T04:02:46Z&quot; level=info msg=&quot;Creating /xxxx&quot;<br>
time=&quot;2020-02-18T04:02:46Z&quot; level=info msg=&quot;Removing image sha256:ff4ee4caaa237174080c0d545xxxxxx</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7.3防火墙配置]]></title>
        <id>https://newdy.cf/post/centos73-fang-huo-qiang-pei-zhi/</id>
        <link href="https://newdy.cf/post/centos73-fang-huo-qiang-pei-zhi/">
        </link>
        <updated>2020-02-20T10:55:40.000Z</updated>
        <content type="html"><![CDATA[<p>1、查看firewall服务状态<br>
systemctl status firewalld<br>
<img src="https://newdy.cf/post-images/1582196168648.png" alt="" loading="lazy"></p>
<p>2、查看firewall的状态<br>
firewall-cmd --state<br>
<img src="https://newdy.cf/post-images/1582196217057.png" alt="" loading="lazy"></p>
<p>3、开启、重启、关闭、firewalld.service服务</p>
<h1 id="开启">开启</h1>
<p>service firewalld start</p>
<h1 id="重启">重启</h1>
<p>service firewalld restart</p>
<h1 id="关闭">关闭</h1>
<p>service firewalld stop</p>
<p>4、查看防火墙规则<br>
firewall-cmd --list-all<br>
<img src="https://newdy.cf/post-images/1582196328235.png" alt="" loading="lazy"></p>
<p>5、查询、开放、关闭端口</p>
<p>复制代码</p>
<h1 id="查询端口是否开放">查询端口是否开放</h1>
<p>firewall-cmd --query-port=8080/tcp</p>
<h1 id="开放80端口">开放80端口</h1>
<p>firewall-cmd --permanent --add-port=80/tcp</p>
<h1 id="移除端口">移除端口</h1>
<p>firewall-cmd --permanent --remove-port=8080/tcp</p>
<p>#重启防火墙(修改配置后要重启防火墙)<br>
firewall-cmd --reload</p>
<h1 id="参数解释">参数解释</h1>
<p>1、firwall-cmd：是Linux提供的操作firewall的一个工具；<br>
2、--permanent：表示设置为持久；<br>
3、--add-port：标识添加的端口；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装CentOS7.6 Minimal ISO系统并增加图形化桌面]]></title>
        <id>https://newdy.cf/post/an-zhuang-centos76-minimal-iso-xi-tong-bing-zeng-jia-tu-xing-hua-zhuo-mian/</id>
        <link href="https://newdy.cf/post/an-zhuang-centos76-minimal-iso-xi-tong-bing-zeng-jia-tu-xing-hua-zhuo-mian/">
        </link>
        <updated>2020-02-20T08:04:20.000Z</updated>
        <content type="html"><![CDATA[<p>1.配置网络（因为安装过程需要网络yum源。当然你这里如果有完整系统镜像做本地yum源或者其它本地yum源可以满足安装需求的话没有网络也是可以的。）</p>
<p>2.查看yum源是否可用：</p>
<p>yum repolist</p>
<p>3.执行命令：</p>
<p>yum grouplist  # 先检查一下系统支持哪些桌面安装类型，见下图<br>
<img src="https://newdy.cf/post-images/1582185918274.png" alt="" loading="lazy"><br>
yum groupinstall -y &quot;X Window System&quot;  # X Window System是执行在UNIX系统上的视窗系统，出现complete表示成功。据其它同行说此步骤不执行亦可。</p>
<p>yum groupinstall -y &quot;GNOME Desktop&quot;  # 表示安装GNOME Desktop类型的桌面，出现complete表示成功；查阅其它经验贴发现也可以选择KDE Desktop，安装方法请参考其它资料。<br>
报错：</p>
<p>Transaction check error:</p>
<p>file /boot/efi/EFI/redhat from install of fwupdate-efi-12-5.el7.x86_64 conflicts with file from package grub2-common-1:2.02-0.65.el7_4.2.noarch</p>
<p>file /boot/efi/EFI/redhat from install of fwupdate-efi-12-5.el7.x86_64 conflicts with file from package grub2-efi-1:2.02-0.65.el7_4.2.x86_64</p>
<p>解决：表示包的版本有冲突，貌似是系统bug；</p>
<p>执行</p>
<p>yum update grub2-common</p>
<p>yum install grub2-efi</p>
<p>yum install fwupdate</p>
<p>再重新执行yum groupinstall -y &quot;GNOME Desktop&quot;即可，参考链接：https://www.createdpro.com/a/100006。</p>
<p>startx  # 表示进入桌面</p>
<p>报错：</p>
<p>xauth: file /root/.serverauth.2669 does not exist  # 这只是报错的其中一条，还有几条同类型报错，因当时不便截图故不能一 一列出。</p>
<p>解决：在有网的情况下执行yum upgrade 该命令表示安装新内核，重启后即可正常进入桌面。参考链接：https://www.cnblogs.com/rgqancy/p/5554814.html。</p>
<p>4.进入桌面后按提示输入一步步执行完成即可。注意事项：走到如下图这一步时只能以英文字母开头不能以数字开头，你输入全名时下一行的用户名会跟着自动输入，当用户名不跟着全名自动输入时说明系统不支持该类名称，但系统并不报错，只是等你到最后会发现一切就绪后桌面无图标并且鼠标右键无效无法操作；到输入密码这一步时，要求密码不能和名称有相同的字母或数字，否则无法进入下一步。<br>
<img src="https://newdy.cf/post-images/1582185962009.png" alt="" loading="lazy"><br>
至此桌面安装完毕，以下为知识点扩展及经验总结：</p>
<p>1.整个过程报错几次，当时没细看报错，导致操作了几遍才解决，差点有重新装系统的冲动了。首先遇到报错不要着急要看一下报错信息再解决，不能盲目解决导致效率低，遇到问题要自信沉稳。</p>
<p>2.yum groupinstall 这个命令的新命令据说可以这样写yum groups install，本人未亲自验证。</p>
<p>3.卸载命令yum groupremove</p>
<p>4.设置开机启动模式为图形模式（是否需要操作这一步有待核实，因为我当时操作了，但与别人交流时他们并未操作该步骤）</p>
<p>systemctl set-default graphical.target或者ln -sf /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target</p>
<p>设置开机启动模式为文本模式（这一步在装桌面肯定是不用执行的啦，我在这里写出来只是为了知识点的扩展而已）：ln -sf/lib/systemd/system/multi-user.target /etc/systemd/system/default.target</p>
<p>5.期间如果reboot后无法正常进入桌面，亦无法进入命令行模式时可以采用Xshell等远程工具连接进入命令行。（有人说可以在终端前用Ctrl+Alt+F*（*表示1-7）之间选择即可以进入控制台来操作，本人未亲自验证）</p>
<p>6.这种情况建议最好安装everything ISO带桌面的系统，一步到位。选择系统时不要选最新的，求稳不求新，同事下载的就是目前最新的7.6版本，新版本难免有bug</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dockerfile常用指令详解&镜像缓存特性]]></title>
        <id>https://newdy.cf/post/dockerfile-chang-yong-zhi-ling-xiang-jie-andjing-xiang-huan-cun-te-xing/</id>
        <link href="https://newdy.cf/post/dockerfile-chang-yong-zhi-ling-xiang-jie-andjing-xiang-huan-cun-te-xing/">
        </link>
        <updated>2020-02-20T05:52:02.000Z</updated>
        <content type="html"><![CDATA[<p>Dockerfile简介<br>
Dockerfile 是Docker中用于定义镜像自动化构建流程的配置文件。在Dockerfile中，包含了构建镜像过程中需要执行的命令和其他操作。通过Dockerfile可以更加清晰，明确的给定Docker镜像的制作过程，由于仅是简单，小体积的文件，在网络等介质中传递的速度快，能够更快的实现容器迁移和集群部署。<br>
Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>相对于提交容器修改在进行镜像迁移的方式相比，使用Dockerfile有很多优势：</p>
<p>Dockerfile的体积远小于镜像包，更容易进行快速迁移和部署。<br>
环境构建流程记录在Dockerfile中，能够直观的看到镜像构建的顺序和逻辑。<br>
使用Dockerfile构建镜像能够更轻松的实现自动部署等自动化流程。<br>
在修改环境搭建细节时，修改Dockerfile文件更加简单。<br>
实际开发使用中很少会选择容器提交这种方法来构建镜像，而是几乎采用Dockerfile来制作镜像。</p>
<p>Docker执行Dockerfile的大致流程：<br>
（1）docker会从Dockerfile文件头FROM指定的基础镜像运行一个容器<br>
（2）然后执行一条指令，对容器作出修改。<br>
（3）接着执行类似于docker commit的操作，创建一个新的镜像层。<br>
（4）在基于刚创建的镜像运行一个新的容器。<br>
（4）执行dockerfile中的下一条指令，直到所有指令都执行完毕。<br>
docker会删除中间层创建的容器，但不会删除中间层镜像，所以可以使用docker run运行一个中间层容器，从而查看每一步构建后的镜像状态，，这样就可以进行调试。</p>
<p>Dockerfile 基本结构<br>
Dockerfile 又一行行命令语句组成，并且支持以#开头的注释行。<br>
Dockerfile 分为四部分：基础镜像信息，维护者信息，镜像操作指令，容器启动时执行指令。<br>
例如，以下为一个完整的Dockerfile：</p>
<h1 id="this-dockerfile-uses-the-ubuntu-image">This dockerfile uses the ubuntu image</h1>
<h1 id="version-2-edition-1">VERSION 2 - EDITION 1</h1>
<h1 id="author-docker_user">Author: docker_user</h1>
<h1 id="command-format-instruction-arguments-command">Command format: Instruction [arguments / command] ..</h1>
<h1 id="base-image-to-use-this-must-be-set-as-the-first-line">Base image to use, this must be set as the first line</h1>
<p>1，第一行必须指定，基础镜像信息<br>
FROM ubuntu</p>
<h1 id="maintainer-docker_user-docker_user-at-emailcom-docker_user">Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)</h1>
<p>2，维护者信息<br>
MAINTAINER docker_user docker_user@email.com</p>
<h1 id="commands-to-update-the-image">Commands to update the image</h1>
<p>3，镜像操作指令<br>
RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list<br>
RUN apt-get update &amp;&amp; apt-get install -y nginx<br>
RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf</p>
<h1 id="commands-when-creating-a-new-container">Commands when creating a new container</h1>
<p>4，容器启动执行指令<br>
CMD /usr/sbin/nginx<br>
其中，已开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如RUN指令。每执行一条RUN指令，镜像添加新的一层，并提交；最后是CMD指令，来指明运行容器时的操作命令。</p>
<p>Dockerfile 常用指令<br>
以下常见的dockerfile指令，基本包含常用的90%功能。</p>
<p>常用指令目录：<br>
1，FROM--指定基础镜像<br>
2，MAINTAINER--指定维护者信息<br>
3，RUN--运行指定的命令<br>
4，CMD--容器启动时执行的命令<br>
5， EXPOSE--声明容器的服务端口<br>
6，ENV--设置环境变量<br>
7，ARG--构建参数<br>
8，COPY--复制文件或目录<br>
9，ADD--更高级的复制文件/目录<br>
10，ENTRYPOINT--入口点<br>
11，ENTRYPOINT与CMD指令结合使用<br>
12，VOLUME--定义匿名卷<br>
13，WORKDIR--指定工作目录<br>
14，USER--指定当前用户<br>
15，ONBUILD--为镜像添加触发器<br>
1，FROM--指定基础镜像<br>
第一条指令必须为FROM指令。<br>
如果不以任何镜像为基础，那么写法如下，同时意味着接下来所写的指令将作为镜像的第一层开始：<br>
FROM nginx<br>
FROM 指令支持三种格式：</p>
<p>FROM <image><br>
FROM <image>:<tag><br>
FROM <image>:<digest></p>
<p>三种写法，第二种和第三种是可选项，如果没有选择，那么默认为latest。</p>
<p>在Dockerfile中可以多次出现FROM指令，当FROM第二次或者之后出现时，表示在此刻构建时，要将当前指出镜像的内容合并到此刻构建镜像的内容。</p>
<p>ARG是唯一可以在FROM之前执行的参数：</p>
<p>ARG  CODE_VERSION=latest<br>
FROM base:${CODE_VERSION}<br>
CMD  /code/run-app</p>
<p>FROM extras:${CODE_VERSION}<br>
CMD  /code/run-extras<br>
2，MAINTAINER--指定维护者信息<br>
格式为：MAINTAINER <name>，指定维护者信息（镜像维护者姓名或邮箱），可选项。<br>
例如：<br>
MAINTAINER docker_user docker_user@email.com<br>
3，RUN--运行指定的命令<br>
RUN有两种格式：</p>
<p>RUN <command><br>
RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</p>
<p>前者将在shell终端运行命令，即/bin/sh -c; 后者则使用exec执行。指定使用其它终端可以通过第二种方式实现，例如使用bash终端： RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]。</p>
<p>注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层，多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。一般一个RUN指令后边可以跟多个要执行的命令（使用&amp;&amp;符即可），当命令较长时可以使用&quot;&quot;来换行。<br>
例子如下：</p>
<p>RUN yum -y install gcc* pcre-devel openssl-devel zlib-devel unzip make vim net-tools elinks tree <br>
&amp;&amp; groupadd nginx <br>
&amp;&amp;  useradd  nginx -g nginx  -s /sbin/nologin<br>
4，CMD--容器启动时执行的命令<br>
CMD支持三种格式：</p>
<p>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式；<br>
CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；<br>
CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给 ENTRYPOINT 的默认参数；</p>
<p>指定启动容器时执行的命令，每个dockerfile只能有一条CMD命令。如果指令了多条命令，只有最后一条会被执行。</p>
<p>如果用户启动容器时候指定了运行的命令，则会覆盖掉CMD指定的命令。</p>
<p>补充细节：如果不是使用shell（/bin/sh）这种方式，”[]“中括号这里边包括参数的一定要用双引号,千万不能写成单引号。原因是参数传递后，docker解析的是一个JSON array<br>
例如：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
CMD echo hello world<br>
CMD echo hello china<br>
[root@sqm-docker01 dfs]# docker run --rm test:v1   #只有最后一条CMD命令会被执行<br>
hello china<br>
[root@sqm-docker01 dfs]# docker run --rm test:v1 echo &quot;hello friend&quot;  #在启动容器时指定运行命令，会将其覆盖<br>
hello friend<br>
采用exec格式，那么上面的例子改为：</p>
<p>FROM centos:latest<br>
CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello world&quot;]<br>
CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello china&quot;]<br>
还有一种情况下CMD会结合ENTRYPOINT指令使用，后面会讲到。</p>
<p>5， EXPOSE--声明容器的服务端口<br>
格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>
在Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用户则是运行时使用随机端口映射时，也就是docker run -P 时，会自动随机映射EXPOSE的端口。<br>
要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。<br>
例如：<br>
EXPOSE 80 443</p>
<p>6，ENV--设置环境变量<br>
格式有两种：</p>
<p>ENV <key> <value><br>
ENV <key1>=<value1> <key2>=<value2>...</p>
<p>两者的区别是第一种是一次设置一个，第二种是一次设置多个。</p>
<p>ENV这个指令就是指定一个环境变量，会被后续RUN指定使用，并在容器运行时保持。</p>
<p>ENV VERSION=1.0 DEBUG=on <br>
NAME=&quot;Happy Feet&quot;<br>
这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和shell下的行为是一致的。<br>
举例如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM busybox:latest<br>
ENV var1=haha var2=hehe<br>
RUN echo $var1 &gt; a.txt &amp;&amp; echo $var2 &gt; b.txt<br>
执行dockerfile后，进行容器查看文件：<br>
[root@sqm-docker01 dfs]# docker run --rm test:v2 /bin/sh<br>
/ # cat a.txt<br>
haha<br>
/ # cat b.txt<br>
hehe<br>
#并且定义的变量会在容器运行时保持：<br>
/ # echo $var1<br>
haha<br>
/ # echo $var2<br>
hehe<br>
7，ARG--构建参数</p>
<p>格式：<br>
ARG <name>[=<default value>]</p>
<p>构建参数和ENV的效果一样，都是设置环境变量。所不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在的这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为docker history还是可以看到所有值的。</p>
<p>#用法一：在执行docker build构建时传递参数</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ARG user<br>
ARG password<br>
RUN echo $user &gt; a.txt <br>
&amp;&amp; echo $password &gt;&gt; a.txt<br>
#传递两个参数时，则在每个参数中添加--build-arg。<br>
[root@sqm-docker01 dfs]# docker build --build-arg user=sqm --build-arg password=123.com  -t arg:v1 .<br>
#运行容器，参数传递成功<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v1 /bin/bash<br>
root@4809b0c54f8d:/# cat a.txt<br>
sqm<br>
123.com<br>
#与ENV不同，在容器中是不会存在这些变量的<br>
root@9383b7d3d21e:/# echo $user</p>
<p>root@9383b7d3d21e:/# echo $password</p>
<p>root@9383b7d3d21e:/#<br>
注意：如果指定了该参数，但Dockerfile中未使用，构建过程中会输出警告。</p>
<p>#用法二：在dockerfile中设定一个默认值，如果ARG指令具有默认值，并且在构建时未传递任何参数，那么构建其将使用该默认值</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ARG user=zhangsan<br>
ARG password=123456<br>
RUN echo $user $password &gt; a.txt<br>
#构建镜像且不传递任何参数：<br>
[root@sqm-docker01 dfs]# docker build -t arg:v2 .<br>
#运行容器，参数传递成功<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v2 /bin/bash<br>
root@b52fa70086de:/# cat a.txt<br>
zhangsan 123456<br>
#多阶段构建中每个阶段都必须包含arg指令：</p>
<p>FROM busybox<br>
ARG user<br>
RUN ./run/setup $user</p>
<p>FROM busybox<br>
ARG user<br>
RUN ./run/other $user<br>
#ENV变量会覆盖同名的ARG变量：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ARG user=zhangsan<br>
ENV user lisi<br>
RUN echo $user &gt; a.txt<br>
[root@sqm-docker01 dfs]# docker build -t arg:v3 .<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v3 /bin/bash<br>
root@a2aefd05efee:/# cat a.txt<br>
lisi<br>
#ARG和ENV指令结合使用：（一般这种用法，不常用）</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
ARG var<br>
ENV user=${var}<br>
RUN echo $user &gt; a.txt<br>
[root@sqm-docker01 dfs]# docker build --build-arg var=zhangsan -t arg:v4 .<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v4 /bin/bash<br>
[root@26bf8c139a3f /]# cat a.txt<br>
zhangsan<br>
8，COPY--复制文件或目录‘’<br>
格式：</p>
<p>COPY [--chown=<user>:<group>] &lt;源路径&gt;... &lt;目标路径&gt;<br>
COPY [--chown=<user>:<group>] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</p>
<p>和RUN指令一样，也有两种格式，前者在shell终端运行; 后者则使用exec执行。</p>
<p>&lt;源路径&gt;为宿主机的上的路径，可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<p>COPY hom* /mydir/<br>
COPY hom?.txt /mydir/<br>
注意：&lt;源路径&gt;必须是在build上下文目录中，也就是Dockerfile配置文件所在的目录及下面的递归目录，如果拷贝上下文之外目录下的文件（不是Dockerfile所在的目录），则无法拷贝。<br>
build上下文的概念可参考：https://www.cnblogs.com/sparkdev/p/9573248.html</p>
<p>&lt;目标路径&gt;是容器中的路径，可以是绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。可以使用如下命令指定：</p>
<p>COPY [--chown=:] ...<br>
COPY [--chown=:] [&quot;&quot;,... &quot;&quot;] （包含空格的路径需要这种形式）<br>
–chown功能仅在用于构建Linux容器的Dockerfiles上受支持<br>
例如：<br>
COPY --chown=nginx:nginx files* /somedir/</p>
<p>举例：</p>
<p>[root@sqm-docker01 dfs]# echo &quot;hello world&quot; &gt; index.html<br>
[root@sqm-docker01 dfs]# echo aaaaaa &gt; a.txt<br>
[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
COPY ./index.html /usr/share/nginx/html/<br>
COPY ./a.txt /test/<br>
[root@sqm-docker01 dfs]# docker run --rm  nginx:v1  /bin/bash<br>
root@8a1ee4925b43:/# cat /usr/share/nginx/html/index.html<br>
hello world<br>
#即使目标目录不存在，会自己事先创建<br>
root@8a1ee4925b43:/# cat /test/a.txt<br>
aaaaaa<br>
##拷贝整个目录：<br>
格式：COPY src WORKDIR/src<br>
例如：</p>
<p>[root@sqm-docker01 dfs]# cat test/a.txt<br>
addddddddddddaaaaa<br>
[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
COPY ./test  /usr/share/nginx/test/<br>
#必须要在目标路径下指定要拷贝的目录，不然只拷贝源目录中的文件，而不拷贝目录</p>
<p>#进入容器查看整个目录及其目录下的文件<br>
[root@sqm-docker01 dfs]# docker run --rm nginx:v2 /bin/bash<br>
root@4eae96cbe364:/# cd /usr/share/nginx/<br>
root@4eae96cbe364:/usr/share/nginx# ls<br>
html  test<br>
root@4eae96cbe364:/usr/share/nginx# cat test/a.txt<br>
addddddddddddaaaaa<br>
9，ADD--更高级的复制文件/目录<br>
格式为：</p>
<p>ADD [--chown=<user>:<group>] &lt;源路径&gt;... &lt;目标路径&gt;<br>
ADD [--chown=<user>:<group>] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</p>
<p>ADD指令和COPY 的格式和性质基本一致。但是在 COPY`基础上增加了一些功能：可以是一个URL（通过URL下载下来自动设置权限600）；还可以是一个tar文件（自动解压为目录)。</p>
<p>举例：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
ADD nginx-1.8.0.tar.gz  /usr/src<br>
[root@sqm-docker01 dfs]# docker run --rm  nginx:v3 /bin/bash<br>
[root@0c8d6789aa4c /]# cd /usr/src/<br>
[root@0c8d6789aa4c src]# ls<br>
debug  kernels  nginx-1.8.0     #自动解压tar包<br>
[root@0c8d6789aa4c src]# ls nginx-1.8.0/<br>
CHANGES  CHANGES.ru  LICENSE  README  auto  conf  configure  contrib  html  man  src<br>
#通过url下载链接文件放到目标路径下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
ADD http://nginx.org/download/nginx-1.9.0.tar.gz /</p>
<p>[root@sqm-docker01 dfs]# docker run --rm  nginx:v4 /bin/bash<br>
[root@b9d978e3a333 /]# ls -lh nginx-1.9.0.tar.gz<br>
-rw------- 1 root root 835K Apr 28  2015 nginx-1.9.0.tar.gz<br>
#默认权限600<br>
#与COPY的区别：<br>
用于与COPY类似，不同的是COPY的只能是本地文件/目录，如果src是归档文件（tar,zip,tgz,xz等），使用ADD命令文件会被自动解压到dest。</p>
<p>因此在COPY和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY，仅在需要自动解压缩的场合使用 ADD。</p>
<p>10，ENTRYPOINT--入口点<br>
两种格式：</p>
<p>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]（exec格式）<br>
ENTRYPOINT command param1 param2（shell中执行）。</p>
<p>ENTRYPOINT 的 目的和CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比CMD要略显繁琐，需要通过docekr run的参数 --entrypoint 来指定。</p>
<p>#与CMD比较说明：<br>
1）相同点：只能写一条，如果写多条，那么只有最后一条生效。<br>
容器启动时才运行，运行时机相同。<br>
2）不同点： ENTRYPOINT不会被运行的命令覆盖，而CMD则会被覆盖。<br>
例子：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
ENTRYPOINT echo hello world<br>
ENTRYPOINT echo hello china<br>
#与CMD一样，只有最后一条指令生效<br>
[root@sqm-docker01 dfs]# docker run --rm  en:v1<br>
hello china<br>
#不同的是不会被运行时的命令覆盖<br>
[root@sqm-docker01 dfs]# docker run ---rm  en:v1 echo &quot;test&quot;<br>
hello china<br>
#除非使用--entrypoint参数<br>
[root@sqm-docker01 dfs]# docker run --rm --entrypoint hostname  en:v1<br>
fa667d019ce5<br>
#这里使用hostname命令将hello china覆盖了<br>
11，ENTRYPOINT与CMD指令结合使用<br>
#如果我们在Dockerfile中同时写了ENTRYPOINT和CMD，那么CMD指定的内容就会作为ENTRYPOINT的参数。<br>
举例如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
ENTRYPOINT [&quot;/usr/bin/ping&quot;,&quot;baidu.com&quot;,&quot;-c&quot;]<br>
CMD [&quot;4&quot;]<br>
#运行一个容器：<br>
[root@sqm-docker01 dfs]# docker run --rm en:v2<br>
PING baidu.com (39.156.69.79): 56 data bytes<br>
64 bytes from 39.156.69.79: seq=0 ttl=127 time=72.931 ms<br>
64 bytes from 39.156.69.79: seq=1 ttl=127 time=62.366 ms<br>
64 bytes from 39.156.69.79: seq=2 ttl=127 time=58.875 ms<br>
64 bytes from 39.156.69.79: seq=3 ttl=127 time=50.662 ms</p>
<p>--- baidu.com ping statistics ---<br>
4 packets transmitted, 4 packets received, 0% packet loss<br>
round-trip min/avg/max = 50.662/61.208/72.931 ms<br>
此时容器中运行的命令为：ping baidu.com -c 4。</p>
<p>#ENTRYPOINT中的参数始终会被使用，而CMD的额外参数可以在容器启动时动态替换掉，例子如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
ENTRYPOINT [&quot;/usr/bin/ping&quot;,&quot;baidu.com&quot;,&quot;-c&quot;]<br>
CMD [&quot;4&quot;]<br>
[root@sqm-docker01 dfs]# docker run --rm en:v2 2<br>
PING baidu.com (39.156.69.79) 56(84) bytes of data.<br>
64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=127 time=80.4 ms<br>
64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=127 time=61.5 ms</p>
<p>--- baidu.com ping statistics ---<br>
2 packets transmitted, 2 received, 0% packet loss, time 3ms<br>
rtt min/avg/max/mdev = 61.532/70.945/80.358/9.413 ms<br>
此时容器运行的命为：ping baidu.com -c 2。</p>
<p>#这两种指令结合起来使用，有什么好处呢？我们通过以场景来理解：（例子和上边例子大同小异）</p>
<p>//假设我们需要一个得知自己当前公网IP的镜像，可以那么先用CMD来实现：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
RUN yum  -y install curl<br>
CMD [&quot;/usr/bin/curl&quot;,&quot;-s&quot;,&quot;https://ip.cn&quot;]<br>
#构建镜像并运行容器：<br>
[root@sqm-docker01 dfs]# docker build -t myip:v1 .<br>
[root@sqm-docker01 dfs]# docker run --rm myip:v1<br>
{&quot;ip&quot;: &quot;117.136.60.216&quot;, &quot;country&quot;: &quot;江西省&quot;, &quot;city&quot;: &quot;移动&quot;}<br>
看起来我们是可以把它当作命令使用了，不过命令总有参数，如果我们希望显示HTTP头信息，就需要加上-i参数。那么我们可以直接加-i参数给docker run myip么？</p>
<p>[root@sqm-docker01 dfs]# docker run --rm myip:v1 -i<br>
docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: &quot;-i&quot;: executable file not found in $PATH&quot;: unknown.<br>
我们可以看到替换文件找不到的报错，executable file not found，之前我们说过，跟在上面名字后面的是command，运行时会替换为CMD的值。因此这里的-i替换了原来的CMD，而不是添加在原来的curl -s https://ip.cn 后面。-i根本不是命令，所以自然找不到。</p>
<p>//为了有很好的解决这个问题，我们将CMD和ENTRYPOINT结合使用：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
RUN yum  -y install curl<br>
ENTRYPOINT [&quot;/usr/bin/curl&quot;,&quot;-s&quot;,&quot;https://ip.cn&quot;]<br>
CMD [&quot;-i&quot;]<br>
#构建并运行容器：<br>
[root@sqm-docker01 dfs]# docker build -t myip:v2 .<br>
[root@sqm-docker01 dfs]# docker run --rm myip:v2<br>
HTTP/2 200<br>
date: Wed, 19 Feb 2020 07:10:48 GMT<br>
content-type: application/json; charset=UTF-8<br>
set-cookie: __cfduid=d1903fe7e93a885c6ae4890572cda42161582096248; expires=Fri, 20-Mar-20 07:10:48 GMT; path=/; domain=.ip.cn; HttpOnly; SameSite=Lax<br>
cf-cache-status: DYNAMIC<br>
expect-ct: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot;<br>
alt-svc: h3-25=&quot;:443&quot;; ma=86400, h3-24=&quot;:443&quot;; ma=86400, h3-23=&quot;:443&quot;; ma=86400<br>
server: cloudflare<br>
cf-ray: 56766c505d6fb22e-HKG</p>
<p>{&quot;ip&quot;: &quot;117.136.60.216&quot;, &quot;country&quot;: &quot;江西省&quot;, &quot;city&quot;: &quot;移动&quot;}<br>
可以看到成功了，这是因为当存在ENTRYPOINT后，CMD的内容将会传递给ENTRYPOINT使用，从而达到了我们预期的效果。</p>
<p>##总结几条规律：</p>
<p>如果 ENTRYPOINT 使用了 shell 模式，CMD 指令会被忽略。<br>
如果 ENTRYPOINT 使用了 exec 模式，CMD 指定的内容被追加为 ENTRYPOINT 指定命令的参数。<br>
如果 ENTRYPOINT 使用了 exec 模式，CMD 也应该使用 exec 模式<br>
12，VOLUME--定义匿名卷<br>
格式为：</p>
<p>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]<br>
VOLUME &lt;路径&gt;</p>
<p>在Dockerfile中，我们可以预先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<p>VOLUME /data</p>
<p>这里的/data 目录就会在运行时自动挂载为匿名卷，任何向/data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。</p>
<p>docker run -d -v mydata:/data xxxx</p>
<p>在上边命令中，就使用了mydata 这个命名卷挂载到了/data 这个位置，替代了Dockerfile 中定义的匿名卷的挂载配置。</p>
<p>#注意：从该指令的支持的格式就可以知道，VOLUME只支持docker manager volume的挂载方式，而不支持bind mount的方式。</p>
<p>docker manager volume：不需要指定源文件，只需要指定mount point。把容器里面的目录映射到了本地（宿主机）。</p>
<p>举例如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
VOLUME /usr/share/nginx/html/<br>
#构建并运行容器：<br>
[root@sqm-docker01 dfs]# docker build -t volume:v1 .<br>
[root@sqm-docker01 dfs]# docker run -itd --name volume volume:v1<br>
5d963fb3b51ae9ddcc3b55382e289e0447235676f8893900a440f5f9500f035e<br>
我们通过docker inspect查看通过该dockerfile创建的大量生成的容器，可以看到挂载点的信息：</p>
<p>[root@sqm-docker01 dfs]# docker inspect volume<br>
&quot;Mounts&quot;: [<br>
{<br>
&quot;Type&quot;: &quot;volume&quot;,<br>
&quot;Name&quot;: &quot;190c5a22df09462a9f5fd54209b8bc5ad06fc9382f9c8b9c665c734e4bcf95e0&quot;,<br>
&quot;Source&quot;: &quot;/var/lib/docker/volumes/190c5a22df09462a9f5fd54209b8bc5ad06fc9382f9c8b9c665c734e4bcf95e0/_data&quot;,<br>
&quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,<br>
&quot;Driver&quot;: &quot;local&quot;,<br>
&quot;Mode&quot;: &quot;&quot;,<br>
&quot;RW&quot;: true,<br>
&quot;Propagation&quot;: &quot;&quot;<br>
}<br>
],<br>
从上面的信息可以看出默认挂载到本地的源路径为“/var/lib/docker/volumes/190c5a22df09462a9f5fd54209b8bc5ad06fc9382f9c8b9c665c734e4bcf95e0/_data” ，而目标路径（容器内的路径）为自定义的&quot;/usr/share/nginx/html&quot;。</p>
<p>13，WORKDIR--指定工作目录<br>
格式为：</p>
<p>WORKDIR &lt;工作目录路径&gt;</p>
<p>设置工作目录，对RUN，CMD，ENTRYPOINT,COPY,ADD生效。如果目录不存在，则会帮你创建，也可以设置多次,如：</p>
<p>WORKDIR /a<br>
WORKDIR b<br>
WORKDIR c<br>
RUN pwd<br>
#则最终的路径为/a/b/c。<br>
##WORKDIR也可以解析环境变量，如：</p>
<p>ENV DIRPATH /usr/src<br>
WORKDIR $DIRPATH<br>
RUN pwd<br>
#pwd的执行结果是/usr/src。<br>
注意：千万不要把dockerfile等同于shell脚本来书写，例如：</p>
<p>RUN cd /app<br>
RUN echo &quot;hello&quot; &gt; world.txt<br>
将这个dockerfile 进行构建镜像运行后，会发现找不到/app/world.txt 文件,或者其内容不是 hello。原因其实很简单，在dockerfile中这两行RUN命令的执行环境不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。<br>
如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>
<p>14，USER--指定当前用户</p>
<p>格式： USER &lt;用户名&gt;[:&lt;用户组&gt;]</p>
<p>USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。<br>
WORKDIR是改变工作目录，USER是改变之后层的执行RUN，CMD，以及ENTRYPOINT 这类命令的身份。<br>
当然，和WORKDIR一样，USER只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换：</p>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis<br>
USER redis<br>
RUN [ &quot;redis-server&quot; ]<br>
如果以root执行脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用su或者sudo，这些都需要比较麻烦的配置，而且在TTY缺失的环境下经常出错。一般使用 gosu。<br>
举例如下：</p>
<h1 id="建立-redis-用户并使用-gosu-换另一个用户执行命令">建立 redis 用户，并使用 gosu 换另一个用户执行命令</h1>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</p>
<h1 id="下载-gosu">下载 gosu</h1>
<p>RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; <br>
&amp;&amp; chmod +x /usr/local/bin/gosu <br>
&amp;&amp; gosu nobody true</p>
<h1 id="设置-cmd并以另外的用户redis执行">设置 CMD，并以另外的用户（redis）执行</h1>
<p>CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]<br>
15，ONBUILD--为镜像添加触发器</p>
<p>格式：ONBUILD &lt;其它指令&gt;</p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其他指令，比如RUN，COPY等，而这些指令，在当前镜像构建时并不会被执行。<br>
只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br>
Dockerfile中的其他指令都是为了定制当前镜像而准备的，唯有ONBUILD 是为了帮助别人定制自己而准备的。<br>
举例如下：<br>
//编写一个Dockerfile文件，内容如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ONBUILD COPY ./index.html /   #拷贝文件到容器内的 / 下<br>
//利用上面的dockerfile文件构建镜像：<br>
[root@sqm-docker01 dfs]# docker build -t image1 .</p>
<p>//利用image1镜像创建容器：</p>
<p>[root@sqm-docker01 dfs]# docker run --rm -it image1 /bin/bash<br>
root@db8a068d9f30:/# ls<br>
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var<br>
boot  etc  lib   media  opt  root  sbin  sys  usr<br>
我们发现以image1镜像运行的容器/目录下并没有index.html文件，这说明ONBUILD指定的指令并不会在自己的镜像构建中执行。</p>
<p>//再编写一个新的Dockerfile文件，内容如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM image1  #使用的基础镜像是上面构建的镜像image1<br>
CMD echo hello world<br>
//利用上面的dockerfile文件构建镜像：</p>
<p>[root@sqm-docker01 dfs]# docker build -t image2 .<br>
Sending build context to Docker daemon  102.6MB<br>
Step 1/2 : FROM image1</p>
<h1 id="executing-1-build-trigger">Executing 1 build trigger</h1>
<p>---&gt; 796e32308d29<br>
Step 2/2 : CMD echo hello world<br>
---&gt; Running in 5c16f913f5e9<br>
Removing intermediate container 5c16f913f5e9<br>
---&gt; 4c0a45374727<br>
Successfully built 4c0a45374727<br>
Successfully tagged image2:latest<br>
//利用image2镜像创建容器：</p>
<p>[root@sqm-docker01 dfs]# docker run -it --rm image2 /bin/bash<br>
root@3e3c1d0fe3f6:/# ls<br>
bin   dev  home        lib    media  opt   root  sbin  sys  usr<br>
boot  etc  index.html  lib64  mnt    proc  run   srv   tmp  var<br>
root@3e3c1d0fe3f6:/# cat index.html<br>
hello world<br>
我们发现以image2镜像运行的容器根目录下有index.html文件，说明触发器执行了 COPY ./index.html / 指令。</p>
<p>镜像缓存特性:<br>
1）Docker 会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无需重新创建，如下所示：<br>
//创建一个新的dockerfile</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
RUN yum -y install vim<br>
//构建一个镜像<br>
[root@sqm-docker01 dfs]# docker build -t a:v1 .<br>
#往刚刚创建的dockerfile中添加一点新内容（在镜像中添加一条COPY指令）：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
RUN yum -y install vim<br>
COPY testfile /<br>
#以同一个dockefile重新构建镜像：</p>
<p>[root@sqm-docker01 dfs]# touch testfile<br>
[root@sqm-docker01 dfs]# docker build -t a:v2 .<br>
Sending build context to Docker daemon  102.6MB<br>
Step 1/3 : FROM centos<br>
---&gt; 0f3e07c0138f<br>
Step 2/3 : RUN yum -y install vim<br>
---&gt; Using cache<br>
---&gt; 6467d4675159<br>
Step 3/3 : COPY testfile /<br>
---&gt; 6b92fe05882f<br>
Successfully built 6b92fe05882f<br>
Successfully tagged a:v2<br>
(1）确保testfile文件已存在<br>
(2）Using cache，重点在这里：之前已经运行过相同的RUN指令，这次直接使用缓存中的镜像层6467d4675159。<br>
(3）执行COPY指令。<br>
其过程是启动临时容器，复制testfile，提交新的镜像层6b92fe05882f，删除临时容器。</p>
<p>如果我们希望在构建镜像时不使用缓存，可以在docker build命令中加上--no-cache参数。</p>
<p>2）Dockerfile中每一个指令都会创建一个镜像层，上层是依赖于下层的。无论什么时候，只要某一层发生变化，其上面所有层的缓存都会失效。<br>
也就是说，如果我们改变 Dockerfile 指令的执行顺序，或者修改或添加指令，都会使缓存失效。<br>
举例说明，比如交换上面RUN和COPY指令的顺序：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
COPY testfile /<br>
RUN yum -y install vim<br>
虽然在逻辑上这种改动对镜像的内容没有影响，但由于分层的结构特性，Docker 必须重建受影响的镜像层。</p>
<p>//重新构建镜像:</p>
<p>[root@sqm-docker01 dfs]# docker build -t a:v3 .<br>
Sending build context to Docker daemon  102.6MB<br>
Step 1/3 : FROM centos<br>
---&gt; 0f3e07c0138f<br>
Step 2/3 : COPY testfile /<br>
---&gt; 97e725434a6b<br>
Step 3/3 : RUN yum -y install vim<br>
---&gt; Running in 5f30ff393047<br>
......<br>
Removing intermediate container 5f30ff393047<br>
---&gt; 90ceae8b3638<br>
Successfully built 90ceae8b3638<br>
Successfully tagged a:v3<br>
从上面的输出可以看到生成了新的镜像层97e725434a6b，缓存已经失效。</p>
<p>除了构建时使用缓存，Docker 在下载镜像时也会使用。例如我们下载 httpd 镜像：</p>
<p>[root@sqm-docker01 dfs]#docker pull httpd<br>
Using default tag: latest<br>
latest: Pulling from library/httpd<br>
f17d81b4b692: Already exists<br>
06fe09255c64: Already exists<br>
0baf8127507d: Already exists<br>
07b9730387a3: Already exists<br>
6dbdee9d6fa5: Already exists<br>
Digest: sha256:76954e59f23aa9845ed81146ef3cad4a78f5eb3daab9625874ebca0e416367e2<br>
Status: Image is up to date for httpd:latest<br>
docker pull 命令输出显示第一层（base 镜像）已经存在，不需要下载。</p>
<p>简单了解镜像分层概念<br>
Dockerfile中每行代码都会产生一个新的分层，一个镜像不能超过127层，每个层都会产生一个单独的id。<br>
在已经存在image中的层，都是只读的。当一个image被运行成为一个container的时候，这个层是可读可写的，需要操作镜像层中的文件时，都是通过容器层复制一份，然后在进行操作，这个机制是copy on write（写时复制）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[同时使用有线网上内网、无线网上外网]]></title>
        <id>https://newdy.cf/post/tong-shi-shi-yong-you-xian-wang-shang-nei-wang-wu-xian-wang-shang-wai-wang/</id>
        <link href="https://newdy.cf/post/tong-shi-shi-yong-you-xian-wang-shang-nei-wang-wu-xian-wang-shang-wai-wang/">
        </link>
        <updated>2020-02-20T05:43:15.000Z</updated>
        <content type="html"><![CDATA[<p>方法一、</p>
<p>利用有线访问局域网数据库等，用无线网络访问外网，这里提供一种方法可以实现，可编写bat文件，并在cmd中执行：</p>
<p>route delete 0.0.0.0</p>
<p>route add 0.0.0.0 mask 0.0.0.0 172.20.1.254</p>
<p>route add 172.20.36.0 mask 255.255.255.0 172.20.36.254</p>
<p>解释一下：</p>
<p>其中172.20.1.254为无线网网关，172.20.36.254为有线网网关。这两句话的意思是：对于所有IP地址的访问，都从172.20.1.254走；但是，对于172.20.36开头的地址的访问，从172.20.36.254走。</p>
<p>针对上述情况，实际应用中，遇到windows 7与windows xp两者不一样，windows 7中，除了上述命令外，在TCP/IP配置中，无线外网设置为自动获取，内网配置为内网IP，子网掩码，网关。</p>
<p>widows xp中，除了上述命令外，在TCP/IP配置中，无线设置为手动输入IP，子网掩码，且网关留空，不填，内网配置为内网IP，子网掩码，网关。</p>
<p>方法二、</p>
<p>例1</p>
<p>我的笔记本用无线 网卡联互联网，同时局域网使用的是有线 连接（网段 132.147.X.X，不提供接入Internet服务），同时提供无线 网络连接供客户使用（网段192.168.1.X，可连接互联网）。</p>
<p>如果同时连接有线 网卡和 无线 网卡，因为有线 网卡的优先级较高，故仅有线 局域网能正常工作，无线 网卡可连接但却无法传送数据。要改变这种情况，需要对笔记本本地路由设置做出修改：访问132.147.X.X的请求均有有线 网卡处理，访问其它网络的则由无线 网卡处理。</p>
<p>具体设置步骤如下：</p>
<p>1. 设置无线 网卡为默认路由网关：无线 网络连接属性—Internet协议（TCP/IP）-属性-高级，手动输入无线 路由网关，我这里的是132.147.X.X，跃点数为“1”， 是最高优先级。到了这一步，如果有线 连接，无线 连接同时存在的话，所有的数据都是经由无线 网卡处理的。</p>
<p>2. 设置排除信息，把132.147.X.X路段的网址连接请求交由优先网卡处理：在命令行输入以下命令</p>
<p>route -p add 132.147.0.0 mask 255.255.0.0 132.147.160.1</p>
<p>其中132.147.0.0是本地局域网网段，132.147.160.1是本机所处子网段的默认网关，需要根据具体情况填写。经过以上设置，在访问本地网段的时候均由有线 网卡处理，访问互联网的时候可交由无线 网卡处理，就不会产生冲突了。</p>
<p>注意: 这里的172.16.x.x 和192.168.1.X 和你的局域网环境有关,可以命令行下ipconfig /all 查看</p>
<p>例2</p>
<p>局域网有线连接（网段172.16.X.X，不提供接入internet服务），WIFI连接（网段192.168.1.X，可连接互联网)。</p>
<p>如 果同时连接有线网卡和无线网卡，因为有线网卡的优先级较高，故仅有线局域网能正常工作，无线网卡可连接但却无法传送数据。要改变这种情况，需要对笔记本本 地路由设置做出修改：访问172.16.X.X的请求均有有线网卡处理，访问其它网络的则由无线网卡处理。设置步骤如下：</p>
<p>1》 设置无线网卡为默认路由网关：无线网络连接属性—Internet协议(TCP/IP)-属性-高级，手动输入无线路由网关，我这里的是 192.168.1.1，跃点数为“1”，是最高优先级。到了这一步，如果有线连接，无线连接同时存在的话，所有的数据都是经由无线网卡处理的。</p>
<p>2》设置排除信息，把172.16.X.X路段的网址连接请求交由优先网卡处理：在命令行输入以下命令<br>
route -p add 172.16.0.0 mask 255.255.0.0 172.16.6.1<br>
其中172.16.0.0是本地局域网网段，172.16.6.1是本机所处子网段的默认网关，需要根据具体情况填写。</p>
<p>经过以上设置，在访问本地网段的时候均由有线网卡处理，访问互联网的时候可交由无线网卡处理，就不会产生冲突了。</p>
<p>其它信息(来自网络)</p>
<p>不少公司的网管试图解决双网卡问题，下面我就给大家详细的讲解一下双网卡同时使用的方法，这样即可保障内网的安全，又能解决电脑访问外网的问题，一举两得。希望大家喜欢。</p>
<p>首先你的机器需要有两块网卡，分别接到两台交换机上,</p>
<p>internet地址：192.168.1.8，子网掩码：255.255.255.0，网关：192.168.1.1</p>
<p>内部网地址：172.23.1.8，子网掩码：255.255.255.0，网关：172.23.1.1</p>
<p>如果按正常的设置方法设置每块网卡的ip地址和网关，再cmd下使用route print查看时会看到</p>
<p>Network Destination Netmask Gateway Interface Metric</p>
<p>0.0.0.0 0.0.0.0 192.168.1.1 192.168.1.8</p>
<p>0.0.0.0 0.0.0.0 172.23.1.1 172.23.1.8</p>
<p>即指向0.0.0.0的有两个网关，这样就会出现路由冲突，两个网络都不能访问。</p>
<p>如何实现同时访问两个网络？那要用到route命令</p>
<p>第一步：route delete 0.0.0.0     &quot;删除所有0.0.0.0的路由&quot;</p>
<p>第二步：route add 0.0.0.0 mask 0.0.0.0 192.168.1.1     &quot;添加0.0.0.0网络路由&quot;这个是主要的,意思就是你可以上外网.</p>
<p>第三步：route add 172.23.0.0 mask 255.0.0.0 172.23.1.1    &quot;添加172.23.0.0网络路由&quot;，注意mask为255.0.0.0   ，而不是255.255.255.0 ，这样内部的多网段才可用。</p>
<p>这时就可以同时访问两个网络了，但碰到一个问题，使用上述命令添加的路由在系统重新启动后会自动丢失，怎样保存现有的路由表呢？</p>
<p>route add -p 添加静态路由，即重启后，路由不会丢失。注意使用前要在tcp/ip设置里去掉接在企业内部网的网卡的网关</p>
<hr>
<p>一些单位将内网和外网分开了。痛苦啊，偶单位就是如此。boss当然是基于安全性考虑了，可是没有笔记本的怎么办？又要办公，有得上网。没办法，发扬DIY精神偷偷装一块网卡，让聊天与工作同在。让你的主机内外兼顾。这是我在网上找到的，谢谢作者了。方法如下：<br>
1.设置其中接internet的网卡的网关为10.0.0.1，启用后就是默认网关<br>
--注：这是对应外网的网卡，按照你们单位外网的ip分配情况，在TCP/IP属性中配置好 ip、掩码、DNS</p>
<p>2.将连接单位内部网的网卡IP配好后，设网关设置为空（即不设网关），启用后，此时内网无法通过网关路由</p>
<p>3.进入CMD，运行：route -p add 192.0.0.0 mask 255.0.0.0 192.168.0.1 metric 1</p>
<p>--注：意思是将192*的IP包的路由网关设为192.168.0.1 ，-P 参数代表永久写入路由表，建议先不加此参数，实践通过后在写上去</p>
<ol start="4">
<li>OK！同时启用两个网卡，两个网关可以同时起作用了，两个子网也可以同时访问了，关机重启后也不用重设！</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NFS服务器搭建与配置]]></title>
        <id>https://newdy.cf/post/nfs-fu-wu-qi-da-jian-yu-pei-zhi/</id>
        <link href="https://newdy.cf/post/nfs-fu-wu-qi-da-jian-yu-pei-zhi/">
        </link>
        <updated>2020-02-20T05:31:42.000Z</updated>
        <content type="html"><![CDATA[<p>NFS服务简介<br>
什么是NFS？<br>
NFS就是Network File System的缩写，它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。</p>
<p>​	NFS服务器可以让PC将网络中的NFS服务器共享的目录挂载到本地端的文件系统中，而在本地端的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样，在使用上相当便利；</p>
<p>NFS一般用来存储共享视频，图片等静态数据。</p>
<p>NFS挂载原理：<br>
<img src="https://newdy.cf/post-images/1582176745939.jpg" alt="" loading="lazy"><br>
图；服务器挂载结构<br>
如上图示：</p>
<p>当我们在NFS服务器设置好一个共享目录/home/public后，其他的有权访问NFS服务器的NFS客户端就可以将这个目录挂载到自己文件系统的某个挂载点，这个挂载点可以自己定义，如上图客户端A与客户端B挂载的目录就不相同。并且挂载好后我们在本地能够看到服务端/home/public的所有数据。如果服务器端配置的客户端只读，那么客户端就只能够只读。如果配置读写，客户端就能够进行读写。挂载后，NFS客户端查看磁盘信息命令：#df –h。</p>
<p>既然NFS是通过网络来进行服务器端和客户端之间的数据传输，那么两者之间要传输数据就要有想对应的网络端口，NFS服务器到底使用哪个端口来进行数据传输呢？基本上NFS这个服务器的端口开在2049,但由于文件系统非常复杂。因此NFS还有其他的程序去启动额外的端口，这些额外的用来传输数据的端口是随机选择的，是小于1024的端口；既然是随机的那么客户端又是如何知道NFS服务器端到底使用的是哪个端口呢？这时就需要通过远程过程调用（Remote Procedure Call,RPC）协议来实现了！</p>
<p>RPC与NFS通讯原理：<br>
​	因为NFS支持的功能相当多，而不同的功能都会使用不同的程序来启动，每启动一个功能就会启用一些端口来传输数据，因此NFS的功能对应的端口并不固定，客户端要知道NFS服务器端的相关端口才能建立连接进行数据传输，而RPC就是用来统一管理NFS端口的服务，并且统一对外的端口是111，RPC会记录NFS端口的信息，如此我们就能够通过RPC实现服务端和客户端沟通端口信息。PRC最主要的功能就是指定每个NFS功能所对应的port number,并且通知客户端，记客户端可以连接到正常端口上去。</p>
<p>那么RPC又是如何知道每个NFS功能的端口呢？</p>
<p>首先当NFS启动后，就会随机的使用一些端口，然后NFS就会向RPC去注册这些端口，RPC就会记录下这些端口，并且RPC会开启111端口，等待客户端RPC的请求，如果客户端有请求，那么服务器端的RPC就会将之前记录的NFS端口信息告知客户端。如此客户端就会获取NFS服务器端的端口信息，就会以实际端口进行数据的传输了。</p>
<p>注意：在启动NFS SERVER之前，首先要启动RPC服务（即portmap服务，下同）否则NFS SERVER就无法向RPC服务区注册，另外，如果RPC服务重新启动，原来已经注册好的NFS端口数据就会全部丢失。因此此时RPC服务管理的NFS程序也要重新启动以重新向RPC注册。特别注意：一般修改NFS配置文档后，是不需要重启NFS的，直接在命令执行systemctl reload nfs或exportfs –rv即可使修改的/etc/exports生效</p>
<p>NFS客户端和NFS服务器通讯过程：<br>
<img src="https://newdy.cf/post-images/1582176817313.jpg" alt="" loading="lazy"><br>
首先服务器端启动RPC服务，并开启111端口</p>
<p>服务器端启动NFS服务，并向RPC注册端口信息</p>
<p>客户端启动RPC（portmap服务），向服务端的RPC(portmap)服务请求服务端的NFS端口</p>
<p>服务端的RPC(portmap)服务反馈NFS端口信息给客户端。</p>
<p>客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输。</p>
<p>Linux下NFS服务器部署<br>
NFS服务所需软件及主要配置文件：<br>
安装NFS服务，需要安装两个软件，分别是：</p>
<p>RPC主程序：rpcbind</p>
<p>NFS 其实可以被视为一个 RPC 服务，因为启动任何一个 RPC 服务之前，我们都需要做好 port 的对应 (mapping) 的工作才行，这个工作其实就是『 rpcbind 』这个服务所负责的！也就是说， 在启动任何一个 RPC 服务之前，我们都需要启动 rpcbind 才行！ (在 CentOS 5.x 以前这个软件称为 portmap，在 CentOS 6.x 之后才称为 rpcbind 的！)。</p>
<p>NFS主程序：nfs-utils</p>
<p>就是提供 rpc.nfsd 及 rpc.mountd 这两个 NFS daemons 与其他相关 documents 与说明文件、执行文件等的软件！这个就是 NFS 服务所需要的主要软件。</p>
<p>NFS的相关文件：</p>
<p>主要配置文件：/etc/exports<br>
这是 NFS 的主要配置文件了。该文件是空白的，有的系统可能不存在这个文件，主要手动建立。NFS的配置一般只在这个文件中配置即可。<br>
NFS 文件系统维护指令：/usr/sbin/exportfs<br>
这个是维护 NFS 分享资源的指令，可以利用这个指令重新分享 /etc/exports 变更的目录资源、将 NFS Server 分享的目录卸除或重新分享。<br>
分享资源的登录档：/var/lib/nfs/*tab<br>
在 NFS 服务器的登录文件都放置到 /var/lib/nfs/ 目录里面，在该目录下有两个比较重要的登录档， 一个是 etab ，主要记录了 NFS 所分享出来的目录的完整权限设定值；另一个 xtab 则记录曾经链接到此 NFS 服务器的相关客户端数据。<br>
客户端查询服务器分享资源的指令：/usr/sbin/showmount<br>
这是另一个重要的 NFS 指令。exportfs 是用在 NFS Server 端，而 showmount 则主要用在 Client 端。showmount 可以用来察看 NFS 分享出来的目录资源。<br>
服务端安装NFS服务步骤：<br>
第一步：安装NFS和rpc。<br>
[root@localhost ~]# yum install -y  nfs-utils<br>
#安装nfs服务<br>
[root@localhost ~]# yum install -y rpcbind<br>
#安装rpc服务</p>
<p>第二步：启动服务和设置开启启动：</p>
<p>注意：先启动rpc服务，再启动nfs服务。<br>
[root@localhost ~]# systemctl start rpcbind    #先启动rpc服务<br>
[root@localhost ~]# systemctl enable rpcbind   #设置开机启动<br>
[root@localhost ~]# systemctl start nfs-server nfs-secure-server<br>
#启动nfs服务和nfs安全传输服务<br>
[root@localhost ~]# systemctl enable nfs-server nfs-secure-server<br>
[root@localhost /]# firewall-cmd --permanent --add-service=nfs<br>
success   #配置防火墙放行nfs服务<br>
[root@localhost /]# firewall-cmd  --reload<br>
success</p>
<p>第三步：配置共享文件目录，编辑配置文件：</p>
<p>首先创建共享目录，然后在/etc/exports配置文件中编辑配置即可。</p>
<p>[root@localhost /]# mkdir /public<br>
#创建public共享目录<br>
[root@localhost /]# vi /etc/exports<br>
/public 192.168.245.0/24(ro)<br>
/protected 192.168.245.0/24（rw）<br>
[root@localhost /]# systemctl reload nfs<br>
#重新加载NFS服务，使配置文件生效<br>
配置文件说明：</p>
<p>格式： 共享目录的路径 允许访问的NFS客户端（共享权限参数）</p>
<p>如上，共享目录为/public , 允许访问的客户端为192.168.245.0/24网络用户，权限为只读。</p>
<p>请注意，NFS客户端地址与权限之间没有空格。</p>
<p>NFS输出保护需要用到kerberos加密（none，sys，krb5，krb5i，krb5p），格式sec=XXX</p>
<p>none：以匿名身份访问，如果要允许写操作，要映射到nfsnobody用户，同时布尔值开关要打开，setsebool nfsd_anon_write 1</p>
<p>sys：文件的访问是基于标准的文件访问，如果没有指定，默认就是sys， 信任任何发送过来用户名</p>
<p>krb5：客户端必须提供标识，客户端的表示也必须是krb5，基于域环境的认证</p>
<p>krb5i：在krb5的基础上做了加密的操作，对用户的密码做了加密，但是传输的数据没有加密</p>
<p>krb5p：所有的数据都加密</p>
<p>用于配置NFS服务程序配置文件的参数：</p>
<p>参数	作用<br>
ro                      	  只读<br>
rw	                         读写<br>
root_squash	           当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户<br>
no_root_squash      当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员<br>
all_squash             	 无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户<br>
sync	                    同时将数据写入到内存与硬盘中，保证不丢失数据<br>
async	                   优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据</p>
<p>NFS客户端挂载配置：<br>
**第一步：**使用showmount命令查看nfs服务器共享信息。输出格式为“共享的目录名称 允许使用客户端地址”。</p>
<p>[root@localhost ~]# showmount -e 192.168.245.128<br>
Export list for 192.168.245.128:<br>
/protected 192.168.245.0/24<br>
/public    192.168.245.0/24</p>
<p>showmount命令的用法；<br>
参数	作用<br>
-e	     显示NFS服务器的共享列表<br>
-a	     显示本机挂载的文件资源的情况NFS资源的情况<br>
-v	     显示版本号</p>
<p>**第二步，**在客户端创建目录，并挂载共享目录。</p>
<p>[root@localhost ~]# mkdir /mnt/public<br>
[root@localhost ~]# mkdir /mnt/data<br>
[root@localhost ~]# vim /etc/fstab<br>
#在该文件中挂载，使系统每次启动时都能自动挂载<br>
192.168.245.128:/public  /mnt/public       nfs    defaults 0 0<br>
192.168.245.128:/protected /mnt/data     nfs    defaults  0 1<br>
[root@localhost ~]# mount -a   #是文件/etc/fstab生效</p>
<p>第三步：检查：</p>
<p>[root@mail ~]# df -Th<br>
Filesystem                 Type      Size  Used Avail Use% Mounted on<br>
/dev/mapper/rhel-root      xfs        17G  3.1G   14G  18% /<br>
devtmpfs                   devtmpfs  1.4G     0  1.4G   0% /dev<br>
tmpfs                      tmpfs     1.4G  140K  1.4G   1% /dev/shm<br>
tmpfs                      tmpfs     1.4G  9.1M  1.4G   1% /run<br>
tmpfs                      tmpfs     1.4G     0  1.4G   0% /sys/fs/cgroup<br>
/dev/sda1                  xfs      1014M  173M  842M  18% /boot<br>
tmpfs                      tmpfs     280M   32K  280M   1% /run/user/0<br>
/dev/sr0                   iso9660   3.6G  3.6G     0 100% /mnt/cdrom<br>
192.168.245.128:/public    nfs4       17G  3.7G   14G  22% /mnt/public<br>
192.168.245.128:/protected nfs4       17G  3.7G   14G  22% /mnt/data</p>
<p>在Window上挂载NFS<br>
第一步：在控制面板–&gt;添加程序和功能–&gt;添加NFS组件。<br>
<img src="https://newdy.cf/post-images/1582177129076.png" alt="" loading="lazy"><br>
第二步：在此电脑，映射驱动器中添加nfs地址，和要共享的文件夹。<br>
<img src="https://newdy.cf/post-images/1582177154552.png" alt="" loading="lazy"><br>
第三步：如果权限有问题，打开注册表：regedit, 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ClientForNFS\CurrentVersion\Default 下新建两个OWORD（64）位值，添加值AnonymousGid，值默认为0，AnonymousUid，值默认为0。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows挂载nfs]]></title>
        <id>https://newdy.cf/post/windows-gua-zai-nfs/</id>
        <link href="https://newdy.cf/post/windows-gua-zai-nfs/">
        </link>
        <updated>2020-02-20T05:24:03.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://newdy.cf/post-images/1582176250349.png" alt="" loading="lazy"><br>
注意：Win10 Creators Update前只有Win10企业版可以挂载NFS， Creators Update后专业版也可挂载NFS了。</p>
<p>安装<br>
按Win+R输入OptionalFeatures，勾选”NFS服务”</p>
<p>不需要勾选“管理工具”，那玩意是个废物，非WinServer只能靠命令行挂载NFS。</p>
<p>装好后按Win+R输入cmd</p>
<p>查看远程电脑NFS共享的目录<br>
showmount -e 远程电脑的IP<br>
完整的用法：<br>
用法: showmount -e [server] 显示 NFS 服务器导出的所有共享。<br>
showmount -a [server] 列出客户端主机名或 IP 地址，以及使用“主机:目录”格式显示的安装目录。<br>
showmount -d [server] 显示 NFS 服务器上当前由某些 NFS 客户端安装的目录。<br>
挂载<br>
mount \远程电脑的IP\共享的目录 盘符<br>
<strong>例如：</strong><br>
mount \192.168.1.2\root V:<br>
关于如何配置远程电脑上的NFS请自行Google 完整的用法：<br>
用法: mount [-o options] [-u:username] [-p:&lt;password | *&gt;] &lt;\computername\sharename&gt; &lt;devicename | *&gt;</p>
<p>-o rsize=size 设置读取缓冲区的大小(以 KB 为单位)。<br>
-o wsize=size 设置写入缓冲区的大小(以 KB 为单位)。<br>
-o timeout=time 设置 RPC 调用的超时值(以秒为单位)。<br>
-o retry=number 设置软装载的重试次数。<br>
-o mtype=soft|hard 设置装载类型。<br>
-o lang=euc-jp|euc-tw|euc-kr|shift-jis|big5|ksc5601|gb2312-80|ansi<br>
指定用于文件和目录名称的编码。<br>
-o fileaccess=mode 指定文件的权限模式。<br>
这些模式用于在 NFS 服务器上创建的<br>
新文件。使用 UNIX 样式模式位指定。<br>
-o anon 作为匿名用户装载。<br>
-o nolock 禁用锁定。<br>
-o casesensitive=yes|no 指定在服务器上执行区分大小写的文件查找。<br>
-o sec=sys|krb5|krb5i|krb5p<br>
卸载</p>
<p>umount 盘符</p>
<p>例如：umount V:\</p>
<p>如果要卸载全部的NFS挂载：</p>
<p>umount -f -a</p>
<p>不要使用资源管理器的“断开网络驱动器”！！！</p>
]]></content>
    </entry>
</feed>