<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newdy.cf</id>
    <title>Gridea</title>
    <updated>2020-02-21T18:31:28.624Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newdy.cf"/>
    <link rel="self" href="https://newdy.cf/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://newdy.cf/images/avatar.png</logo>
    <icon>https://newdy.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[unraid6.7.2安装]]></title>
        <id>https://newdy.cf/post/unraid672-an-zhuang/</id>
        <link href="https://newdy.cf/post/unraid672-an-zhuang/">
        </link>
        <updated>2020-02-21T18:24:15.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://newdy.cf/post-images/1582309503734.png" alt="" loading="lazy"><br>
注意 4 help 打开复制翻译 ,它就是一教程<br>
<img src="https://newdy.cf/post-images/1582309522668.png" alt="" loading="lazy"><br>
大佬说话简而言之，这里啰嗦一下<br>
格式化U盘 格式FAT32 卷标 UNRAID 大写<br>
用第一张图的第6个工具把unraid安装到U盘中<br>
<img src="https://newdy.cf/post-images/1582309546445.png" alt="" loading="lazy"><br>
将crack目录中的文件复制到U盘根目录，拔U盘，插到服务器，启动<br>
找到服务器IP，浏览器直接IP进入，按图打开，找到 Flash GUID 后面的ID<br>
<img src="https://newdy.cf/post-images/1582309577402.png" alt="" loading="lazy"><br>
用第一张图中的第5个行成key,如第一张图中的3就是。<br>
服务器关机，拔U盘插到操作电脑，把刚生成的BTRS.key复制到U盘的config文件中。完事<br>
有大佬做了视频 53，对我这小白太有用处了，https://space.bilibili.com/28457?share_medium=android&amp;share_source=more&amp;bbid=ehksHyZDIRMmHn8dYR1hVmdVJF46SXpJek14infoc&amp;ts=1573127133669</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Watchtower - 自动更新 Docker 镜像与容器]]></title>
        <id>https://newdy.cf/post/watchtower-zi-dong-geng-xin-docker-jing-xiang-yu-rong-qi/</id>
        <link href="https://newdy.cf/post/watchtower-zi-dong-geng-xin-docker-jing-xiang-yu-rong-qi/">
        </link>
        <updated>2020-02-20T13:17:14.000Z</updated>
        <summary type="html"><![CDATA[<p>前言<br>
在早前部署Awesome TTRSS时,作者在docker-compose里配置了Watchtower,于是找到 Github 官方项目研究了下,根据官方文档简单整理了一下常用参数以备用.</p>
<p>Watchtower 是一款实现自动化更新 Docker 镜像与容器的实用工具.它监控着所有正在运行的容器以及相关镜像,当检测本地镜像与镜像仓库中的镜像有差异时,会自动拉取最新镜像并使用最初部署时的参数重新启动相应的容器.</p>
]]></summary>
        <content type="html"><![CDATA[<p>前言<br>
在早前部署Awesome TTRSS时,作者在docker-compose里配置了Watchtower,于是找到 Github 官方项目研究了下,根据官方文档简单整理了一下常用参数以备用.</p>
<p>Watchtower 是一款实现自动化更新 Docker 镜像与容器的实用工具.它监控着所有正在运行的容器以及相关镜像,当检测本地镜像与镜像仓库中的镜像有差异时,会自动拉取最新镜像并使用最初部署时的参数重新启动相应的容器.</p>
<!-- more -->
<p>containrrr/watchtower</p>
<!-- more -->
<p>部署<br>
快速启动<br>
以容器的方式启动 Watch­tower</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower<br>
清理旧镜像<br>
镜像在更新后旧镜像标签会变为none,长期自动更新会导致过多的none镜像占用空间,加入--cleanup参数可以在每次更新后自动删除none镜像.</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup<br>
指定容器更新<br>
如无需自动更新所有稳定运行的容器,可以配置仅更新指定容器,只需要在命令后加上容器名.例如只更新nginx和redis.</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup <br>
nginx redis<br>
注意指定容器需填写 容器名 ,并非镜像名.由于启动容器时可能没有定义 --name 参数,请执行 docker ps 查询核对容器名.<br>
指定容器排除更新<br>
如需要更新大部分容器,而排除掉少数容器不更新,可以加上 --label=com.centurylinklabs.watchtower.enable=false 的参数.命令结尾加上不更新的容器名.例如希望自动更新所有容器,而不更新nginx和redis.</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
--label=com.centurylinklabs.watchtower.enable=false <br>
containrrr/watchtower <br>
--cleanup <br>
nginx redis<br>
注意指定容器需填写 容器名 ,并非镜像名.由于启动容器时可能没有定义 --name 参数,请执行 docker ps 查询核对容器名.<br>
配置自动更新频率<br>
Watch­tower 默认每 5 分钟轮询一次,可以使用以下参数配置更新的频率.</p>
<p>--interval,-i 配置更新周期,默认300秒.<br>
--schedule,-s 配置定时更新,使用Cron表达式,例如&quot;0 0 4 * * *&quot;.即每天凌晨4点更新.<br>
每小时更新一次</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup <br>
-i 3600<br>
每天凌晨4点更新</p>
<p>docker run -d <br>
--name watchtower <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
containrrr/watchtower <br>
--cleanup <br>
-s &quot;0 0 4 * * *&quot;<br>
手动更新<br>
使用手动更新的方式,运行一次Watch­tower容器来更新所需的容器,更新后会自动删除本次运行的Watch­tower容器.只需要加上--rm和--run-once参数即可.同时也可以配合以上指定容器或指定排除容器的参数来使用.</p>
<p>docker run --rm <br>
-v /var/run/docker.sock:/var/run/docker.sock <br>
--label=com.centurylinklabs.watchtower.enable=false <br>
containrrr/watchtower <br>
--cleanup <br>
--run-once <br>
nginx redis<br>
注意指定容器需填写 容器名 ,并非镜像名.由于启动容器时可能没有定义 --name 参数,请执行 docker ps 查询核对容器名.<br>
手动运行更新时会出现以下消息,表示正在更新,请耐心等待几分钟.</p>
<p>time=&quot;2020-02-18T03:58:24Z&quot; level=info msg=&quot;Running a one time update.&quot;<br>
随后提示找到更新镜像,停止容器,更新镜像,重启容器并移除旧镜像.至此更新完毕.</p>
<p>time=&quot;2020-02-18T04:02:45Z&quot; level=info msg=&quot;Found new xxxx/xxxx:latest image (sha256:10383f5b5720d7e1fxxxx137034c69b7f6xxxxxxafcc4e9d508b561af77)&quot;<br>
time=&quot;2020-02-18T04:02:45Z&quot; level=info msg=&quot;Stopping /xxxx (2e9ce1ebe319f3a35d80bxxxxxxxxxx6763ada155da957acb24fe76fc8a8c5) with SIGTERM&quot;<br>
time=&quot;2020-02-18T04:02:46Z&quot; level=info msg=&quot;Creating /xxxx&quot;<br>
time=&quot;2020-02-18T04:02:46Z&quot; level=info msg=&quot;Removing image sha256:ff4ee4caaa237174080c0d545xxxxxx</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7.3防火墙配置]]></title>
        <id>https://newdy.cf/post/centos73-fang-huo-qiang-pei-zhi/</id>
        <link href="https://newdy.cf/post/centos73-fang-huo-qiang-pei-zhi/">
        </link>
        <updated>2020-02-20T10:55:40.000Z</updated>
        <content type="html"><![CDATA[<p>1、查看firewall服务状态<br>
systemctl status firewalld<br>
<img src="https://newdy.cf/post-images/1582196168648.png" alt="" loading="lazy"></p>
<p>2、查看firewall的状态<br>
firewall-cmd --state<br>
<img src="https://newdy.cf/post-images/1582196217057.png" alt="" loading="lazy"></p>
<p>3、开启、重启、关闭、firewalld.service服务</p>
<h1 id="开启">开启</h1>
<p>service firewalld start</p>
<h1 id="重启">重启</h1>
<p>service firewalld restart</p>
<h1 id="关闭">关闭</h1>
<p>service firewalld stop</p>
<p>4、查看防火墙规则<br>
firewall-cmd --list-all<br>
<img src="https://newdy.cf/post-images/1582196328235.png" alt="" loading="lazy"></p>
<p>5、查询、开放、关闭端口</p>
<p>复制代码</p>
<h1 id="查询端口是否开放">查询端口是否开放</h1>
<p>firewall-cmd --query-port=8080/tcp</p>
<h1 id="开放80端口">开放80端口</h1>
<p>firewall-cmd --permanent --add-port=80/tcp</p>
<h1 id="移除端口">移除端口</h1>
<p>firewall-cmd --permanent --remove-port=8080/tcp</p>
<p>#重启防火墙(修改配置后要重启防火墙)<br>
firewall-cmd --reload</p>
<h1 id="参数解释">参数解释</h1>
<p>1、firwall-cmd：是Linux提供的操作firewall的一个工具；<br>
2、--permanent：表示设置为持久；<br>
3、--add-port：标识添加的端口；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装CentOS7.6 Minimal ISO系统并增加图形化桌面]]></title>
        <id>https://newdy.cf/post/an-zhuang-centos76-minimal-iso-xi-tong-bing-zeng-jia-tu-xing-hua-zhuo-mian/</id>
        <link href="https://newdy.cf/post/an-zhuang-centos76-minimal-iso-xi-tong-bing-zeng-jia-tu-xing-hua-zhuo-mian/">
        </link>
        <updated>2020-02-20T08:04:20.000Z</updated>
        <content type="html"><![CDATA[<p>1.配置网络（因为安装过程需要网络yum源。当然你这里如果有完整系统镜像做本地yum源或者其它本地yum源可以满足安装需求的话没有网络也是可以的。）</p>
<p>2.查看yum源是否可用：</p>
<p>yum repolist</p>
<p>3.执行命令：</p>
<p>yum grouplist  # 先检查一下系统支持哪些桌面安装类型，见下图<br>
<img src="https://newdy.cf/post-images/1582185918274.png" alt="" loading="lazy"><br>
yum groupinstall -y &quot;X Window System&quot;  # X Window System是执行在UNIX系统上的视窗系统，出现complete表示成功。据其它同行说此步骤不执行亦可。</p>
<p>yum groupinstall -y &quot;GNOME Desktop&quot;  # 表示安装GNOME Desktop类型的桌面，出现complete表示成功；查阅其它经验贴发现也可以选择KDE Desktop，安装方法请参考其它资料。<br>
报错：</p>
<p>Transaction check error:</p>
<p>file /boot/efi/EFI/redhat from install of fwupdate-efi-12-5.el7.x86_64 conflicts with file from package grub2-common-1:2.02-0.65.el7_4.2.noarch</p>
<p>file /boot/efi/EFI/redhat from install of fwupdate-efi-12-5.el7.x86_64 conflicts with file from package grub2-efi-1:2.02-0.65.el7_4.2.x86_64</p>
<p>解决：表示包的版本有冲突，貌似是系统bug；</p>
<p>执行</p>
<p>yum update grub2-common</p>
<p>yum install grub2-efi</p>
<p>yum install fwupdate</p>
<p>再重新执行yum groupinstall -y &quot;GNOME Desktop&quot;即可，参考链接：https://www.createdpro.com/a/100006。</p>
<p>startx  # 表示进入桌面</p>
<p>报错：</p>
<p>xauth: file /root/.serverauth.2669 does not exist  # 这只是报错的其中一条，还有几条同类型报错，因当时不便截图故不能一 一列出。</p>
<p>解决：在有网的情况下执行yum upgrade 该命令表示安装新内核，重启后即可正常进入桌面。参考链接：https://www.cnblogs.com/rgqancy/p/5554814.html。</p>
<p>4.进入桌面后按提示输入一步步执行完成即可。注意事项：走到如下图这一步时只能以英文字母开头不能以数字开头，你输入全名时下一行的用户名会跟着自动输入，当用户名不跟着全名自动输入时说明系统不支持该类名称，但系统并不报错，只是等你到最后会发现一切就绪后桌面无图标并且鼠标右键无效无法操作；到输入密码这一步时，要求密码不能和名称有相同的字母或数字，否则无法进入下一步。<br>
<img src="https://newdy.cf/post-images/1582185962009.png" alt="" loading="lazy"><br>
至此桌面安装完毕，以下为知识点扩展及经验总结：</p>
<p>1.整个过程报错几次，当时没细看报错，导致操作了几遍才解决，差点有重新装系统的冲动了。首先遇到报错不要着急要看一下报错信息再解决，不能盲目解决导致效率低，遇到问题要自信沉稳。</p>
<p>2.yum groupinstall 这个命令的新命令据说可以这样写yum groups install，本人未亲自验证。</p>
<p>3.卸载命令yum groupremove</p>
<p>4.设置开机启动模式为图形模式（是否需要操作这一步有待核实，因为我当时操作了，但与别人交流时他们并未操作该步骤）</p>
<p>systemctl set-default graphical.target或者ln -sf /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target</p>
<p>设置开机启动模式为文本模式（这一步在装桌面肯定是不用执行的啦，我在这里写出来只是为了知识点的扩展而已）：ln -sf/lib/systemd/system/multi-user.target /etc/systemd/system/default.target</p>
<p>5.期间如果reboot后无法正常进入桌面，亦无法进入命令行模式时可以采用Xshell等远程工具连接进入命令行。（有人说可以在终端前用Ctrl+Alt+F*（*表示1-7）之间选择即可以进入控制台来操作，本人未亲自验证）</p>
<p>6.这种情况建议最好安装everything ISO带桌面的系统，一步到位。选择系统时不要选最新的，求稳不求新，同事下载的就是目前最新的7.6版本，新版本难免有bug</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dockerfile常用指令详解&镜像缓存特性]]></title>
        <id>https://newdy.cf/post/dockerfile-chang-yong-zhi-ling-xiang-jie-andjing-xiang-huan-cun-te-xing/</id>
        <link href="https://newdy.cf/post/dockerfile-chang-yong-zhi-ling-xiang-jie-andjing-xiang-huan-cun-te-xing/">
        </link>
        <updated>2020-02-20T05:52:02.000Z</updated>
        <content type="html"><![CDATA[<p>Dockerfile简介<br>
Dockerfile 是Docker中用于定义镜像自动化构建流程的配置文件。在Dockerfile中，包含了构建镜像过程中需要执行的命令和其他操作。通过Dockerfile可以更加清晰，明确的给定Docker镜像的制作过程，由于仅是简单，小体积的文件，在网络等介质中传递的速度快，能够更快的实现容器迁移和集群部署。<br>
Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>相对于提交容器修改在进行镜像迁移的方式相比，使用Dockerfile有很多优势：</p>
<p>Dockerfile的体积远小于镜像包，更容易进行快速迁移和部署。<br>
环境构建流程记录在Dockerfile中，能够直观的看到镜像构建的顺序和逻辑。<br>
使用Dockerfile构建镜像能够更轻松的实现自动部署等自动化流程。<br>
在修改环境搭建细节时，修改Dockerfile文件更加简单。<br>
实际开发使用中很少会选择容器提交这种方法来构建镜像，而是几乎采用Dockerfile来制作镜像。</p>
<p>Docker执行Dockerfile的大致流程：<br>
（1）docker会从Dockerfile文件头FROM指定的基础镜像运行一个容器<br>
（2）然后执行一条指令，对容器作出修改。<br>
（3）接着执行类似于docker commit的操作，创建一个新的镜像层。<br>
（4）在基于刚创建的镜像运行一个新的容器。<br>
（4）执行dockerfile中的下一条指令，直到所有指令都执行完毕。<br>
docker会删除中间层创建的容器，但不会删除中间层镜像，所以可以使用docker run运行一个中间层容器，从而查看每一步构建后的镜像状态，，这样就可以进行调试。</p>
<p>Dockerfile 基本结构<br>
Dockerfile 又一行行命令语句组成，并且支持以#开头的注释行。<br>
Dockerfile 分为四部分：基础镜像信息，维护者信息，镜像操作指令，容器启动时执行指令。<br>
例如，以下为一个完整的Dockerfile：</p>
<h1 id="this-dockerfile-uses-the-ubuntu-image">This dockerfile uses the ubuntu image</h1>
<h1 id="version-2-edition-1">VERSION 2 - EDITION 1</h1>
<h1 id="author-docker_user">Author: docker_user</h1>
<h1 id="command-format-instruction-arguments-command">Command format: Instruction [arguments / command] ..</h1>
<h1 id="base-image-to-use-this-must-be-set-as-the-first-line">Base image to use, this must be set as the first line</h1>
<p>1，第一行必须指定，基础镜像信息<br>
FROM ubuntu</p>
<h1 id="maintainer-docker_user-docker_user-at-emailcom-docker_user">Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)</h1>
<p>2，维护者信息<br>
MAINTAINER docker_user docker_user@email.com</p>
<h1 id="commands-to-update-the-image">Commands to update the image</h1>
<p>3，镜像操作指令<br>
RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list<br>
RUN apt-get update &amp;&amp; apt-get install -y nginx<br>
RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf</p>
<h1 id="commands-when-creating-a-new-container">Commands when creating a new container</h1>
<p>4，容器启动执行指令<br>
CMD /usr/sbin/nginx<br>
其中，已开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如RUN指令。每执行一条RUN指令，镜像添加新的一层，并提交；最后是CMD指令，来指明运行容器时的操作命令。</p>
<p>Dockerfile 常用指令<br>
以下常见的dockerfile指令，基本包含常用的90%功能。</p>
<p>常用指令目录：<br>
1，FROM--指定基础镜像<br>
2，MAINTAINER--指定维护者信息<br>
3，RUN--运行指定的命令<br>
4，CMD--容器启动时执行的命令<br>
5， EXPOSE--声明容器的服务端口<br>
6，ENV--设置环境变量<br>
7，ARG--构建参数<br>
8，COPY--复制文件或目录<br>
9，ADD--更高级的复制文件/目录<br>
10，ENTRYPOINT--入口点<br>
11，ENTRYPOINT与CMD指令结合使用<br>
12，VOLUME--定义匿名卷<br>
13，WORKDIR--指定工作目录<br>
14，USER--指定当前用户<br>
15，ONBUILD--为镜像添加触发器<br>
1，FROM--指定基础镜像<br>
第一条指令必须为FROM指令。<br>
如果不以任何镜像为基础，那么写法如下，同时意味着接下来所写的指令将作为镜像的第一层开始：<br>
FROM nginx<br>
FROM 指令支持三种格式：</p>
<p>FROM <image><br>
FROM <image>:<tag><br>
FROM <image>:<digest></p>
<p>三种写法，第二种和第三种是可选项，如果没有选择，那么默认为latest。</p>
<p>在Dockerfile中可以多次出现FROM指令，当FROM第二次或者之后出现时，表示在此刻构建时，要将当前指出镜像的内容合并到此刻构建镜像的内容。</p>
<p>ARG是唯一可以在FROM之前执行的参数：</p>
<p>ARG  CODE_VERSION=latest<br>
FROM base:${CODE_VERSION}<br>
CMD  /code/run-app</p>
<p>FROM extras:${CODE_VERSION}<br>
CMD  /code/run-extras<br>
2，MAINTAINER--指定维护者信息<br>
格式为：MAINTAINER <name>，指定维护者信息（镜像维护者姓名或邮箱），可选项。<br>
例如：<br>
MAINTAINER docker_user docker_user@email.com<br>
3，RUN--运行指定的命令<br>
RUN有两种格式：</p>
<p>RUN <command><br>
RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</p>
<p>前者将在shell终端运行命令，即/bin/sh -c; 后者则使用exec执行。指定使用其它终端可以通过第二种方式实现，例如使用bash终端： RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]。</p>
<p>注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层，多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。一般一个RUN指令后边可以跟多个要执行的命令（使用&amp;&amp;符即可），当命令较长时可以使用&quot;&quot;来换行。<br>
例子如下：</p>
<p>RUN yum -y install gcc* pcre-devel openssl-devel zlib-devel unzip make vim net-tools elinks tree <br>
&amp;&amp; groupadd nginx <br>
&amp;&amp;  useradd  nginx -g nginx  -s /sbin/nologin<br>
4，CMD--容器启动时执行的命令<br>
CMD支持三种格式：</p>
<p>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式；<br>
CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；<br>
CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给 ENTRYPOINT 的默认参数；</p>
<p>指定启动容器时执行的命令，每个dockerfile只能有一条CMD命令。如果指令了多条命令，只有最后一条会被执行。</p>
<p>如果用户启动容器时候指定了运行的命令，则会覆盖掉CMD指定的命令。</p>
<p>补充细节：如果不是使用shell（/bin/sh）这种方式，”[]“中括号这里边包括参数的一定要用双引号,千万不能写成单引号。原因是参数传递后，docker解析的是一个JSON array<br>
例如：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
CMD echo hello world<br>
CMD echo hello china<br>
[root@sqm-docker01 dfs]# docker run --rm test:v1   #只有最后一条CMD命令会被执行<br>
hello china<br>
[root@sqm-docker01 dfs]# docker run --rm test:v1 echo &quot;hello friend&quot;  #在启动容器时指定运行命令，会将其覆盖<br>
hello friend<br>
采用exec格式，那么上面的例子改为：</p>
<p>FROM centos:latest<br>
CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello world&quot;]<br>
CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello china&quot;]<br>
还有一种情况下CMD会结合ENTRYPOINT指令使用，后面会讲到。</p>
<p>5， EXPOSE--声明容器的服务端口<br>
格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>
在Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用户则是运行时使用随机端口映射时，也就是docker run -P 时，会自动随机映射EXPOSE的端口。<br>
要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。<br>
例如：<br>
EXPOSE 80 443</p>
<p>6，ENV--设置环境变量<br>
格式有两种：</p>
<p>ENV <key> <value><br>
ENV <key1>=<value1> <key2>=<value2>...</p>
<p>两者的区别是第一种是一次设置一个，第二种是一次设置多个。</p>
<p>ENV这个指令就是指定一个环境变量，会被后续RUN指定使用，并在容器运行时保持。</p>
<p>ENV VERSION=1.0 DEBUG=on <br>
NAME=&quot;Happy Feet&quot;<br>
这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和shell下的行为是一致的。<br>
举例如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM busybox:latest<br>
ENV var1=haha var2=hehe<br>
RUN echo $var1 &gt; a.txt &amp;&amp; echo $var2 &gt; b.txt<br>
执行dockerfile后，进行容器查看文件：<br>
[root@sqm-docker01 dfs]# docker run --rm test:v2 /bin/sh<br>
/ # cat a.txt<br>
haha<br>
/ # cat b.txt<br>
hehe<br>
#并且定义的变量会在容器运行时保持：<br>
/ # echo $var1<br>
haha<br>
/ # echo $var2<br>
hehe<br>
7，ARG--构建参数</p>
<p>格式：<br>
ARG <name>[=<default value>]</p>
<p>构建参数和ENV的效果一样，都是设置环境变量。所不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在的这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为docker history还是可以看到所有值的。</p>
<p>#用法一：在执行docker build构建时传递参数</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ARG user<br>
ARG password<br>
RUN echo $user &gt; a.txt <br>
&amp;&amp; echo $password &gt;&gt; a.txt<br>
#传递两个参数时，则在每个参数中添加--build-arg。<br>
[root@sqm-docker01 dfs]# docker build --build-arg user=sqm --build-arg password=123.com  -t arg:v1 .<br>
#运行容器，参数传递成功<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v1 /bin/bash<br>
root@4809b0c54f8d:/# cat a.txt<br>
sqm<br>
123.com<br>
#与ENV不同，在容器中是不会存在这些变量的<br>
root@9383b7d3d21e:/# echo $user</p>
<p>root@9383b7d3d21e:/# echo $password</p>
<p>root@9383b7d3d21e:/#<br>
注意：如果指定了该参数，但Dockerfile中未使用，构建过程中会输出警告。</p>
<p>#用法二：在dockerfile中设定一个默认值，如果ARG指令具有默认值，并且在构建时未传递任何参数，那么构建其将使用该默认值</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ARG user=zhangsan<br>
ARG password=123456<br>
RUN echo $user $password &gt; a.txt<br>
#构建镜像且不传递任何参数：<br>
[root@sqm-docker01 dfs]# docker build -t arg:v2 .<br>
#运行容器，参数传递成功<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v2 /bin/bash<br>
root@b52fa70086de:/# cat a.txt<br>
zhangsan 123456<br>
#多阶段构建中每个阶段都必须包含arg指令：</p>
<p>FROM busybox<br>
ARG user<br>
RUN ./run/setup $user</p>
<p>FROM busybox<br>
ARG user<br>
RUN ./run/other $user<br>
#ENV变量会覆盖同名的ARG变量：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ARG user=zhangsan<br>
ENV user lisi<br>
RUN echo $user &gt; a.txt<br>
[root@sqm-docker01 dfs]# docker build -t arg:v3 .<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v3 /bin/bash<br>
root@a2aefd05efee:/# cat a.txt<br>
lisi<br>
#ARG和ENV指令结合使用：（一般这种用法，不常用）</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
ARG var<br>
ENV user=${var}<br>
RUN echo $user &gt; a.txt<br>
[root@sqm-docker01 dfs]# docker build --build-arg var=zhangsan -t arg:v4 .<br>
[root@sqm-docker01 dfs]# docker run -it --rm arg:v4 /bin/bash<br>
[root@26bf8c139a3f /]# cat a.txt<br>
zhangsan<br>
8，COPY--复制文件或目录‘’<br>
格式：</p>
<p>COPY [--chown=<user>:<group>] &lt;源路径&gt;... &lt;目标路径&gt;<br>
COPY [--chown=<user>:<group>] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</p>
<p>和RUN指令一样，也有两种格式，前者在shell终端运行; 后者则使用exec执行。</p>
<p>&lt;源路径&gt;为宿主机的上的路径，可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<p>COPY hom* /mydir/<br>
COPY hom?.txt /mydir/<br>
注意：&lt;源路径&gt;必须是在build上下文目录中，也就是Dockerfile配置文件所在的目录及下面的递归目录，如果拷贝上下文之外目录下的文件（不是Dockerfile所在的目录），则无法拷贝。<br>
build上下文的概念可参考：https://www.cnblogs.com/sparkdev/p/9573248.html</p>
<p>&lt;目标路径&gt;是容器中的路径，可以是绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。可以使用如下命令指定：</p>
<p>COPY [--chown=:] ...<br>
COPY [--chown=:] [&quot;&quot;,... &quot;&quot;] （包含空格的路径需要这种形式）<br>
–chown功能仅在用于构建Linux容器的Dockerfiles上受支持<br>
例如：<br>
COPY --chown=nginx:nginx files* /somedir/</p>
<p>举例：</p>
<p>[root@sqm-docker01 dfs]# echo &quot;hello world&quot; &gt; index.html<br>
[root@sqm-docker01 dfs]# echo aaaaaa &gt; a.txt<br>
[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
COPY ./index.html /usr/share/nginx/html/<br>
COPY ./a.txt /test/<br>
[root@sqm-docker01 dfs]# docker run --rm  nginx:v1  /bin/bash<br>
root@8a1ee4925b43:/# cat /usr/share/nginx/html/index.html<br>
hello world<br>
#即使目标目录不存在，会自己事先创建<br>
root@8a1ee4925b43:/# cat /test/a.txt<br>
aaaaaa<br>
##拷贝整个目录：<br>
格式：COPY src WORKDIR/src<br>
例如：</p>
<p>[root@sqm-docker01 dfs]# cat test/a.txt<br>
addddddddddddaaaaa<br>
[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
COPY ./test  /usr/share/nginx/test/<br>
#必须要在目标路径下指定要拷贝的目录，不然只拷贝源目录中的文件，而不拷贝目录</p>
<p>#进入容器查看整个目录及其目录下的文件<br>
[root@sqm-docker01 dfs]# docker run --rm nginx:v2 /bin/bash<br>
root@4eae96cbe364:/# cd /usr/share/nginx/<br>
root@4eae96cbe364:/usr/share/nginx# ls<br>
html  test<br>
root@4eae96cbe364:/usr/share/nginx# cat test/a.txt<br>
addddddddddddaaaaa<br>
9，ADD--更高级的复制文件/目录<br>
格式为：</p>
<p>ADD [--chown=<user>:<group>] &lt;源路径&gt;... &lt;目标路径&gt;<br>
ADD [--chown=<user>:<group>] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</p>
<p>ADD指令和COPY 的格式和性质基本一致。但是在 COPY`基础上增加了一些功能：可以是一个URL（通过URL下载下来自动设置权限600）；还可以是一个tar文件（自动解压为目录)。</p>
<p>举例：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
ADD nginx-1.8.0.tar.gz  /usr/src<br>
[root@sqm-docker01 dfs]# docker run --rm  nginx:v3 /bin/bash<br>
[root@0c8d6789aa4c /]# cd /usr/src/<br>
[root@0c8d6789aa4c src]# ls<br>
debug  kernels  nginx-1.8.0     #自动解压tar包<br>
[root@0c8d6789aa4c src]# ls nginx-1.8.0/<br>
CHANGES  CHANGES.ru  LICENSE  README  auto  conf  configure  contrib  html  man  src<br>
#通过url下载链接文件放到目标路径下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
ADD http://nginx.org/download/nginx-1.9.0.tar.gz /</p>
<p>[root@sqm-docker01 dfs]# docker run --rm  nginx:v4 /bin/bash<br>
[root@b9d978e3a333 /]# ls -lh nginx-1.9.0.tar.gz<br>
-rw------- 1 root root 835K Apr 28  2015 nginx-1.9.0.tar.gz<br>
#默认权限600<br>
#与COPY的区别：<br>
用于与COPY类似，不同的是COPY的只能是本地文件/目录，如果src是归档文件（tar,zip,tgz,xz等），使用ADD命令文件会被自动解压到dest。</p>
<p>因此在COPY和ADD指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY，仅在需要自动解压缩的场合使用 ADD。</p>
<p>10，ENTRYPOINT--入口点<br>
两种格式：</p>
<p>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]（exec格式）<br>
ENTRYPOINT command param1 param2（shell中执行）。</p>
<p>ENTRYPOINT 的 目的和CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比CMD要略显繁琐，需要通过docekr run的参数 --entrypoint 来指定。</p>
<p>#与CMD比较说明：<br>
1）相同点：只能写一条，如果写多条，那么只有最后一条生效。<br>
容器启动时才运行，运行时机相同。<br>
2）不同点： ENTRYPOINT不会被运行的命令覆盖，而CMD则会被覆盖。<br>
例子：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
ENTRYPOINT echo hello world<br>
ENTRYPOINT echo hello china<br>
#与CMD一样，只有最后一条指令生效<br>
[root@sqm-docker01 dfs]# docker run --rm  en:v1<br>
hello china<br>
#不同的是不会被运行时的命令覆盖<br>
[root@sqm-docker01 dfs]# docker run ---rm  en:v1 echo &quot;test&quot;<br>
hello china<br>
#除非使用--entrypoint参数<br>
[root@sqm-docker01 dfs]# docker run --rm --entrypoint hostname  en:v1<br>
fa667d019ce5<br>
#这里使用hostname命令将hello china覆盖了<br>
11，ENTRYPOINT与CMD指令结合使用<br>
#如果我们在Dockerfile中同时写了ENTRYPOINT和CMD，那么CMD指定的内容就会作为ENTRYPOINT的参数。<br>
举例如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
ENTRYPOINT [&quot;/usr/bin/ping&quot;,&quot;baidu.com&quot;,&quot;-c&quot;]<br>
CMD [&quot;4&quot;]<br>
#运行一个容器：<br>
[root@sqm-docker01 dfs]# docker run --rm en:v2<br>
PING baidu.com (39.156.69.79): 56 data bytes<br>
64 bytes from 39.156.69.79: seq=0 ttl=127 time=72.931 ms<br>
64 bytes from 39.156.69.79: seq=1 ttl=127 time=62.366 ms<br>
64 bytes from 39.156.69.79: seq=2 ttl=127 time=58.875 ms<br>
64 bytes from 39.156.69.79: seq=3 ttl=127 time=50.662 ms</p>
<p>--- baidu.com ping statistics ---<br>
4 packets transmitted, 4 packets received, 0% packet loss<br>
round-trip min/avg/max = 50.662/61.208/72.931 ms<br>
此时容器中运行的命令为：ping baidu.com -c 4。</p>
<p>#ENTRYPOINT中的参数始终会被使用，而CMD的额外参数可以在容器启动时动态替换掉，例子如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
ENTRYPOINT [&quot;/usr/bin/ping&quot;,&quot;baidu.com&quot;,&quot;-c&quot;]<br>
CMD [&quot;4&quot;]<br>
[root@sqm-docker01 dfs]# docker run --rm en:v2 2<br>
PING baidu.com (39.156.69.79) 56(84) bytes of data.<br>
64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=1 ttl=127 time=80.4 ms<br>
64 bytes from 39.156.69.79 (39.156.69.79): icmp_seq=2 ttl=127 time=61.5 ms</p>
<p>--- baidu.com ping statistics ---<br>
2 packets transmitted, 2 received, 0% packet loss, time 3ms<br>
rtt min/avg/max/mdev = 61.532/70.945/80.358/9.413 ms<br>
此时容器运行的命为：ping baidu.com -c 2。</p>
<p>#这两种指令结合起来使用，有什么好处呢？我们通过以场景来理解：（例子和上边例子大同小异）</p>
<p>//假设我们需要一个得知自己当前公网IP的镜像，可以那么先用CMD来实现：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
RUN yum  -y install curl<br>
CMD [&quot;/usr/bin/curl&quot;,&quot;-s&quot;,&quot;https://ip.cn&quot;]<br>
#构建镜像并运行容器：<br>
[root@sqm-docker01 dfs]# docker build -t myip:v1 .<br>
[root@sqm-docker01 dfs]# docker run --rm myip:v1<br>
{&quot;ip&quot;: &quot;117.136.60.216&quot;, &quot;country&quot;: &quot;江西省&quot;, &quot;city&quot;: &quot;移动&quot;}<br>
看起来我们是可以把它当作命令使用了，不过命令总有参数，如果我们希望显示HTTP头信息，就需要加上-i参数。那么我们可以直接加-i参数给docker run myip么？</p>
<p>[root@sqm-docker01 dfs]# docker run --rm myip:v1 -i<br>
docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: &quot;-i&quot;: executable file not found in $PATH&quot;: unknown.<br>
我们可以看到替换文件找不到的报错，executable file not found，之前我们说过，跟在上面名字后面的是command，运行时会替换为CMD的值。因此这里的-i替换了原来的CMD，而不是添加在原来的curl -s https://ip.cn 后面。-i根本不是命令，所以自然找不到。</p>
<p>//为了有很好的解决这个问题，我们将CMD和ENTRYPOINT结合使用：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos:latest<br>
RUN yum  -y install curl<br>
ENTRYPOINT [&quot;/usr/bin/curl&quot;,&quot;-s&quot;,&quot;https://ip.cn&quot;]<br>
CMD [&quot;-i&quot;]<br>
#构建并运行容器：<br>
[root@sqm-docker01 dfs]# docker build -t myip:v2 .<br>
[root@sqm-docker01 dfs]# docker run --rm myip:v2<br>
HTTP/2 200<br>
date: Wed, 19 Feb 2020 07:10:48 GMT<br>
content-type: application/json; charset=UTF-8<br>
set-cookie: __cfduid=d1903fe7e93a885c6ae4890572cda42161582096248; expires=Fri, 20-Mar-20 07:10:48 GMT; path=/; domain=.ip.cn; HttpOnly; SameSite=Lax<br>
cf-cache-status: DYNAMIC<br>
expect-ct: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot;<br>
alt-svc: h3-25=&quot;:443&quot;; ma=86400, h3-24=&quot;:443&quot;; ma=86400, h3-23=&quot;:443&quot;; ma=86400<br>
server: cloudflare<br>
cf-ray: 56766c505d6fb22e-HKG</p>
<p>{&quot;ip&quot;: &quot;117.136.60.216&quot;, &quot;country&quot;: &quot;江西省&quot;, &quot;city&quot;: &quot;移动&quot;}<br>
可以看到成功了，这是因为当存在ENTRYPOINT后，CMD的内容将会传递给ENTRYPOINT使用，从而达到了我们预期的效果。</p>
<p>##总结几条规律：</p>
<p>如果 ENTRYPOINT 使用了 shell 模式，CMD 指令会被忽略。<br>
如果 ENTRYPOINT 使用了 exec 模式，CMD 指定的内容被追加为 ENTRYPOINT 指定命令的参数。<br>
如果 ENTRYPOINT 使用了 exec 模式，CMD 也应该使用 exec 模式<br>
12，VOLUME--定义匿名卷<br>
格式为：</p>
<p>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]<br>
VOLUME &lt;路径&gt;</p>
<p>在Dockerfile中，我们可以预先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<p>VOLUME /data</p>
<p>这里的/data 目录就会在运行时自动挂载为匿名卷，任何向/data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。</p>
<p>docker run -d -v mydata:/data xxxx</p>
<p>在上边命令中，就使用了mydata 这个命名卷挂载到了/data 这个位置，替代了Dockerfile 中定义的匿名卷的挂载配置。</p>
<p>#注意：从该指令的支持的格式就可以知道，VOLUME只支持docker manager volume的挂载方式，而不支持bind mount的方式。</p>
<p>docker manager volume：不需要指定源文件，只需要指定mount point。把容器里面的目录映射到了本地（宿主机）。</p>
<p>举例如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
VOLUME /usr/share/nginx/html/<br>
#构建并运行容器：<br>
[root@sqm-docker01 dfs]# docker build -t volume:v1 .<br>
[root@sqm-docker01 dfs]# docker run -itd --name volume volume:v1<br>
5d963fb3b51ae9ddcc3b55382e289e0447235676f8893900a440f5f9500f035e<br>
我们通过docker inspect查看通过该dockerfile创建的大量生成的容器，可以看到挂载点的信息：</p>
<p>[root@sqm-docker01 dfs]# docker inspect volume<br>
&quot;Mounts&quot;: [<br>
{<br>
&quot;Type&quot;: &quot;volume&quot;,<br>
&quot;Name&quot;: &quot;190c5a22df09462a9f5fd54209b8bc5ad06fc9382f9c8b9c665c734e4bcf95e0&quot;,<br>
&quot;Source&quot;: &quot;/var/lib/docker/volumes/190c5a22df09462a9f5fd54209b8bc5ad06fc9382f9c8b9c665c734e4bcf95e0/_data&quot;,<br>
&quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,<br>
&quot;Driver&quot;: &quot;local&quot;,<br>
&quot;Mode&quot;: &quot;&quot;,<br>
&quot;RW&quot;: true,<br>
&quot;Propagation&quot;: &quot;&quot;<br>
}<br>
],<br>
从上面的信息可以看出默认挂载到本地的源路径为“/var/lib/docker/volumes/190c5a22df09462a9f5fd54209b8bc5ad06fc9382f9c8b9c665c734e4bcf95e0/_data” ，而目标路径（容器内的路径）为自定义的&quot;/usr/share/nginx/html&quot;。</p>
<p>13，WORKDIR--指定工作目录<br>
格式为：</p>
<p>WORKDIR &lt;工作目录路径&gt;</p>
<p>设置工作目录，对RUN，CMD，ENTRYPOINT,COPY,ADD生效。如果目录不存在，则会帮你创建，也可以设置多次,如：</p>
<p>WORKDIR /a<br>
WORKDIR b<br>
WORKDIR c<br>
RUN pwd<br>
#则最终的路径为/a/b/c。<br>
##WORKDIR也可以解析环境变量，如：</p>
<p>ENV DIRPATH /usr/src<br>
WORKDIR $DIRPATH<br>
RUN pwd<br>
#pwd的执行结果是/usr/src。<br>
注意：千万不要把dockerfile等同于shell脚本来书写，例如：</p>
<p>RUN cd /app<br>
RUN echo &quot;hello&quot; &gt; world.txt<br>
将这个dockerfile 进行构建镜像运行后，会发现找不到/app/world.txt 文件,或者其内容不是 hello。原因其实很简单，在dockerfile中这两行RUN命令的执行环境不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。<br>
如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>
<p>14，USER--指定当前用户</p>
<p>格式： USER &lt;用户名&gt;[:&lt;用户组&gt;]</p>
<p>USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。<br>
WORKDIR是改变工作目录，USER是改变之后层的执行RUN，CMD，以及ENTRYPOINT 这类命令的身份。<br>
当然，和WORKDIR一样，USER只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换：</p>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis<br>
USER redis<br>
RUN [ &quot;redis-server&quot; ]<br>
如果以root执行脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用su或者sudo，这些都需要比较麻烦的配置，而且在TTY缺失的环境下经常出错。一般使用 gosu。<br>
举例如下：</p>
<h1 id="建立-redis-用户并使用-gosu-换另一个用户执行命令">建立 redis 用户，并使用 gosu 换另一个用户执行命令</h1>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</p>
<h1 id="下载-gosu">下载 gosu</h1>
<p>RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; <br>
&amp;&amp; chmod +x /usr/local/bin/gosu <br>
&amp;&amp; gosu nobody true</p>
<h1 id="设置-cmd并以另外的用户redis执行">设置 CMD，并以另外的用户（redis）执行</h1>
<p>CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]<br>
15，ONBUILD--为镜像添加触发器</p>
<p>格式：ONBUILD &lt;其它指令&gt;</p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其他指令，比如RUN，COPY等，而这些指令，在当前镜像构建时并不会被执行。<br>
只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br>
Dockerfile中的其他指令都是为了定制当前镜像而准备的，唯有ONBUILD 是为了帮助别人定制自己而准备的。<br>
举例如下：<br>
//编写一个Dockerfile文件，内容如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM nginx:latest<br>
ONBUILD COPY ./index.html /   #拷贝文件到容器内的 / 下<br>
//利用上面的dockerfile文件构建镜像：<br>
[root@sqm-docker01 dfs]# docker build -t image1 .</p>
<p>//利用image1镜像创建容器：</p>
<p>[root@sqm-docker01 dfs]# docker run --rm -it image1 /bin/bash<br>
root@db8a068d9f30:/# ls<br>
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var<br>
boot  etc  lib   media  opt  root  sbin  sys  usr<br>
我们发现以image1镜像运行的容器/目录下并没有index.html文件，这说明ONBUILD指定的指令并不会在自己的镜像构建中执行。</p>
<p>//再编写一个新的Dockerfile文件，内容如下：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM image1  #使用的基础镜像是上面构建的镜像image1<br>
CMD echo hello world<br>
//利用上面的dockerfile文件构建镜像：</p>
<p>[root@sqm-docker01 dfs]# docker build -t image2 .<br>
Sending build context to Docker daemon  102.6MB<br>
Step 1/2 : FROM image1</p>
<h1 id="executing-1-build-trigger">Executing 1 build trigger</h1>
<p>---&gt; 796e32308d29<br>
Step 2/2 : CMD echo hello world<br>
---&gt; Running in 5c16f913f5e9<br>
Removing intermediate container 5c16f913f5e9<br>
---&gt; 4c0a45374727<br>
Successfully built 4c0a45374727<br>
Successfully tagged image2:latest<br>
//利用image2镜像创建容器：</p>
<p>[root@sqm-docker01 dfs]# docker run -it --rm image2 /bin/bash<br>
root@3e3c1d0fe3f6:/# ls<br>
bin   dev  home        lib    media  opt   root  sbin  sys  usr<br>
boot  etc  index.html  lib64  mnt    proc  run   srv   tmp  var<br>
root@3e3c1d0fe3f6:/# cat index.html<br>
hello world<br>
我们发现以image2镜像运行的容器根目录下有index.html文件，说明触发器执行了 COPY ./index.html / 指令。</p>
<p>镜像缓存特性:<br>
1）Docker 会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无需重新创建，如下所示：<br>
//创建一个新的dockerfile</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
RUN yum -y install vim<br>
//构建一个镜像<br>
[root@sqm-docker01 dfs]# docker build -t a:v1 .<br>
#往刚刚创建的dockerfile中添加一点新内容（在镜像中添加一条COPY指令）：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
RUN yum -y install vim<br>
COPY testfile /<br>
#以同一个dockefile重新构建镜像：</p>
<p>[root@sqm-docker01 dfs]# touch testfile<br>
[root@sqm-docker01 dfs]# docker build -t a:v2 .<br>
Sending build context to Docker daemon  102.6MB<br>
Step 1/3 : FROM centos<br>
---&gt; 0f3e07c0138f<br>
Step 2/3 : RUN yum -y install vim<br>
---&gt; Using cache<br>
---&gt; 6467d4675159<br>
Step 3/3 : COPY testfile /<br>
---&gt; 6b92fe05882f<br>
Successfully built 6b92fe05882f<br>
Successfully tagged a:v2<br>
(1）确保testfile文件已存在<br>
(2）Using cache，重点在这里：之前已经运行过相同的RUN指令，这次直接使用缓存中的镜像层6467d4675159。<br>
(3）执行COPY指令。<br>
其过程是启动临时容器，复制testfile，提交新的镜像层6b92fe05882f，删除临时容器。</p>
<p>如果我们希望在构建镜像时不使用缓存，可以在docker build命令中加上--no-cache参数。</p>
<p>2）Dockerfile中每一个指令都会创建一个镜像层，上层是依赖于下层的。无论什么时候，只要某一层发生变化，其上面所有层的缓存都会失效。<br>
也就是说，如果我们改变 Dockerfile 指令的执行顺序，或者修改或添加指令，都会使缓存失效。<br>
举例说明，比如交换上面RUN和COPY指令的顺序：</p>
<p>[root@sqm-docker01 dfs]# cat Dockerfile<br>
FROM centos<br>
COPY testfile /<br>
RUN yum -y install vim<br>
虽然在逻辑上这种改动对镜像的内容没有影响，但由于分层的结构特性，Docker 必须重建受影响的镜像层。</p>
<p>//重新构建镜像:</p>
<p>[root@sqm-docker01 dfs]# docker build -t a:v3 .<br>
Sending build context to Docker daemon  102.6MB<br>
Step 1/3 : FROM centos<br>
---&gt; 0f3e07c0138f<br>
Step 2/3 : COPY testfile /<br>
---&gt; 97e725434a6b<br>
Step 3/3 : RUN yum -y install vim<br>
---&gt; Running in 5f30ff393047<br>
......<br>
Removing intermediate container 5f30ff393047<br>
---&gt; 90ceae8b3638<br>
Successfully built 90ceae8b3638<br>
Successfully tagged a:v3<br>
从上面的输出可以看到生成了新的镜像层97e725434a6b，缓存已经失效。</p>
<p>除了构建时使用缓存，Docker 在下载镜像时也会使用。例如我们下载 httpd 镜像：</p>
<p>[root@sqm-docker01 dfs]#docker pull httpd<br>
Using default tag: latest<br>
latest: Pulling from library/httpd<br>
f17d81b4b692: Already exists<br>
06fe09255c64: Already exists<br>
0baf8127507d: Already exists<br>
07b9730387a3: Already exists<br>
6dbdee9d6fa5: Already exists<br>
Digest: sha256:76954e59f23aa9845ed81146ef3cad4a78f5eb3daab9625874ebca0e416367e2<br>
Status: Image is up to date for httpd:latest<br>
docker pull 命令输出显示第一层（base 镜像）已经存在，不需要下载。</p>
<p>简单了解镜像分层概念<br>
Dockerfile中每行代码都会产生一个新的分层，一个镜像不能超过127层，每个层都会产生一个单独的id。<br>
在已经存在image中的层，都是只读的。当一个image被运行成为一个container的时候，这个层是可读可写的，需要操作镜像层中的文件时，都是通过容器层复制一份，然后在进行操作，这个机制是copy on write（写时复制）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[同时使用有线网上内网、无线网上外网]]></title>
        <id>https://newdy.cf/post/tong-shi-shi-yong-you-xian-wang-shang-nei-wang-wu-xian-wang-shang-wai-wang/</id>
        <link href="https://newdy.cf/post/tong-shi-shi-yong-you-xian-wang-shang-nei-wang-wu-xian-wang-shang-wai-wang/">
        </link>
        <updated>2020-02-20T05:43:15.000Z</updated>
        <content type="html"><![CDATA[<p>方法一、</p>
<p>利用有线访问局域网数据库等，用无线网络访问外网，这里提供一种方法可以实现，可编写bat文件，并在cmd中执行：</p>
<p>route delete 0.0.0.0</p>
<p>route add 0.0.0.0 mask 0.0.0.0 172.20.1.254</p>
<p>route add 172.20.36.0 mask 255.255.255.0 172.20.36.254</p>
<p>解释一下：</p>
<p>其中172.20.1.254为无线网网关，172.20.36.254为有线网网关。这两句话的意思是：对于所有IP地址的访问，都从172.20.1.254走；但是，对于172.20.36开头的地址的访问，从172.20.36.254走。</p>
<p>针对上述情况，实际应用中，遇到windows 7与windows xp两者不一样，windows 7中，除了上述命令外，在TCP/IP配置中，无线外网设置为自动获取，内网配置为内网IP，子网掩码，网关。</p>
<p>widows xp中，除了上述命令外，在TCP/IP配置中，无线设置为手动输入IP，子网掩码，且网关留空，不填，内网配置为内网IP，子网掩码，网关。</p>
<p>方法二、</p>
<p>例1</p>
<p>我的笔记本用无线 网卡联互联网，同时局域网使用的是有线 连接（网段 132.147.X.X，不提供接入Internet服务），同时提供无线 网络连接供客户使用（网段192.168.1.X，可连接互联网）。</p>
<p>如果同时连接有线 网卡和 无线 网卡，因为有线 网卡的优先级较高，故仅有线 局域网能正常工作，无线 网卡可连接但却无法传送数据。要改变这种情况，需要对笔记本本地路由设置做出修改：访问132.147.X.X的请求均有有线 网卡处理，访问其它网络的则由无线 网卡处理。</p>
<p>具体设置步骤如下：</p>
<p>1. 设置无线 网卡为默认路由网关：无线 网络连接属性—Internet协议（TCP/IP）-属性-高级，手动输入无线 路由网关，我这里的是132.147.X.X，跃点数为“1”， 是最高优先级。到了这一步，如果有线 连接，无线 连接同时存在的话，所有的数据都是经由无线 网卡处理的。</p>
<p>2. 设置排除信息，把132.147.X.X路段的网址连接请求交由优先网卡处理：在命令行输入以下命令</p>
<p>route -p add 132.147.0.0 mask 255.255.0.0 132.147.160.1</p>
<p>其中132.147.0.0是本地局域网网段，132.147.160.1是本机所处子网段的默认网关，需要根据具体情况填写。经过以上设置，在访问本地网段的时候均由有线 网卡处理，访问互联网的时候可交由无线 网卡处理，就不会产生冲突了。</p>
<p>注意: 这里的172.16.x.x 和192.168.1.X 和你的局域网环境有关,可以命令行下ipconfig /all 查看</p>
<p>例2</p>
<p>局域网有线连接（网段172.16.X.X，不提供接入internet服务），WIFI连接（网段192.168.1.X，可连接互联网)。</p>
<p>如 果同时连接有线网卡和无线网卡，因为有线网卡的优先级较高，故仅有线局域网能正常工作，无线网卡可连接但却无法传送数据。要改变这种情况，需要对笔记本本 地路由设置做出修改：访问172.16.X.X的请求均有有线网卡处理，访问其它网络的则由无线网卡处理。设置步骤如下：</p>
<p>1》 设置无线网卡为默认路由网关：无线网络连接属性—Internet协议(TCP/IP)-属性-高级，手动输入无线路由网关，我这里的是 192.168.1.1，跃点数为“1”，是最高优先级。到了这一步，如果有线连接，无线连接同时存在的话，所有的数据都是经由无线网卡处理的。</p>
<p>2》设置排除信息，把172.16.X.X路段的网址连接请求交由优先网卡处理：在命令行输入以下命令<br>
route -p add 172.16.0.0 mask 255.255.0.0 172.16.6.1<br>
其中172.16.0.0是本地局域网网段，172.16.6.1是本机所处子网段的默认网关，需要根据具体情况填写。</p>
<p>经过以上设置，在访问本地网段的时候均由有线网卡处理，访问互联网的时候可交由无线网卡处理，就不会产生冲突了。</p>
<p>其它信息(来自网络)</p>
<p>不少公司的网管试图解决双网卡问题，下面我就给大家详细的讲解一下双网卡同时使用的方法，这样即可保障内网的安全，又能解决电脑访问外网的问题，一举两得。希望大家喜欢。</p>
<p>首先你的机器需要有两块网卡，分别接到两台交换机上,</p>
<p>internet地址：192.168.1.8，子网掩码：255.255.255.0，网关：192.168.1.1</p>
<p>内部网地址：172.23.1.8，子网掩码：255.255.255.0，网关：172.23.1.1</p>
<p>如果按正常的设置方法设置每块网卡的ip地址和网关，再cmd下使用route print查看时会看到</p>
<p>Network Destination Netmask Gateway Interface Metric</p>
<p>0.0.0.0 0.0.0.0 192.168.1.1 192.168.1.8</p>
<p>0.0.0.0 0.0.0.0 172.23.1.1 172.23.1.8</p>
<p>即指向0.0.0.0的有两个网关，这样就会出现路由冲突，两个网络都不能访问。</p>
<p>如何实现同时访问两个网络？那要用到route命令</p>
<p>第一步：route delete 0.0.0.0     &quot;删除所有0.0.0.0的路由&quot;</p>
<p>第二步：route add 0.0.0.0 mask 0.0.0.0 192.168.1.1     &quot;添加0.0.0.0网络路由&quot;这个是主要的,意思就是你可以上外网.</p>
<p>第三步：route add 172.23.0.0 mask 255.0.0.0 172.23.1.1    &quot;添加172.23.0.0网络路由&quot;，注意mask为255.0.0.0   ，而不是255.255.255.0 ，这样内部的多网段才可用。</p>
<p>这时就可以同时访问两个网络了，但碰到一个问题，使用上述命令添加的路由在系统重新启动后会自动丢失，怎样保存现有的路由表呢？</p>
<p>route add -p 添加静态路由，即重启后，路由不会丢失。注意使用前要在tcp/ip设置里去掉接在企业内部网的网卡的网关</p>
<hr>
<p>一些单位将内网和外网分开了。痛苦啊，偶单位就是如此。boss当然是基于安全性考虑了，可是没有笔记本的怎么办？又要办公，有得上网。没办法，发扬DIY精神偷偷装一块网卡，让聊天与工作同在。让你的主机内外兼顾。这是我在网上找到的，谢谢作者了。方法如下：<br>
1.设置其中接internet的网卡的网关为10.0.0.1，启用后就是默认网关<br>
--注：这是对应外网的网卡，按照你们单位外网的ip分配情况，在TCP/IP属性中配置好 ip、掩码、DNS</p>
<p>2.将连接单位内部网的网卡IP配好后，设网关设置为空（即不设网关），启用后，此时内网无法通过网关路由</p>
<p>3.进入CMD，运行：route -p add 192.0.0.0 mask 255.0.0.0 192.168.0.1 metric 1</p>
<p>--注：意思是将192*的IP包的路由网关设为192.168.0.1 ，-P 参数代表永久写入路由表，建议先不加此参数，实践通过后在写上去</p>
<ol start="4">
<li>OK！同时启用两个网卡，两个网关可以同时起作用了，两个子网也可以同时访问了，关机重启后也不用重设！</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NFS服务器搭建与配置]]></title>
        <id>https://newdy.cf/post/nfs-fu-wu-qi-da-jian-yu-pei-zhi/</id>
        <link href="https://newdy.cf/post/nfs-fu-wu-qi-da-jian-yu-pei-zhi/">
        </link>
        <updated>2020-02-20T05:31:42.000Z</updated>
        <content type="html"><![CDATA[<p>NFS服务简介<br>
什么是NFS？<br>
NFS就是Network File System的缩写，它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。</p>
<p>​	NFS服务器可以让PC将网络中的NFS服务器共享的目录挂载到本地端的文件系统中，而在本地端的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样，在使用上相当便利；</p>
<p>NFS一般用来存储共享视频，图片等静态数据。</p>
<p>NFS挂载原理：<br>
<img src="https://newdy.cf/post-images/1582176745939.jpg" alt="" loading="lazy"><br>
图；服务器挂载结构<br>
如上图示：</p>
<p>当我们在NFS服务器设置好一个共享目录/home/public后，其他的有权访问NFS服务器的NFS客户端就可以将这个目录挂载到自己文件系统的某个挂载点，这个挂载点可以自己定义，如上图客户端A与客户端B挂载的目录就不相同。并且挂载好后我们在本地能够看到服务端/home/public的所有数据。如果服务器端配置的客户端只读，那么客户端就只能够只读。如果配置读写，客户端就能够进行读写。挂载后，NFS客户端查看磁盘信息命令：#df –h。</p>
<p>既然NFS是通过网络来进行服务器端和客户端之间的数据传输，那么两者之间要传输数据就要有想对应的网络端口，NFS服务器到底使用哪个端口来进行数据传输呢？基本上NFS这个服务器的端口开在2049,但由于文件系统非常复杂。因此NFS还有其他的程序去启动额外的端口，这些额外的用来传输数据的端口是随机选择的，是小于1024的端口；既然是随机的那么客户端又是如何知道NFS服务器端到底使用的是哪个端口呢？这时就需要通过远程过程调用（Remote Procedure Call,RPC）协议来实现了！</p>
<p>RPC与NFS通讯原理：<br>
​	因为NFS支持的功能相当多，而不同的功能都会使用不同的程序来启动，每启动一个功能就会启用一些端口来传输数据，因此NFS的功能对应的端口并不固定，客户端要知道NFS服务器端的相关端口才能建立连接进行数据传输，而RPC就是用来统一管理NFS端口的服务，并且统一对外的端口是111，RPC会记录NFS端口的信息，如此我们就能够通过RPC实现服务端和客户端沟通端口信息。PRC最主要的功能就是指定每个NFS功能所对应的port number,并且通知客户端，记客户端可以连接到正常端口上去。</p>
<p>那么RPC又是如何知道每个NFS功能的端口呢？</p>
<p>首先当NFS启动后，就会随机的使用一些端口，然后NFS就会向RPC去注册这些端口，RPC就会记录下这些端口，并且RPC会开启111端口，等待客户端RPC的请求，如果客户端有请求，那么服务器端的RPC就会将之前记录的NFS端口信息告知客户端。如此客户端就会获取NFS服务器端的端口信息，就会以实际端口进行数据的传输了。</p>
<p>注意：在启动NFS SERVER之前，首先要启动RPC服务（即portmap服务，下同）否则NFS SERVER就无法向RPC服务区注册，另外，如果RPC服务重新启动，原来已经注册好的NFS端口数据就会全部丢失。因此此时RPC服务管理的NFS程序也要重新启动以重新向RPC注册。特别注意：一般修改NFS配置文档后，是不需要重启NFS的，直接在命令执行systemctl reload nfs或exportfs –rv即可使修改的/etc/exports生效</p>
<p>NFS客户端和NFS服务器通讯过程：<br>
<img src="https://newdy.cf/post-images/1582176817313.jpg" alt="" loading="lazy"><br>
首先服务器端启动RPC服务，并开启111端口</p>
<p>服务器端启动NFS服务，并向RPC注册端口信息</p>
<p>客户端启动RPC（portmap服务），向服务端的RPC(portmap)服务请求服务端的NFS端口</p>
<p>服务端的RPC(portmap)服务反馈NFS端口信息给客户端。</p>
<p>客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输。</p>
<p>Linux下NFS服务器部署<br>
NFS服务所需软件及主要配置文件：<br>
安装NFS服务，需要安装两个软件，分别是：</p>
<p>RPC主程序：rpcbind</p>
<p>NFS 其实可以被视为一个 RPC 服务，因为启动任何一个 RPC 服务之前，我们都需要做好 port 的对应 (mapping) 的工作才行，这个工作其实就是『 rpcbind 』这个服务所负责的！也就是说， 在启动任何一个 RPC 服务之前，我们都需要启动 rpcbind 才行！ (在 CentOS 5.x 以前这个软件称为 portmap，在 CentOS 6.x 之后才称为 rpcbind 的！)。</p>
<p>NFS主程序：nfs-utils</p>
<p>就是提供 rpc.nfsd 及 rpc.mountd 这两个 NFS daemons 与其他相关 documents 与说明文件、执行文件等的软件！这个就是 NFS 服务所需要的主要软件。</p>
<p>NFS的相关文件：</p>
<p>主要配置文件：/etc/exports<br>
这是 NFS 的主要配置文件了。该文件是空白的，有的系统可能不存在这个文件，主要手动建立。NFS的配置一般只在这个文件中配置即可。<br>
NFS 文件系统维护指令：/usr/sbin/exportfs<br>
这个是维护 NFS 分享资源的指令，可以利用这个指令重新分享 /etc/exports 变更的目录资源、将 NFS Server 分享的目录卸除或重新分享。<br>
分享资源的登录档：/var/lib/nfs/*tab<br>
在 NFS 服务器的登录文件都放置到 /var/lib/nfs/ 目录里面，在该目录下有两个比较重要的登录档， 一个是 etab ，主要记录了 NFS 所分享出来的目录的完整权限设定值；另一个 xtab 则记录曾经链接到此 NFS 服务器的相关客户端数据。<br>
客户端查询服务器分享资源的指令：/usr/sbin/showmount<br>
这是另一个重要的 NFS 指令。exportfs 是用在 NFS Server 端，而 showmount 则主要用在 Client 端。showmount 可以用来察看 NFS 分享出来的目录资源。<br>
服务端安装NFS服务步骤：<br>
第一步：安装NFS和rpc。<br>
[root@localhost ~]# yum install -y  nfs-utils<br>
#安装nfs服务<br>
[root@localhost ~]# yum install -y rpcbind<br>
#安装rpc服务</p>
<p>第二步：启动服务和设置开启启动：</p>
<p>注意：先启动rpc服务，再启动nfs服务。<br>
[root@localhost ~]# systemctl start rpcbind    #先启动rpc服务<br>
[root@localhost ~]# systemctl enable rpcbind   #设置开机启动<br>
[root@localhost ~]# systemctl start nfs-server nfs-secure-server<br>
#启动nfs服务和nfs安全传输服务<br>
[root@localhost ~]# systemctl enable nfs-server nfs-secure-server<br>
[root@localhost /]# firewall-cmd --permanent --add-service=nfs<br>
success   #配置防火墙放行nfs服务<br>
[root@localhost /]# firewall-cmd  --reload<br>
success</p>
<p>第三步：配置共享文件目录，编辑配置文件：</p>
<p>首先创建共享目录，然后在/etc/exports配置文件中编辑配置即可。</p>
<p>[root@localhost /]# mkdir /public<br>
#创建public共享目录<br>
[root@localhost /]# vi /etc/exports<br>
/public 192.168.245.0/24(ro)<br>
/protected 192.168.245.0/24（rw）<br>
[root@localhost /]# systemctl reload nfs<br>
#重新加载NFS服务，使配置文件生效<br>
配置文件说明：</p>
<p>格式： 共享目录的路径 允许访问的NFS客户端（共享权限参数）</p>
<p>如上，共享目录为/public , 允许访问的客户端为192.168.245.0/24网络用户，权限为只读。</p>
<p>请注意，NFS客户端地址与权限之间没有空格。</p>
<p>NFS输出保护需要用到kerberos加密（none，sys，krb5，krb5i，krb5p），格式sec=XXX</p>
<p>none：以匿名身份访问，如果要允许写操作，要映射到nfsnobody用户，同时布尔值开关要打开，setsebool nfsd_anon_write 1</p>
<p>sys：文件的访问是基于标准的文件访问，如果没有指定，默认就是sys， 信任任何发送过来用户名</p>
<p>krb5：客户端必须提供标识，客户端的表示也必须是krb5，基于域环境的认证</p>
<p>krb5i：在krb5的基础上做了加密的操作，对用户的密码做了加密，但是传输的数据没有加密</p>
<p>krb5p：所有的数据都加密</p>
<p>用于配置NFS服务程序配置文件的参数：</p>
<p>参数	作用<br>
ro                      	  只读<br>
rw	                         读写<br>
root_squash	           当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户<br>
no_root_squash      当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员<br>
all_squash             	 无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户<br>
sync	                    同时将数据写入到内存与硬盘中，保证不丢失数据<br>
async	                   优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据</p>
<p>NFS客户端挂载配置：<br>
**第一步：**使用showmount命令查看nfs服务器共享信息。输出格式为“共享的目录名称 允许使用客户端地址”。</p>
<p>[root@localhost ~]# showmount -e 192.168.245.128<br>
Export list for 192.168.245.128:<br>
/protected 192.168.245.0/24<br>
/public    192.168.245.0/24</p>
<p>showmount命令的用法；<br>
参数	作用<br>
-e	     显示NFS服务器的共享列表<br>
-a	     显示本机挂载的文件资源的情况NFS资源的情况<br>
-v	     显示版本号</p>
<p>**第二步，**在客户端创建目录，并挂载共享目录。</p>
<p>[root@localhost ~]# mkdir /mnt/public<br>
[root@localhost ~]# mkdir /mnt/data<br>
[root@localhost ~]# vim /etc/fstab<br>
#在该文件中挂载，使系统每次启动时都能自动挂载<br>
192.168.245.128:/public  /mnt/public       nfs    defaults 0 0<br>
192.168.245.128:/protected /mnt/data     nfs    defaults  0 1<br>
[root@localhost ~]# mount -a   #是文件/etc/fstab生效</p>
<p>第三步：检查：</p>
<p>[root@mail ~]# df -Th<br>
Filesystem                 Type      Size  Used Avail Use% Mounted on<br>
/dev/mapper/rhel-root      xfs        17G  3.1G   14G  18% /<br>
devtmpfs                   devtmpfs  1.4G     0  1.4G   0% /dev<br>
tmpfs                      tmpfs     1.4G  140K  1.4G   1% /dev/shm<br>
tmpfs                      tmpfs     1.4G  9.1M  1.4G   1% /run<br>
tmpfs                      tmpfs     1.4G     0  1.4G   0% /sys/fs/cgroup<br>
/dev/sda1                  xfs      1014M  173M  842M  18% /boot<br>
tmpfs                      tmpfs     280M   32K  280M   1% /run/user/0<br>
/dev/sr0                   iso9660   3.6G  3.6G     0 100% /mnt/cdrom<br>
192.168.245.128:/public    nfs4       17G  3.7G   14G  22% /mnt/public<br>
192.168.245.128:/protected nfs4       17G  3.7G   14G  22% /mnt/data</p>
<p>在Window上挂载NFS<br>
第一步：在控制面板–&gt;添加程序和功能–&gt;添加NFS组件。<br>
<img src="https://newdy.cf/post-images/1582177129076.png" alt="" loading="lazy"><br>
第二步：在此电脑，映射驱动器中添加nfs地址，和要共享的文件夹。<br>
<img src="https://newdy.cf/post-images/1582177154552.png" alt="" loading="lazy"><br>
第三步：如果权限有问题，打开注册表：regedit, 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ClientForNFS\CurrentVersion\Default 下新建两个OWORD（64）位值，添加值AnonymousGid，值默认为0，AnonymousUid，值默认为0。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows挂载nfs]]></title>
        <id>https://newdy.cf/post/windows-gua-zai-nfs/</id>
        <link href="https://newdy.cf/post/windows-gua-zai-nfs/">
        </link>
        <updated>2020-02-20T05:24:03.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://newdy.cf/post-images/1582176250349.png" alt="" loading="lazy"><br>
注意：Win10 Creators Update前只有Win10企业版可以挂载NFS， Creators Update后专业版也可挂载NFS了。</p>
<p>安装<br>
按Win+R输入OptionalFeatures，勾选”NFS服务”</p>
<p>不需要勾选“管理工具”，那玩意是个废物，非WinServer只能靠命令行挂载NFS。</p>
<p>装好后按Win+R输入cmd</p>
<p>查看远程电脑NFS共享的目录<br>
showmount -e 远程电脑的IP<br>
完整的用法：<br>
用法: showmount -e [server] 显示 NFS 服务器导出的所有共享。<br>
showmount -a [server] 列出客户端主机名或 IP 地址，以及使用“主机:目录”格式显示的安装目录。<br>
showmount -d [server] 显示 NFS 服务器上当前由某些 NFS 客户端安装的目录。<br>
挂载<br>
mount \远程电脑的IP\共享的目录 盘符<br>
<strong>例如：</strong><br>
mount \192.168.1.2\root V:<br>
关于如何配置远程电脑上的NFS请自行Google 完整的用法：<br>
用法: mount [-o options] [-u:username] [-p:&lt;password | *&gt;] &lt;\computername\sharename&gt; &lt;devicename | *&gt;</p>
<p>-o rsize=size 设置读取缓冲区的大小(以 KB 为单位)。<br>
-o wsize=size 设置写入缓冲区的大小(以 KB 为单位)。<br>
-o timeout=time 设置 RPC 调用的超时值(以秒为单位)。<br>
-o retry=number 设置软装载的重试次数。<br>
-o mtype=soft|hard 设置装载类型。<br>
-o lang=euc-jp|euc-tw|euc-kr|shift-jis|big5|ksc5601|gb2312-80|ansi<br>
指定用于文件和目录名称的编码。<br>
-o fileaccess=mode 指定文件的权限模式。<br>
这些模式用于在 NFS 服务器上创建的<br>
新文件。使用 UNIX 样式模式位指定。<br>
-o anon 作为匿名用户装载。<br>
-o nolock 禁用锁定。<br>
-o casesensitive=yes|no 指定在服务器上执行区分大小写的文件查找。<br>
-o sec=sys|krb5|krb5i|krb5p<br>
卸载</p>
<p>umount 盘符</p>
<p>例如：umount V:\</p>
<p>如果要卸载全部的NFS挂载：</p>
<p>umount -f -a</p>
<p>不要使用资源管理器的“断开网络驱动器”！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HomeAssistant+frp+NGINX+HTTPS实现无端口加密远程访问 ]]></title>
        <id>https://newdy.cf/post/homeassistantfrpnginxhttps-shi-xian-wu-duan-kou-jia-mi-yuan-cheng-fang-wen/</id>
        <link href="https://newdy.cf/post/homeassistantfrpnginxhttps-shi-xian-wu-duan-kou-jia-mi-yuan-cheng-fang-wen/">
        </link>
        <updated>2020-02-19T12:10:35.000Z</updated>
        <content type="html"><![CDATA[<p>等到IPV6和5G（678910G）普及了，才真的叫互联。<br>
一个公网IP就可以带来很多完全别样的感受</p>
<p>一般来说，HomeAssistant都是运行在家中的网络中，LZ想了想似乎没啥特别的需求要在外面访问它。</p>
<p>LZ家中用的北京联通，有公网IP（自己申请的）。老家的中国电信也有公网IP（也是一个电话到客服就行）<br>
这样一来就可以做很多事情。</p>
<p>一.北京出租屋：<br>
1.小米路由器3G，刷Padavan，<br>
2.北京联通宽带，公网IP（可以申请），破解光猫取得超级权限，开桥接（淘宝远程，几十块钱）可以双开，即获取两条线路和两个ip，然并卵，lz就租了个主卧。没那么多需求</p>
<ol>
<li>光纤接光猫，光猫LAN口拉网线到小米路由器WAN口。在路由器里拨号。</li>
<li>显示器HKC C340（34寸，21:9 100hz）</li>
<li>PS4 pro 不支持21:9 ，网线接路由器，NAT2的连接类型。</li>
<li>PS4输出HDMI接一个音视频分离的设备，即一边是HDMI, 另一边是HDMI，和3.5mm音频。不这样做PS4没声音。</li>
<li>PC，网线接路由器，DP接显示器。PC挂了三个固态和两个机械。分别装了windows，macOS和Ubuntu。macOS买了个有线蓝牙加网卡，隔空投送很安逸。就是最新的系统不支持N卡了。</li>
<li>有线蓝牙音箱Bose Soundlink Mini2，音频口接一个二分转接口，一个接PS4，一个接PC。可以同时播两路输入。叠加在一起。</li>
<li>信号切换器（DP+HDMI+miniDP输入，HDMI输出）。没有用。因为PC只能用DP才能获得全分辨率+100Hz。</li>
<li>支持iOS的MFI手柄，xbox one手柄</li>
<li>Surface GO</li>
<li>iPad， iPhone</li>
</ol>
<p>单位<br>
13. 笔记本，装FRP客户端bat自启，在任何地方可以应急访问。手机通过远程桌面看看公司笔记本摄像头什么的<br>
14. PC（基本不用）<br>
15. 瞎眼显示器<br>
16. Xbox one手柄</p>
<ol start="17">
<li>iOS和PC都装了Moonlight串流工具，PS4官方串流工具（iOS得切到非大陆账号）。  iOS还装了r-play（国区商店有，68rmb）</li>
<li>NVIDIA串流需要打开（默认关闭）</li>
<li>Steam串流（好像只能局域网）</li>
</ol>
<p>路由器上面<br>
20. ss （买了VPS）<br>
21.FTP+SMB+NFS<br>
22.VPN（PPTP）</p>
<p>二.老家：<br>
1 路由器设置相同<br>
2 中国电信+公网ip<br>
3 路由器DMZ电脑的ip<br>
4 iPad iPhone</p>
<p>实现功能：<br>
1.iOS装nplayer（十几块钱好像）可以在任何地方直接访问家里的移动硬盘看电影，非常流畅。<br>
2.于是我妈想看啥告诉我就直接下载，lz在教育网有ipv6可以下载，然后直接拖进硬盘（远程拖每秒10M左右）相当于通过公网ip造了一个私有的视频点播网站。无广告又高速233333    nplayer真的太好用了，支持各种协议<br>
3.Potplayer建远程专辑看，或者windows资源管理器映射远程磁盘<br>
4.PS4 Pro在公司PC远程串流玩。装了VDX驱动和映射， 直接用xbox手柄即可，也可插usb接ps4手柄。<br>
5.在公司远程moonlight串流家里PC的steam<br>
6 远程家里桌面。有公网ip加持，几乎体会不到是远程桌面，和在本地体验是一样的。lz远程剪辑视频也毫无差别感。<br>
7 手机也有远程mstsc官方工具<br>
8 在家中趴床上用surface go串流（坑，surface go高配版串流很卡，同样网络下e520就完美，iPad也可以）<br>
9 老家电脑有问题，直接mstsc输入域名即可秒连。<br>
10 公司也可以直接连vpn到家里，获取了一个子网地址，但是steam串流好像仍然检测不到。</p>
<ol>
<li>
<p>背景</p>
<p>使用https将本地的HomeAssistant服务转发到公网上，实现远程https和无端口访问。当然也可以转发任意其他服务。<br>
阿里云ECS Ubuntu 16.04  分配有公网IP &lt;A.B.C.D&gt;    //有公网IP的服务器均可<br>
本地树莓派在局域网内运行HomeAssistant &lt;192.168.1.233:8123&gt;<br>
网上教程比较杂乱。专门针对HomeAssistant的还没有。于是我尽可能详细的写一下。如果有问题可以回帖交流。</p>
</li>
</ol>
<p>FRP介绍：<br>
直白的说的话，<br>
frp有服务端frps和客户端frpc。<br>
服务端一般运行在有公网IP的机器上，如云服务器、VPS等。<br>
frpc可以放在任意能联网的设备上面，但本身不必具有公网地址。比如树莓派、电脑等等。进行ssh、远程桌面等访问。一个服务端可以有多个客户端。<br>
因为公网ip是在任何地方都可以访问的到的，<br>
而且通过frp的服务，通过服务端又可以访问到任意的客户端。<br>
这样就实现了你在任意能联网的设备上，通过访问公网ip，来访问任何运行了frpc客户端的设备。</p>
<ol>
<li>安装配置FRPS<br>
项目地址：GitHub - fatedier/frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.<br>
在ECS上执行：</li>
</ol>
<p>cd ~<br>
mkdir software<br>
cd software<br>
wget [url=https://github.com/fatedier/frp/]https://github.com/fatedier/frp/[/url] ... _linux_amd64.tar.gz<br>
tar -xzvf frp_0.22.0_linux_amd64.tar.gz<br>
mv frp_0.22.0_linux_amd64.tar.gz frps<br>
cd frps<br>
nano frps.ini</p>
<pre><code>frps.ini 文件配置：
</code></pre>
<p>[common]</p>
<p>bind_addr = 0.0.0.0</p>
<p>bind_port = 7000</p>
<p>vhost_http_port = 7080</p>
<p>vhost_https_port = 7443</p>
<p>dashboard_port = 7500</p>
<p>dashboard_user = your_account</p>
<p>dashboard_pwd = your_pwd</p>
<p>authentication_timeout = 900</p>
<p>token = your_token</p>
<p>frps开机自动启动：（引用：FRP自启动）</p>
<p>cd ~<br>
apt install supervisor<br>
cd /etc/supervisor/conf.d<br>
nano frps.conf</p>
<pre><code>frps.conf文件内容：
</code></pre>
<p>[program:frp]<br>
command = /home/software/frps/frps -c /home/software/frps/frps.ini<br>
autostart = true</p>
<h1 id="重启supervisor">重启supervisor</h1>
<p>systemctl restart supervisor</p>
<h1 id="查看supervisor运行状态">查看supervisor运行状态</h1>
<p>supervisorctl status</p>
<ol>
<li>安装配置FRPC<br>
在本地运行HomeAssistant的树莓派上执行：</li>
</ol>
<p>cd ~ mkdir software cd software wget https://github.com/fatedier/frp/... _linux_amd64.tar.gz tar -xzvf frp_0.22.0_linux_amd64.tar.gz mv frp_0.22.0_linux_amd64.tar.gz frpc cd frpc nano frpc.ini</p>
<p>[common]<br>
bind_addr = 0.0.0.0<br>
bind_port = 7000<br>
vhost_http_port = 7080<br>
vhost_https_port = 7443<br>
dashboard_port = 7500<br>
dashboard_user = your_account<br>
dashboard_pwd = your_pwd<br>
authentication_timeout = 900<br>
token = your_token</p>
<p>frps开机自动启动：（引用：FRP自启动）</p>
<p>cd ~<br>
apt install supervisor<br>
cd /etc/supervisor/conf.d<br>
nano frps.conf</p>
<pre><code>frps.conf文件内容：
</code></pre>
<p>[program:frp]<br>
command = /home/software/frps/frps -c /home/software/frps/frps.ini<br>
autostart = true</p>
<h1 id="重启supervisor-2">重启supervisor</h1>
<p>systemctl restart supervisor</p>
<h1 id="查看supervisor运行状态-2">查看supervisor运行状态</h1>
<p>supervisorctl status</p>
<ol>
<li>安装配置FRPC<br>
在本地运行HomeAssistant的树莓派上执行：</li>
</ol>
<p>frps.ini 文件配置：<br>
[common]</p>
<p>server_addr = &lt;A.B.C.D&gt;</p>
<p>server_port = 7000</p>
<p>token = your_token</p>
<p>[homeassistant]</p>
<p>type = tcp</p>
<p>local_ip = 127.0.0.1</p>
<p>local_port = 8123</p>
<p>remote_port = 9000</p>
<p>custom_domains = your_website.com  //自己的域名，并且解析到ECS的公网IP</p>
<ol>
<li>安装配置NGINX<br>
在ECS上执行：</li>
</ol>
<p>cd ~<br>
cd software<br>
apt update<br>
apt upgrade<br>
apt install nginx<br>
#NGINX开机启动<br>
systemctl enable nginx<br>
#NGINX的配置文件在/etc/nginx下<br>
cd /etc/nginx<br>
cd sites-enabled<br>
#新建一个配置文件，文件名可以为网站的域名<br>
touch your_website.com<br>
nano your_website.com</p>
<p>在阿里云申请域名ssl证书：<br>
your_website.com文件的配置：<br>
server {<br>
listen 80;<br>
server_name your_website.com;<br>
location / {<br>
rewrite ^ https://your_website.com$request_uri? permanent;<br>
}<br>
}<br>
server {<br>
listen 443;<br>
server_name your_website.com;<br>
ssl on;<br>
ssl_certificate cert/your_website.com.pem;<br>
ssl_certificate_key cert/your_website.com.key;<br>
ssl_session_timeout 5m;<br>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>
ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;<br>
ssl_prefer_server_ciphers on;<br>
proxy_set_header X-Forwarded-For $remote_addr;</p>
<pre><code>location  /api/websocket  {
    proxy_pass http://127.0.0.1:9000/api/websocket;
    proxy_read_timeout 60s;
    proxy_set_header Host $host;
    proxy_set_header X-Real_IP $remote_addr;
    proxy_set_header X-Forwarded-for $remote_addr;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection 'Upgrade';
}

location  / {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_buffering off;
    proxy_pass http://127.0.0.1:9000;
}
</code></pre>
<p>}</p>
<p>#检查NGINX配置文件是否正确 nginx -t #加载NGINX配置文件 nginx -s reload</p>
<p>[common]<br>
server_addr = &lt;A.B.C.D&gt;<br>
server_port = 7000<br>
token = your_token<br>
[homeassistant]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 8123<br>
remote_port = 9000<br>
custom_domains = your_website.com  //自己的域名，并且解析到ECS的公网IP</p>
<ol>
<li>安装配置NGINX<br>
在ECS上执行：</li>
</ol>
<p>cd ~<br>
cd software<br>
apt update<br>
apt upgrade<br>
apt install nginx<br>
#NGINX开机启动<br>
systemctl enable nginx<br>
#NGINX的配置文件在/etc/nginx下<br>
cd /etc/nginx<br>
cd sites-enabled<br>
#新建一个配置文件，文件名可以为网站的域名<br>
touch your_website.com<br>
nano your_website.com</p>
<p>在阿里云申请域名ssl证书：（可参考：为阿里云域名配置免费SSL支持https加密访问简单教程 )</p>
<p>your_website.com文件的配置：</p>
<p>server {<br>
listen 80;<br>
server_name your_website.com;<br>
location / {<br>
rewrite ^ [url=https://your_website.com]https://your_website.com[/url]$request_uri? permanent;<br>
}<br>
}<br>
server {<br>
listen 443;<br>
server_name your_website.com;<br>
ssl on;<br>
ssl_certificate cert/your_website.com.pem;<br>
ssl_certificate_key cert/your_website.com.key;<br>
ssl_session_timeout 5m;<br>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>
ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;<br>
ssl_prefer_server_ciphers on;<br>
proxy_set_header X-Forwarded-For $remote_addr;<br>
location /api/websocket {<br>
#端口写的和frpc.ini中一致<br>
proxy_pass [url=http://127.0.0.1:9000/api/websocket;]http://127.0.0.1:9000/api/websocket;[/url]<br>
proxy_read_timeout 60s;<br>
proxy_set_header Host $host;<br>
proxy_set_header X-Real_IP $remote_addr;<br>
proxy_set_header X-Forwarded-for $remote_addr;<br>
proxy_http_version 1.1;<br>
proxy_set_header Upgrade $http_upgrade;<br>
proxy_set_header Connection 'Upgrade';<br>
}<br>
location / {<br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>
proxy_set_header Host $http_host;<br>
proxy_buffering off;<br>
proxy_pass [url=http://127.0.0.1:9000;]http://127.0.0.1:9000;[/url]<br>
}<br>
}</p>
<p>5.访问https://your_website.com<br>
<img src="https://newdy.cf/post-images/1582114764896.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[黑群晖通过frps，实现quick connect功能]]></title>
        <id>https://newdy.cf/post/hei-qun-hui-tong-guo-frpsshi-xian-quick-connect-gong-neng/</id>
        <link href="https://newdy.cf/post/hei-qun-hui-tong-guo-frpsshi-xian-quick-connect-gong-neng/">
        </link>
        <updated>2020-02-19T08:35:45.000Z</updated>
        <content type="html"><![CDATA[<p>一、申请免费的vps：https://cloud.google.com/free/</p>
<p>二、申请完vps后， 安装frps服务端：</p>
<p>第一步：</p>
<p>1、获取root 权限<br>
sudo su -<br>
2、#安装git客户端<br>
yum install -y git<br>
3、获取一键安装frps脚本<br>
git clone https://github.com/clangcn/onekey-install-shell.git<br>
4、进去frps目录安装<br>
cd onekey-install-shell/frps<br>
sh version.sh<br>
sh install-frps.sh install</p>
<p>然后选择2，就可以一直往下按回车</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582101396279.jpg" alt="" loading="lazy"></figure>
<p>安装完后，会看到相关的账户密码信息，请记录下来。</p>
<p>第二步：</p>
<p>开通vps上的防火墙，在vpc网络–&gt; 防火墙策略下新建一条防火墙，放开所有端口和所有来源ip（假如要安全的话，按需开通端口）,如下图</p>
<figure data-type="image" tabindex="2"><img src="https://newdy.cf/post-images/1582101413068.jpg" alt="" loading="lazy"></figure>
<p>第三步：</p>
<p>启动frps</p>
<p>frps start</p>
<p>三、申请域名</p>
<p>1、在godaddy网站：https://www.godaddy.com/， 申请一级域名，如： nayfeng.com</p>
<p>2、新建一条A记录指向刚才新建vps的外网ip，如nas。那么我们访问nas.nafeng.com，就是指向刚才新建的vps上</p>
<p>四、在vps上配置frps 服务端</p>
<p>1、进入fprs的配置模式<br>
frps config<br>
2、新增配置信息，在配置文件最下面，新增subdomain_host = nayfeng.com，然后按esc，:，x 来保存配置信息</p>
<p>3、重启fprs服务使其生效<br>
frps restart<br>
如下图所示的配置信息，</p>
<figure data-type="image" tabindex="3"><img src="https://newdy.cf/post-images/1582101434713.jpg" alt="" loading="lazy"></figure>
<p>五、在群晖nas上配置frp 客户端</p>
<p>1、通过security crt 或者xshell的客户端，远程登录我们的nas</p>
<p>2、下载frps客户端 wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz<br>
3、解压<br>
tar zxvf frp_0.21.0_linux_amd64.tar.gz<br>
4、修改配置文件<br>
cd frp_0.20.0_linux_amd64<br>
vi frpc.ini</p>
<p>frpc.ini的参考配置信息如下，只要把我们的中文说明的两行根据实际情况填写就可以了，部分人发现配置文件有异常的话，请把中文的备注信息删除：</p>
<p>[common]<br>
server_addr = 1.1.1.1   #用个人vps公网ip代替<br>
server_port = 5443<br>
token = tian-xie-token    #填写自己vps上frps的token配置代替</p>
<p>admin_addr = 127.0.0.1<br>
admin_port = 7001<br>
admin_user = admin<br>
admin_pwd = admin</p>
<p>[ssh]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 22<br>
remote_port = 6000</p>
<p>[plex]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 32400<br>
remote_port = 32400</p>
<p>[nas_5000]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 5000<br>
remote_port = 5000</p>
<p>[nas_5001]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 5001<br>
remote_port = 5001</p>
<p>[nas_web]<br>
type = http<br>
local_ip = 127.0.0.1<br>
local_port = 5000<br>
subdomain = nas</p>
<p>[nas_webs]<br>
type = https<br>
local_ip = 127.0.0.1<br>
local_port = 5001<br>
subdomain = nas<br>
5、启动frpc 客户端服务</p>
<p>nohup ./frpc -c frpc.ini &amp;<br>
在此你就可以在外网连你家的黑群晖了。</p>
<p>六、使其更完美。</p>
<p>1、在黑群晖上装一个dns server套件</p>
<p>2、在dns server 上添加刚申请的域名，并新建一条A记录，指向我们家里的nas ip</p>
<p>3、在路由器上设置分配dns server 的ip  为我们nas 存储的ip</p>
<p>4、黑群晖开机启动frps</p>
]]></content>
    </entry>
</feed>