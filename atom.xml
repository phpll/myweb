<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newdy.cf</id>
    <title>Gridea</title>
    <updated>2020-02-20T05:30:34.856Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newdy.cf"/>
    <link rel="self" href="https://newdy.cf/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://newdy.cf/images/avatar.png</logo>
    <icon>https://newdy.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[windows挂载nfs]]></title>
        <id>https://newdy.cf/post/windows-gua-zai-nfs/</id>
        <link href="https://newdy.cf/post/windows-gua-zai-nfs/">
        </link>
        <updated>2020-02-20T05:24:03.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://newdy.cf/post-images/1582176250349.png" alt="" loading="lazy"><br>
注意：Win10 Creators Update前只有Win10企业版可以挂载NFS， Creators Update后专业版也可挂载NFS了。</p>
<p>安装<br>
按Win+R输入OptionalFeatures，勾选”NFS服务”</p>
<p>不需要勾选“管理工具”，那玩意是个废物，非WinServer只能靠命令行挂载NFS。</p>
<p>装好后按Win+R输入cmd</p>
<p>查看远程电脑NFS共享的目录<br>
showmount -e 远程电脑的IP<br>
完整的用法：<br>
用法: showmount -e [server] 显示 NFS 服务器导出的所有共享。<br>
showmount -a [server] 列出客户端主机名或 IP 地址，以及使用“主机:目录”格式显示的安装目录。<br>
showmount -d [server] 显示 NFS 服务器上当前由某些 NFS 客户端安装的目录。<br>
挂载<br>
mount \远程电脑的IP\共享的目录 盘符<br>
<strong>例如：</strong><br>
mount \192.168.1.2\root V:<br>
关于如何配置远程电脑上的NFS请自行Google 完整的用法：<br>
用法: mount [-o options] [-u:username] [-p:&lt;password | *&gt;] &lt;\computername\sharename&gt; &lt;devicename | *&gt;</p>
<p>-o rsize=size 设置读取缓冲区的大小(以 KB 为单位)。<br>
-o wsize=size 设置写入缓冲区的大小(以 KB 为单位)。<br>
-o timeout=time 设置 RPC 调用的超时值(以秒为单位)。<br>
-o retry=number 设置软装载的重试次数。<br>
-o mtype=soft|hard 设置装载类型。<br>
-o lang=euc-jp|euc-tw|euc-kr|shift-jis|big5|ksc5601|gb2312-80|ansi<br>
指定用于文件和目录名称的编码。<br>
-o fileaccess=mode 指定文件的权限模式。<br>
这些模式用于在 NFS 服务器上创建的<br>
新文件。使用 UNIX 样式模式位指定。<br>
-o anon 作为匿名用户装载。<br>
-o nolock 禁用锁定。<br>
-o casesensitive=yes|no 指定在服务器上执行区分大小写的文件查找。<br>
-o sec=sys|krb5|krb5i|krb5p<br>
卸载</p>
<p>umount 盘符</p>
<p>例如：umount V:\</p>
<p>如果要卸载全部的NFS挂载：</p>
<p>umount -f -a</p>
<p>不要使用资源管理器的“断开网络驱动器”！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HomeAssistant+frp+NGINX+HTTPS实现无端口加密远程访问 ]]></title>
        <id>https://newdy.cf/post/homeassistantfrpnginxhttps-shi-xian-wu-duan-kou-jia-mi-yuan-cheng-fang-wen/</id>
        <link href="https://newdy.cf/post/homeassistantfrpnginxhttps-shi-xian-wu-duan-kou-jia-mi-yuan-cheng-fang-wen/">
        </link>
        <updated>2020-02-19T12:10:35.000Z</updated>
        <content type="html"><![CDATA[<p>等到IPV6和5G（678910G）普及了，才真的叫互联。<br>
一个公网IP就可以带来很多完全别样的感受</p>
<p>一般来说，HomeAssistant都是运行在家中的网络中，LZ想了想似乎没啥特别的需求要在外面访问它。</p>
<p>LZ家中用的北京联通，有公网IP（自己申请的）。老家的中国电信也有公网IP（也是一个电话到客服就行）<br>
这样一来就可以做很多事情。</p>
<p>一.北京出租屋：<br>
1.小米路由器3G，刷Padavan，<br>
2.北京联通宽带，公网IP（可以申请），破解光猫取得超级权限，开桥接（淘宝远程，几十块钱）可以双开，即获取两条线路和两个ip，然并卵，lz就租了个主卧。没那么多需求</p>
<ol>
<li>光纤接光猫，光猫LAN口拉网线到小米路由器WAN口。在路由器里拨号。</li>
<li>显示器HKC C340（34寸，21:9 100hz）</li>
<li>PS4 pro 不支持21:9 ，网线接路由器，NAT2的连接类型。</li>
<li>PS4输出HDMI接一个音视频分离的设备，即一边是HDMI, 另一边是HDMI，和3.5mm音频。不这样做PS4没声音。</li>
<li>PC，网线接路由器，DP接显示器。PC挂了三个固态和两个机械。分别装了windows，macOS和Ubuntu。macOS买了个有线蓝牙加网卡，隔空投送很安逸。就是最新的系统不支持N卡了。</li>
<li>有线蓝牙音箱Bose Soundlink Mini2，音频口接一个二分转接口，一个接PS4，一个接PC。可以同时播两路输入。叠加在一起。</li>
<li>信号切换器（DP+HDMI+miniDP输入，HDMI输出）。没有用。因为PC只能用DP才能获得全分辨率+100Hz。</li>
<li>支持iOS的MFI手柄，xbox one手柄</li>
<li>Surface GO</li>
<li>iPad， iPhone</li>
</ol>
<p>单位<br>
13. 笔记本，装FRP客户端bat自启，在任何地方可以应急访问。手机通过远程桌面看看公司笔记本摄像头什么的<br>
14. PC（基本不用）<br>
15. 瞎眼显示器<br>
16. Xbox one手柄</p>
<ol start="17">
<li>iOS和PC都装了Moonlight串流工具，PS4官方串流工具（iOS得切到非大陆账号）。  iOS还装了r-play（国区商店有，68rmb）</li>
<li>NVIDIA串流需要打开（默认关闭）</li>
<li>Steam串流（好像只能局域网）</li>
</ol>
<p>路由器上面<br>
20. ss （买了VPS）<br>
21.FTP+SMB+NFS<br>
22.VPN（PPTP）</p>
<p>二.老家：<br>
1 路由器设置相同<br>
2 中国电信+公网ip<br>
3 路由器DMZ电脑的ip<br>
4 iPad iPhone</p>
<p>实现功能：<br>
1.iOS装nplayer（十几块钱好像）可以在任何地方直接访问家里的移动硬盘看电影，非常流畅。<br>
2.于是我妈想看啥告诉我就直接下载，lz在教育网有ipv6可以下载，然后直接拖进硬盘（远程拖每秒10M左右）相当于通过公网ip造了一个私有的视频点播网站。无广告又高速233333    nplayer真的太好用了，支持各种协议<br>
3.Potplayer建远程专辑看，或者windows资源管理器映射远程磁盘<br>
4.PS4 Pro在公司PC远程串流玩。装了VDX驱动和映射， 直接用xbox手柄即可，也可插usb接ps4手柄。<br>
5.在公司远程moonlight串流家里PC的steam<br>
6 远程家里桌面。有公网ip加持，几乎体会不到是远程桌面，和在本地体验是一样的。lz远程剪辑视频也毫无差别感。<br>
7 手机也有远程mstsc官方工具<br>
8 在家中趴床上用surface go串流（坑，surface go高配版串流很卡，同样网络下e520就完美，iPad也可以）<br>
9 老家电脑有问题，直接mstsc输入域名即可秒连。<br>
10 公司也可以直接连vpn到家里，获取了一个子网地址，但是steam串流好像仍然检测不到。</p>
<ol>
<li>
<p>背景</p>
<p>使用https将本地的HomeAssistant服务转发到公网上，实现远程https和无端口访问。当然也可以转发任意其他服务。<br>
阿里云ECS Ubuntu 16.04  分配有公网IP &lt;A.B.C.D&gt;    //有公网IP的服务器均可<br>
本地树莓派在局域网内运行HomeAssistant &lt;192.168.1.233:8123&gt;<br>
网上教程比较杂乱。专门针对HomeAssistant的还没有。于是我尽可能详细的写一下。如果有问题可以回帖交流。</p>
</li>
</ol>
<p>FRP介绍：<br>
直白的说的话，<br>
frp有服务端frps和客户端frpc。<br>
服务端一般运行在有公网IP的机器上，如云服务器、VPS等。<br>
frpc可以放在任意能联网的设备上面，但本身不必具有公网地址。比如树莓派、电脑等等。进行ssh、远程桌面等访问。一个服务端可以有多个客户端。<br>
因为公网ip是在任何地方都可以访问的到的，<br>
而且通过frp的服务，通过服务端又可以访问到任意的客户端。<br>
这样就实现了你在任意能联网的设备上，通过访问公网ip，来访问任何运行了frpc客户端的设备。</p>
<ol>
<li>安装配置FRPS<br>
项目地址：GitHub - fatedier/frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.<br>
在ECS上执行：</li>
</ol>
<p>cd ~<br>
mkdir software<br>
cd software<br>
wget [url=https://github.com/fatedier/frp/]https://github.com/fatedier/frp/[/url] ... _linux_amd64.tar.gz<br>
tar -xzvf frp_0.22.0_linux_amd64.tar.gz<br>
mv frp_0.22.0_linux_amd64.tar.gz frps<br>
cd frps<br>
nano frps.ini</p>
<pre><code>frps.ini 文件配置：
</code></pre>
<p>[common]</p>
<p>bind_addr = 0.0.0.0</p>
<p>bind_port = 7000</p>
<p>vhost_http_port = 7080</p>
<p>vhost_https_port = 7443</p>
<p>dashboard_port = 7500</p>
<p>dashboard_user = your_account</p>
<p>dashboard_pwd = your_pwd</p>
<p>authentication_timeout = 900</p>
<p>token = your_token</p>
<p>frps开机自动启动：（引用：FRP自启动）</p>
<p>cd ~<br>
apt install supervisor<br>
cd /etc/supervisor/conf.d<br>
nano frps.conf</p>
<pre><code>frps.conf文件内容：
</code></pre>
<p>[program:frp]<br>
command = /home/software/frps/frps -c /home/software/frps/frps.ini<br>
autostart = true</p>
<h1 id="重启supervisor">重启supervisor</h1>
<p>systemctl restart supervisor</p>
<h1 id="查看supervisor运行状态">查看supervisor运行状态</h1>
<p>supervisorctl status</p>
<ol>
<li>安装配置FRPC<br>
在本地运行HomeAssistant的树莓派上执行：</li>
</ol>
<p>cd ~ mkdir software cd software wget https://github.com/fatedier/frp/... _linux_amd64.tar.gz tar -xzvf frp_0.22.0_linux_amd64.tar.gz mv frp_0.22.0_linux_amd64.tar.gz frpc cd frpc nano frpc.ini</p>
<p>[common]<br>
bind_addr = 0.0.0.0<br>
bind_port = 7000<br>
vhost_http_port = 7080<br>
vhost_https_port = 7443<br>
dashboard_port = 7500<br>
dashboard_user = your_account<br>
dashboard_pwd = your_pwd<br>
authentication_timeout = 900<br>
token = your_token</p>
<p>frps开机自动启动：（引用：FRP自启动）</p>
<p>cd ~<br>
apt install supervisor<br>
cd /etc/supervisor/conf.d<br>
nano frps.conf</p>
<pre><code>frps.conf文件内容：
</code></pre>
<p>[program:frp]<br>
command = /home/software/frps/frps -c /home/software/frps/frps.ini<br>
autostart = true</p>
<h1 id="重启supervisor-2">重启supervisor</h1>
<p>systemctl restart supervisor</p>
<h1 id="查看supervisor运行状态-2">查看supervisor运行状态</h1>
<p>supervisorctl status</p>
<ol>
<li>安装配置FRPC<br>
在本地运行HomeAssistant的树莓派上执行：</li>
</ol>
<p>frps.ini 文件配置：<br>
[common]</p>
<p>server_addr = &lt;A.B.C.D&gt;</p>
<p>server_port = 7000</p>
<p>token = your_token</p>
<p>[homeassistant]</p>
<p>type = tcp</p>
<p>local_ip = 127.0.0.1</p>
<p>local_port = 8123</p>
<p>remote_port = 9000</p>
<p>custom_domains = your_website.com  //自己的域名，并且解析到ECS的公网IP</p>
<ol>
<li>安装配置NGINX<br>
在ECS上执行：</li>
</ol>
<p>cd ~<br>
cd software<br>
apt update<br>
apt upgrade<br>
apt install nginx<br>
#NGINX开机启动<br>
systemctl enable nginx<br>
#NGINX的配置文件在/etc/nginx下<br>
cd /etc/nginx<br>
cd sites-enabled<br>
#新建一个配置文件，文件名可以为网站的域名<br>
touch your_website.com<br>
nano your_website.com</p>
<p>在阿里云申请域名ssl证书：<br>
your_website.com文件的配置：<br>
server {<br>
listen 80;<br>
server_name your_website.com;<br>
location / {<br>
rewrite ^ https://your_website.com$request_uri? permanent;<br>
}<br>
}<br>
server {<br>
listen 443;<br>
server_name your_website.com;<br>
ssl on;<br>
ssl_certificate cert/your_website.com.pem;<br>
ssl_certificate_key cert/your_website.com.key;<br>
ssl_session_timeout 5m;<br>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>
ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;<br>
ssl_prefer_server_ciphers on;<br>
proxy_set_header X-Forwarded-For $remote_addr;</p>
<pre><code>location  /api/websocket  {
    proxy_pass http://127.0.0.1:9000/api/websocket;
    proxy_read_timeout 60s;
    proxy_set_header Host $host;
    proxy_set_header X-Real_IP $remote_addr;
    proxy_set_header X-Forwarded-for $remote_addr;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection 'Upgrade';
}

location  / {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_buffering off;
    proxy_pass http://127.0.0.1:9000;
}
</code></pre>
<p>}</p>
<p>#检查NGINX配置文件是否正确 nginx -t #加载NGINX配置文件 nginx -s reload</p>
<p>[common]<br>
server_addr = &lt;A.B.C.D&gt;<br>
server_port = 7000<br>
token = your_token<br>
[homeassistant]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 8123<br>
remote_port = 9000<br>
custom_domains = your_website.com  //自己的域名，并且解析到ECS的公网IP</p>
<ol>
<li>安装配置NGINX<br>
在ECS上执行：</li>
</ol>
<p>cd ~<br>
cd software<br>
apt update<br>
apt upgrade<br>
apt install nginx<br>
#NGINX开机启动<br>
systemctl enable nginx<br>
#NGINX的配置文件在/etc/nginx下<br>
cd /etc/nginx<br>
cd sites-enabled<br>
#新建一个配置文件，文件名可以为网站的域名<br>
touch your_website.com<br>
nano your_website.com</p>
<p>在阿里云申请域名ssl证书：（可参考：为阿里云域名配置免费SSL支持https加密访问简单教程 )</p>
<p>your_website.com文件的配置：</p>
<p>server {<br>
listen 80;<br>
server_name your_website.com;<br>
location / {<br>
rewrite ^ [url=https://your_website.com]https://your_website.com[/url]$request_uri? permanent;<br>
}<br>
}<br>
server {<br>
listen 443;<br>
server_name your_website.com;<br>
ssl on;<br>
ssl_certificate cert/your_website.com.pem;<br>
ssl_certificate_key cert/your_website.com.key;<br>
ssl_session_timeout 5m;<br>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>
ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;<br>
ssl_prefer_server_ciphers on;<br>
proxy_set_header X-Forwarded-For $remote_addr;<br>
location /api/websocket {<br>
#端口写的和frpc.ini中一致<br>
proxy_pass [url=http://127.0.0.1:9000/api/websocket;]http://127.0.0.1:9000/api/websocket;[/url]<br>
proxy_read_timeout 60s;<br>
proxy_set_header Host $host;<br>
proxy_set_header X-Real_IP $remote_addr;<br>
proxy_set_header X-Forwarded-for $remote_addr;<br>
proxy_http_version 1.1;<br>
proxy_set_header Upgrade $http_upgrade;<br>
proxy_set_header Connection 'Upgrade';<br>
}<br>
location / {<br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>
proxy_set_header Host $http_host;<br>
proxy_buffering off;<br>
proxy_pass [url=http://127.0.0.1:9000;]http://127.0.0.1:9000;[/url]<br>
}<br>
}</p>
<p>5.访问https://your_website.com<br>
<img src="https://newdy.cf/post-images/1582114764896.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[黑群晖通过frps，实现quick connect功能]]></title>
        <id>https://newdy.cf/post/hei-qun-hui-tong-guo-frpsshi-xian-quick-connect-gong-neng/</id>
        <link href="https://newdy.cf/post/hei-qun-hui-tong-guo-frpsshi-xian-quick-connect-gong-neng/">
        </link>
        <updated>2020-02-19T08:35:45.000Z</updated>
        <content type="html"><![CDATA[<p>一、申请免费的vps：https://cloud.google.com/free/</p>
<p>二、申请完vps后， 安装frps服务端：</p>
<p>第一步：</p>
<p>1、获取root 权限<br>
sudo su -<br>
2、#安装git客户端<br>
yum install -y git<br>
3、获取一键安装frps脚本<br>
git clone https://github.com/clangcn/onekey-install-shell.git<br>
4、进去frps目录安装<br>
cd onekey-install-shell/frps<br>
sh version.sh<br>
sh install-frps.sh install</p>
<p>然后选择2，就可以一直往下按回车</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582101396279.jpg" alt="" loading="lazy"></figure>
<p>安装完后，会看到相关的账户密码信息，请记录下来。</p>
<p>第二步：</p>
<p>开通vps上的防火墙，在vpc网络–&gt; 防火墙策略下新建一条防火墙，放开所有端口和所有来源ip（假如要安全的话，按需开通端口）,如下图</p>
<figure data-type="image" tabindex="2"><img src="https://newdy.cf/post-images/1582101413068.jpg" alt="" loading="lazy"></figure>
<p>第三步：</p>
<p>启动frps</p>
<p>frps start</p>
<p>三、申请域名</p>
<p>1、在godaddy网站：https://www.godaddy.com/， 申请一级域名，如： nayfeng.com</p>
<p>2、新建一条A记录指向刚才新建vps的外网ip，如nas。那么我们访问nas.nafeng.com，就是指向刚才新建的vps上</p>
<p>四、在vps上配置frps 服务端</p>
<p>1、进入fprs的配置模式<br>
frps config<br>
2、新增配置信息，在配置文件最下面，新增subdomain_host = nayfeng.com，然后按esc，:，x 来保存配置信息</p>
<p>3、重启fprs服务使其生效<br>
frps restart<br>
如下图所示的配置信息，</p>
<figure data-type="image" tabindex="3"><img src="https://newdy.cf/post-images/1582101434713.jpg" alt="" loading="lazy"></figure>
<p>五、在群晖nas上配置frp 客户端</p>
<p>1、通过security crt 或者xshell的客户端，远程登录我们的nas</p>
<p>2、下载frps客户端 wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz<br>
3、解压<br>
tar zxvf frp_0.21.0_linux_amd64.tar.gz<br>
4、修改配置文件<br>
cd frp_0.20.0_linux_amd64<br>
vi frpc.ini</p>
<p>frpc.ini的参考配置信息如下，只要把我们的中文说明的两行根据实际情况填写就可以了，部分人发现配置文件有异常的话，请把中文的备注信息删除：</p>
<p>[common]<br>
server_addr = 1.1.1.1   #用个人vps公网ip代替<br>
server_port = 5443<br>
token = tian-xie-token    #填写自己vps上frps的token配置代替</p>
<p>admin_addr = 127.0.0.1<br>
admin_port = 7001<br>
admin_user = admin<br>
admin_pwd = admin</p>
<p>[ssh]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 22<br>
remote_port = 6000</p>
<p>[plex]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 32400<br>
remote_port = 32400</p>
<p>[nas_5000]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 5000<br>
remote_port = 5000</p>
<p>[nas_5001]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 5001<br>
remote_port = 5001</p>
<p>[nas_web]<br>
type = http<br>
local_ip = 127.0.0.1<br>
local_port = 5000<br>
subdomain = nas</p>
<p>[nas_webs]<br>
type = https<br>
local_ip = 127.0.0.1<br>
local_port = 5001<br>
subdomain = nas<br>
5、启动frpc 客户端服务</p>
<p>nohup ./frpc -c frpc.ini &amp;<br>
在此你就可以在外网连你家的黑群晖了。</p>
<p>六、使其更完美。</p>
<p>1、在黑群晖上装一个dns server套件</p>
<p>2、在dns server 上添加刚申请的域名，并新建一条A记录，指向我们家里的nas ip</p>
<p>3、在路由器上设置分配dns server 的ip  为我们nas 存储的ip</p>
<p>4、黑群晖开机启动frps</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx SSL 双向认证]]></title>
        <id>https://newdy.cf/post/nginx-ssl-shuang-xiang-ren-zheng/</id>
        <link href="https://newdy.cf/post/nginx-ssl-shuang-xiang-ren-zheng/">
        </link>
        <updated>2020-02-19T08:34:51.000Z</updated>
        <content type="html"><![CDATA[<p>安装Nginx和OpenSSL</p>
<p>yum install nginx openssl -y<br>
SSL 服务器 / 客户端双向验证证书的生成<br>
创建一个新的 CA 根证书，在 nginx 安装目录下新建 ca 文件夹，进入 ca，创建几个子文件夹</p>
<p>$ mkdir ca &amp;&amp; cd ca<br>
$ mkdir newcerts private conf server</p>
<h1 id="newcerts-子目录将用于存放-ca-签署过的数字证书证书备份目录private-用于存放-ca-的私钥conf-目录用于存放一些简化参数用的配置文件server-存放服务器证书文件">newcerts 子目录将用于存放 CA 签署过的数字证书(证书备份目录)；private 用于存放 CA 的私钥；conf 目录用于存放一些简化参数用的配置文件；server 存放服务器证书文件。</h1>
<p>conf 目录新建 openssl.conf 文件</p>
<p>[ ca ]<br>
default_ca      = foo                   # The default ca section</p>
<p>[ foo ]<br>
dir            = ./         # top dir<br>
database       = ./index.txt          # index file.<br>
new_certs_dir  = ./newcerts           # new certs dir</p>
<p>certificate    = ./private/ca.crt         # The CA cert<br>
serial         = ./serial             # serial no file<br>
private_key    = ./private/ca.key  # CA private key<br>
RANDFILE       = ./private/.rand      # random number file</p>
<p>default_days   = 3650                     # how long to certify for<br>
default_crl_days= 30                     # how long before next CRL<br>
default_md     = sha256                     # message digest method to use<br>
unique_subject = no                      # Set to 'no' to allow creation of<br>
# several ctificates with same subject.<br>
policy         = policy_any              # default policy</p>
<p>[ policy_any ]<br>
countryName = match<br>
stateOrProvinceName = match<br>
organizationName = match<br>
organizationalUnitName = match<br>
localityName            = optional<br>
commonName              = supplied<br>
emailAddress            = optional<br>
生成私钥 key 文件</p>
<p>$ openssl genrsa -out private/ca.key 2048<br>
输出<br>
Generating RSA private key, 2048 bit long modulus<br>
.......+++<br>
.........................+++<br>
e is 65537 (0x10001)<br>
private 目录下有 ca.key 文件生成。<br>
生成证书请求 csr 文件</p>
<p>$ openssl req -new -key private/ca.key -out private/ca.csr<br>
生成凭证 crt 文件</p>
<p>$ openssl x509 -req -days 365 -in private/ca.csr -signkey private/ca.key -out private/ca.crt<br>
private 目录下有 ca.crt 文件生成。<br>
为我们的 key 设置起始序列号和创建 CA 键库</p>
<p>$ echo FACE &gt; serial<br>
#可以是任意四个字符<br>
$ touch index.txt<br>
为 &quot;用户证书&quot; 的移除创建一个证书撤销列表</p>
<p>$ openssl ca -gencrl -out ./private/ca.crl -crldays 7 -config &quot;./conf/openssl.conf&quot;</p>
<h1 id="输出">输出</h1>
<p>Using configuration from ./conf/openssl.conf<br>
private 目录下有 ca.crl 文件生成。<br>
服务器证书的生成</p>
<p>创建一个 key</p>
<p>$ openssl genrsa -out server/server.key 2048<br>
为我们的 key 创建一个证书签名请求 csr 文件<br>
$ openssl req -new -key server/server.key -out server/server.csr<br>
使用我们私有的 CA key 为刚才的 key 签名<br>
$ openssl ca -in server/server.csr -cert private/ca.crt -keyfile private/ca.key -out     server/server.crt -config &quot;./conf/openssl.conf&quot;</p>
<h1 id="输出-2">输出</h1>
<p>Using configuration from ./conf/openssl.conf<br>
Check that the request matches the signature<br>
Signature ok<br>
The Subject's Distinguished Name is as follows<br>
countryName           :PRINTABLE:'CN'<br>
stateOrProvinceName   :ASN.1 12:'GuangDong'<br>
localityName          :ASN.1 12:'XX'<br>
organizationName      :ASN.1 12:'<strong><strong>'<br>
organizationalUnitName:ASN.1 12:'<strong>'<br>
commonName            :ASN.1 12:'</strong>'<br>
emailAddress          :IA5STRING:'</strong></strong>'<br>
Certificate is to be certified until Mar 19 07:37:02 2017 GMT (365 days)<br>
Sign the certificate? [y/n]:y</p>
<p>1 out of 1 certificate requests certified, commit? [y/n]y<br>
Write out database with 1 new entries<br>
Data Base Updated<br>
注：签名信息每次必须输入一致</p>
<p>客户端证书的生成 * 创建存放 key 的目录 users</p>
<p>$ mkdir users</p>
<ul>
<li>为用户创建一个 key</li>
</ul>
<p>$ openssl genrsa -des3 -out ./users/client.key 2048<br>
输出：<br>
Enter pass phrase for ./users/client.key:123<br>
Verifying - Enter pass phrase for ./users/client.key:123<br>
#要求输入 pass phrase，这个是当前 key 的口令，以防止本密钥泄漏后被人盗用。两次输入同一个密码(比如我这里输入     123)，users 目录下有 client.key 文件生成。<br>
为 key 创建一个证书签名请求 csr 文件<br>
$ openssl req -new -key ./users/client.key -out ./users/client.csr<br>
#users 目录下有 client.csr 文件生成。<br>
使用我们私有的 CA key 为刚才的 key 签名</p>
<p>$ openssl ca -in ./users/client.csr -cert ./private/ca.crt -keyfile ./private/ca.key -out    ./users/client.crt -config &quot;./conf/openssl.conf&quot;<br>
将证书转换为大多数浏览器都能识别的 PKCS12 文件</p>
<p>$ openssl pkcs12 -export -clcerts -in ./users/client.crt -inkey ./users/client.key -out ./users/client.p12<br>
输出</p>
<p>Enter pass phrase for ./users/client.key:<br>
Enter Export Password:<br>
Verifying - Enter Export Password:<br>
输入密码后，users 目录下有 client.p12 文件生成。</p>
<p>Nginx配置<br>
vhosts.xxx.conf 在 server { }段输入如下代码</p>
<pre><code>listen       443; 
server_name  localhost; 
ssi on; 
ssi_silent_errors on; 
ssi_types text/shtml; 

ssl                  on; 
ssl_certificate      /usr/local/nginx/ca/server/server.crt; 
ssl_certificate_key  /usr/local/nginx/ca/server/server.key; 
ssl_client_certificate /usr/local/nginx/ca/private/ca.crt; 

ssl_session_timeout  5m; 
ssl_verify_client on;  #开户客户端证书验证 
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDH:AES:HIGH:!aNULL:!MD5:!ADH:!DH;


ssl_prefer_server_ciphers   on; 
</code></pre>
<p>重新启动Nginx</p>
<p>nginx -t<br>
nginx -s reload</p>
<p>作者：假装_很深沉<br>
链接：https://www.jianshu.com/p/40bfe7566254<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成Nginx服务器SSL证书和客户端证书]]></title>
        <id>https://newdy.cf/post/sheng-cheng-nginx-fu-wu-qi-ssl-zheng-shu-he-ke-hu-duan-zheng-shu/</id>
        <link href="https://newdy.cf/post/sheng-cheng-nginx-fu-wu-qi-ssl-zheng-shu-he-ke-hu-duan-zheng-shu/">
        </link>
        <updated>2020-02-19T04:54:59.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx服务器SSL证书<br>
生成pass key</p>
<p>下面的命令用于生成一个2048bit的pass key, -passout pass:111111 用于避免交互式输入密码</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:111111 -out server.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
...........+++<br>
.....................+++<br>
e is 65537 (0x10001)</p>
<p>生成key</p>
<p>下面的命令用于生成私钥, -passin pass:111111是和pass key的密码对应的, 用于避免交互式输入密码</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:111111 -in server.pass.key -out server.key<br>
writing RSA key</p>
<p>生成证书签发请求文件(CSR)</p>
<p>下面的命令用于生成csr文件, 这里需要填写机构相关信息. 其中CN务必填写为对应的服务器域名. 最后那个challenge password, 是这个csr的password</p>
<h2 id="tomcata02-tmp-openssl-req-new-sha256-key-serverkey-out-servercsryou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -sha256 -key server.key -out server.csr<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:iSomeone<br>
Common Name (eg, your name or your server's hostname) []:internal.someone.com<br>
Email Address []:</p>
<p>Please enter the following 'extra' attributes<br>
to be sent with your certificate request<br>
A challenge password []:222222<br>
An optional company name []:</p>
<p>发送CSR文件给CA服务商签发证书</p>
<p>如果是购买的CA服务商的SSL证书服务, 这一步把CSR发给服务商就可以了. 收到证书后将内容写入到 server.pem 文件</p>
<p>在Nginx上这样配置</p>
<p>server {<br>
listen      443;<br>
server_name  www.example.com;</p>
<pre><code>ssl                  on;
ssl_certificate      /path/to/ssl/server.pem;
ssl_certificate_key  /path/to/ssl/server.key;
ssl_protocols TLSv1.2 TLSv1.1 TLSv1;
ssl_session_cache shared:ssl_www_example_com:5m;
ssl_session_timeout  5m;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:DES-CBC3-SHA;
#...
location / {
    #...
}
#...
</code></pre>
<p>}</p>
<p>制作自签名证书</p>
<p>如果是打算制作自签名证书, 则进行如下的操作生成pem证书</p>
<p>[tomcat@a02 tmp]$ openssl x509 -req -sha256 -days 3655 -in server.csr -signkey server.key -out server.pem<br>
Signature ok<br>
subject=/C=CN/ST=Beijing/L=Chaoyang/O=HenSomeone/OU=iSomeone/CN=internal.someone.com<br>
Getting Private key</p>
<p>Nginx客户端验证证书<br>
Nginx客户端验证证书和服务端SSL证书其实是没关系的, 你可以一边使用CA签发的证书, 一边使用自己制作的客户端验证证书.</p>
<p>生成服务器端私钥</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:201906 -out ca.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
...............................................................................................................+++<br>
...................................+++<br>
e is 65537 (0x10001)</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:201906 -in ca.pass.key -out ca.key<br>
writing RSA key</p>
<p>生成服务器端证书</p>
<p>下面的命令会生成服务器证书ca.pem, 用于配制到nginx.</p>
<h2 id="tomcata02-tmp-openssl-req-new-x509-days-3655-key-cakey-out-capemyou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -x509 -days 3655 -key ca.key -out ca.pem<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:iSomeone<br>
Common Name (eg, your name or your server's hostname) []:internal.someone.com<br>
Email Address []:</p>
<p>生成客户端私钥</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:201906 -out client_01.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
..........................+++<br>
.....+++<br>
e is 65537 (0x10001)</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:201906 -in client_01.pass.key -out client_01.key<br>
writing RSA key</p>
<p>生成客户端证书签发请求CSR</p>
<h2 id="tomcata02-tmp-openssl-req-new-key-client_01key-out-client_01csryou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -key client_01.key -out client_01.csr<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:Staff<br>
Common Name (eg, your name or your server's hostname) []:Staff<br>
Email Address []:</p>
<p>Please enter the following 'extra' attributes<br>
to be sent with your certificate request<br>
A challenge password []:201907<br>
An optional company name []:</p>
<p>签发客户端证书</p>
<p>下面的命令, 用服务端的私钥和服务端的证书, 对客户端的CSR进行签发, 生成服务端证书. 这里有一个 -set_serial 01 的参数, 如果签发多个客户端证书, 这个数字不能重复</p>
<p>[tomcat@a02 tmp]$ openssl x509 -req -days 3655 -in client_01.csr -CA ca.pem -CAkey ca.key -set_serial 01 -out client_01.pem<br>
Signature ok<br>
subject=/C=CN/ST=Beijing/L=Chaoyang/O=HenSomeone/OU=Staff/CN=Staff<br>
Getting CA Private Key</p>
<p>客户端证书格式转换</p>
<p>前面生成的证书, 不能直接用于常见的应用, 需要转换成应用需要的格式</p>
<p>Full PEM:</p>
<p>[tomcat@a02 tmp]$ cat client_01.key client_01.pem ca.pem &gt; client_01.full.pem</p>
<p>PFX - 这里输入的export password, 就是应用导入PFX证书时需要输入的密码.</p>
<p>[tomcat@a02 tmp]$ openssl pkcs12 -export -out client_01.full.pfx -inkey client_01.key -in client_01.pem -certfile ca.pem<br>
Enter Export Password:<br>
Verifying - Enter Export Password:</p>
<p>配置Nginx的客户端验证证书</p>
<p>ssl_client_certificate /path/to/ca.pem;<br>
ssl_verify_client optional; # or <code>on</code> if you require client key</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx配置中location匹配规则详解]]></title>
        <id>https://newdy.cf/post/nginx-pei-zhi-zhong-location-pi-pei-gui-ze-xiang-jie/</id>
        <link href="https://newdy.cf/post/nginx-pei-zhi-zhong-location-pi-pei-gui-ze-xiang-jie/">
        </link>
        <updated>2020-02-19T04:48:02.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx 的语法形式是： location [=|<sub>|</sub><em>|^~|@] /uri/ { … } ，意思是可以以“ = ”或“ ~</em> ”或“ ~ ”或“ ^~ ”或“ @ ”符号为前缀，当然也可以没有前缀（因为 [A] 是表示可选的 A ； A|B 表示 A 和 B 选一个），紧接着是 /uri/ ，再接着是{…} 指令块，整个意思是对于满足这样条件的 /uri/ 适用指令块 {…} 的指令。</p>
<p>上述各种 location 可分两大类，分别是：“普通 location ”，官方英文说法是 location using   literal strings 和“正则 location ”，英文说法是 location using regular expressions 。其中“普通 location ”是以“ = ”或“ ^~ ”为前缀或者没有任何前缀的 /uri/ ；“正则 location ”是以“ ~ ”或“ ~* ”为前缀的 /uri/ 。</p>
<p>那么，当我们在一个 server 上下文编写了多个 location 的时候， Nginx 对于一个 HTTP 请求，是如何匹配到一个 location 做处理呢？用一句话简单概括 Nginx 的 location 匹配规则是：“正则 location ”让步 “普通 location”的严格精确匹配结果；但覆盖 “普通 location ”的最大前缀匹配结果。理解这句话，我想通过下面的实例来说明。</p>
<p>#1 先普通 location ，再正则 location<br>
周边不少童鞋告诉我， nginx 是“先匹配正则 location 再匹配普通 location ”，其实这是一个误区， nginx 其实是“先匹配普通 location ，再匹配正则 location ”，但是普通 location 的匹配结果又分两种：一种是“严格精确匹配”，官方英文说法是“ exact match ”；另一种是“最大前缀匹配”，官方英文说法是“ Literal strings match the beginning portion of the query – the most specific match will be used. ”。我们做个实验：</p>
<p>例题 1 ：假设 nginx 的配置如下</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>附录 nginx 的目录结构是： nginx-&gt;html-&gt;index.html</p>
<p>上述配置的意思是： location / {… deny all;} 普通 location 以“ / ”开始的 URI 请求（注意任何 HTTP 请求都必然以“/ ”开始，所以“ / ”的意思是所有的请求都能被匹配上），都拒绝访问； location ~.html$ {allow all;} 正则 location以 .html 结尾的 URI 请求，都允许访问。</p>
<p>测试结果：</p>
<p>[root@web108 ~]# curl http://localhost:9090/</p>
<html>
<head><title>403 Forbidden</title></head>
<body bgcolor=”white”>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]# curl http://localhost:9090/index.html</p>
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor=”white” text=”black”>
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
<p>[root@web108 ~]# curl http://localhost:9090/index_notfound.html</p>
<html>
<head><title>404 Not Found</title></head>
<body bgcolor=”white”>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>测试结果如下：</p>
<p>URI 请求	HTTP 响应<br>
curl http://localhost:9090/	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!<br>
curl http://localhost:9090/index_notfound.html	404 Not Found<br>
curl http://localhost:9090/ 的结果是“ 403 Forbidden ”，说明被匹配到“ location / {..deny all;} ”了，原因很简单HTTP 请求 GET / 被“严格精确”匹配到了普通 location / {} ，则会停止搜索正则 location ；</p>
<p>curl http://localhost:9090/index.html 结果是“ Welcome to nginx! ”，说明没有被“ location / {…deny all;} ”匹配，否则会 403 Forbidden ，但 /index.html 的确也是以“ / ”开头的，只不过此时的普通 location / 的匹配结果是“最大前缀”匹配，所以 Nginx 会继续搜索正则 location ， location ~ .html$ 表达了以 .html 结尾的都 allow all; 于是接着就访问到了实际存在的 index.html 页面。</p>
<p>curl http://localhost:9090/index_notfound.html   同样的道理先匹配 location / {} ，但属于“普通 location 的最大前缀匹配”，于是后面被“正则 location ” location ~ .html$ {} 覆盖了，最终 allow all ； 但的确目录下不存在index_notfound.html 页面，于是 404 Not Found 。</p>
<p>如果此时我们访问 http://localhost:9090/index.txt 会是什么结果呢？显然是 deny all ；因为先匹配上了 location / {..deny all;} 尽管属于“普通 location ”的最大前缀匹配结果，继续搜索正则 location ，但是 /index.txt 不是以 .html结尾的，正则 location 失败，最终采纳普通 location 的最大前缀匹配结果，于是 deny all 了。</p>
<p>[root@web108 ~]# curl http://localhost:9090/index.txt</p>
<html>
<head><title>403 Forbidden</title></head>
<body bgcolor=”white”>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>#2 普通 location 的“隐式”严格匹配<br>
例题 2 ：我们在例题 1 的基础上增加精确配置</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

              location / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>测试请求：</p>
<p>[root@web108 ~]# curl http://localhost:9090/exact/match.html</p>
<html>
<head><title>404 Not Found</title></head>
<body bgcolor=”white”>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>结果进一步验证了“普通 location ”的“严格精确”匹配会终止对正则 location 的搜索。这里我们小结下“普通 location”与“正则 location ”的匹配规则：先匹配普通 location ，再匹配正则 location ，但是如果普通 location 的匹配结果恰好是“严格精确（ exact match ）”的，则 nginx 不再尝试后面的正则 location ；如果普通 location 的匹配结果是“最大前缀”，则正则 location 的匹配覆盖普通 location 的匹配。也就是前面说的“正则 location 让步普通location 的严格精确匹配结果，但覆盖普通 location 的最大前缀匹配结果”。</p>
<p>#3 普通 location 的“显式”严格匹配和“ ^~ ” 前缀<br>
上面我们演示的普通 location 都是不加任何前缀的，其实普通 location 也可以加前缀：“ ^~ ”和“ = ”。其中“ ^~”的意思是“非正则，不需要继续正则匹配”，也就是通常我们的普通 location ，还会继续搜索正则 location （恰好严格精确匹配除外），但是 nginx 很人性化允许配置人员告诉 nginx 某条普通 location ，无论最大前缀匹配，还是严格精确匹配都终止继续搜索正则 location ；而“ = ”则表达的是普通 location 不允许“最大前缀”匹配结果，必须严格等于，严格精确匹配。</p>
<p>例题 3 ：“ ^~ ”前缀的使用</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

             location ^~ / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>把例题 2 中的 location / {} 修改成 location ^~ / {} ，再看看测试结果：</p>
<p>URI 请求	修改前	修改后<br>
curl http://localhost:9090/	403 Forbidden	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!	403 Forbidden<br>
curl http://localhost:9090/index_notfound.html	404 Not Found	403 Forbidden<br>
curl http://localhost:9090/exact/match.html	404 Not Found	404 Not Found<br>
除了 GET /exact/match.html 是 404 Not Found ，其余都是 403 Forbidden ，原因很简单所有请求都是以“ / ”开头，所以所有请求都能匹配上“ / ”普通 location ，但普通 location 的匹配原则是“最大前缀”，所以只有/exact/match.html 匹配到 location /exact/match.html {allow all;} ，其余都 location ^~ / {deny all;} 并终止正则搜索。</p>
<p>例题 4 ：“ = ”前缀的使用</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

             location = / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>例题 4 相对例题 2 把 location / {} 修改成了 location = / {} ，再次测试结果：</p>
<p>URI 请求	修改前	修改后<br>
curl http://localhost:9090/	403 Forbidden	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!	Welcome to nginx!<br>
curl http://localhost:9090/index_notfound.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/exact/match.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/test.jsp	403 Forbidden	404 Not Found<br>
最能说明问题的测试是 GET /test.jsp ，实际上 /test.jsp 没有匹配正则 location （ location ~.html$ ），也没有匹配 location = / {} ，如果按照 location / {} 的话，会“最大前缀”匹配到普通 location / {} ，结果是 deny all 。</p>
<p>#4 正则 location 与编辑顺序<br>
location 的指令与编辑顺序无关，这句话不全对。对于普通 location 指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀“ ^~ ”或“ = ”（符号“ = ”只能严格匹配，不能前缀匹配），则停止搜索正则 location ；但对于正则 location 的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</p>
<p>配置 3.1</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

   location ~ \.html$ {

       allow all; 

   } 

   location ~ ^/prefix/.*\.html$ {

       deny all; 

   } 
</code></pre>
<p>}</p>
<p>配置 3.2</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

 

   location ~ ^/prefix/.*\.html$ {

       deny all; 

   } 

             

              location ~ \.html$ {

       allow all; 

   } 
</code></pre>
<p>}</p>
<p>测试结果：</p>
<p>URI 请求	配置 3.1	配置 3.2<br>
curl http://localhost:9090/regextest.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/prefix/regextest.html	404 Not Found	403 Forbidden<br>
解释：</p>
<p>Location ~ ^/prefix/.*.html$ {deny all;} 表示正则 location 对于以 /prefix/ 开头， .html 结尾的所有 URI 请求，都拒绝访问；   location ~.html<span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\.&#039; in math mode at position 71: …实际上，prefix 的是 ~\̲.̲html'>{allow all;} 表示正则 location 对于以 .html 结尾的 URI 请求，都允许访问。 实际上，prefix 的是 ~\.html</span> 的子集。</p>
<p>在“配置 3.1 ”下，两个请求都匹配上 location ~.html$ {allow all;} ，并且停止后面的搜索，于是都允许访问， 404 Not Found ；在“配置 3.2 ”下， /regextest.html 无法匹配 prefix ，于是继续搜索 ~.html$ ，允许访问，于是 404 Not Found ；然而 /prefix/regextest.html 匹配到 prefix ，于是 deny all ， 403 Forbidden 。</p>
<p>配置 3.3</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

   location  /prefix/ {

           deny all; 

   } 

     

   location  /prefix/mid/ {

           allow all; 

   } 
</code></pre>
<p>}</p>
<p>配置 3.4</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

 

   location  /prefix/mid/ {

           allow all; 

   } 

              location  /prefix/ {

           deny all; 

   } 
</code></pre>
<p>}</p>
<p>测试结果：</p>
<p>URI 请求	配置 3.1	配置 3.2<br>
curl http://localhost:9090/prefix/t.html	  403 Forbidden    	403 Forbidden<br>
curl http://localhost:9090/prefix/mid/t.html	404 Not Found	404 Not Found<br>
测试结果表明：普通 location 的匹配规则是“最大前缀”匹配，而且与编辑顺序无关。</p>
<p>#5 “@” 前缀 Named Location 使用<br>
REFER:  http://wiki.nginx.org/HttpCoreModule#error_page</p>
<p>假设配置如下：</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

    location  / {

       root   html;

       index  index.html index.htm;

       allow all;

   }

   #error_page 404 http://www.baidu.com # 直接这样是不允许的

   error_page 404 = @fallback;

   location @fallback {

       proxy_pass http://www.baidu.com;

   }
</code></pre>
<p>}</p>
<p>上述配置文件的意思是：如果请求的 URI 存在，则本 nginx 返回对应的页面；如果不存在，则把请求代理到baidu.com 上去做个弥补（注： nginx 当发现 URI 对应的页面不存在， HTTP_StatusCode 会是 404 ，此时error_page 404 指令能捕获它）。</p>
<p>测试一：</p>
<p>[root@web108 ~]# curl http://localhost:9090/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:17:21 GMT</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<p>Location: http://localhost:9090/search/error.html</p>
<p>Connection: keep-alive</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:17:21 GMT</p>
<p>Content-Length: 222</p>
<!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href=”http://www.baidu.com/search/error.html”>here</a>.</p>
</body></html>
<p>[root@web108 ~]#</p>
<p>当我们 GET /nofound.html 发送给本 nginx ， nginx 找不到对应的页面，于是 error_page 404 = @fallback ，请求被代理到 http://www.baidu.com ，于是 nginx 给 http://www.baidu.com 发送了 GET /nofound.html ，但/nofound.html 页面在百度也不存在，百度 302 跳转到错误页。</p>
<p>直接访问 http://www.baidu.com/nofound.html 结果：</p>
<p>[root@web108 ~]# curl http://www.baidu.com/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Date: Sat, 06 Aug 2011 08:20:05 GMT</p>
<p>Server: Apache</p>
<p>Location: http://www.baidu.com/search/error.html</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:20:05 GMT</p>
<p>Content-Length: 222</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href=”http://www.baidu.com/search/error.html”>here</a>.</p>
</body></html>
<p>[root@web108 ~]#</p>
<p>测试二：访问一个 nginx 不存在，但 baidu 存在的页面</p>
<p>[root@web108 ~]# curl http://www.baidu.com/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Date: Sat, 06 Aug 2011 08:21:56 GMT</p>
<p>Server: Apache</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A0C88CA7075A6601A:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A2337F78F909CCB90:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: “d66-49913b8efe340″</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:21:56 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html</p>
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”

“http://www.w3.org/TR/html4/loose.dtd”>
<p>。。。。</p>
</body>
</html>
<p>显示，的确百度这个页面是存在的。</p>
<p>[root@web108 ~]# curl http://localhost:9090/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:23:23 GMT</p>
<p>Content-Type: text/html</p>
<p>Connection: keep-alive</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277DCB4CC5F80B7F457:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277B1F87691AFFD7440:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: “d66-49913b8efe340″</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:23:23 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”

“http://www.w3.org/TR/html4/loose.dtd”>
<html>
<p>。。。</p>
</body>
</html>
<p>当 curl http://localhost:9090/duty/ -i 时， nginx 没找到对应的页面，于是 error_page = @fallback ，把请求代理到 baidu.com 。注意这里的 error_page = @fallback 不是靠重定向实现的，而是所说的“ internally redirected （forward ）”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx七层负载均衡的几种调度算法]]></title>
        <id>https://newdy.cf/post/nginx-qi-ceng-fu-zai-jun-heng-de-ji-chong-diao-du-suan-fa/</id>
        <link href="https://newdy.cf/post/nginx-qi-ceng-fu-zai-jun-heng-de-ji-chong-diao-du-suan-fa/">
        </link>
        <updated>2020-02-19T04:44:25.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx是一款轻量级的高性能web服务器，同时也是一款非常优秀的负载均衡器和反向代理服务器。由于支持强大的正则匹配规则、动静分离、URLrewrite功能及安装配置简单且对网络稳定性依赖非常小等优点，所以常用来做为七层负载均衡使用。在硬件不差的情况下，通常可以稳定支持几万的并发连接，在硬件性能足够好，且对系统内核参数及Nginx配置进行优化甚至可以达到10万以上的并发。</p>
<p>以下是Nginx作为七层负载均衡常用的几种调度算法和适用的业务场景</p>
<p>1、轮询（默认调度算法）</p>
<p>特点：每个请求按时间顺序逐一分配到不同的后端服务器处理。<br>
适用业务场景：后端服务器硬件性能配置完全一致，业务无特殊要求时使用。<br>
upstream backendserver {<br>
server 192.168.0.14：80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15：80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>2、加权轮询</p>
<p>特点：指定轮询几率，weight值(权重)和访问比例成正比，用户请求按权重比例分配。<br>
适用业务场景：用于后端服务器硬件性处理能力不平均的情形。<br>
upstream backendserver {<br>
server 192.168.0.14:80 weight=5 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 weight=10 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>3、ip_hash</p>
<p>特点：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session会话保持问题。<br>
适用业务场景：适用于需要账号登录的系统，会话连接保持的业务。<br>
upstream backendserver {<br>
ip_hash;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>4、最少连接数 least_conn</p>
<p>特点：按nginx反向代理与后端服务器之间的连接数，连接数最少的优先分配。</p>
<p>适用业务场景：适用于客户端与后端服务器需要保持长连接的业务。<br>
upstream backendserver {<br>
least_conn;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>5、fair（需编译安装第三方模块 ngx_http_upstream_fair_module）</p>
<p>特点：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>
适用业务场景：对访问响应速度有一定要求的业务。<br>
upstream backendserver {<br>
fair;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>6、url_hash（需编译安装第三方模块 ngx_http_upstream_hash_module）</p>
<p>特点：按访问url的hash结果来分配请求，使同一个url访问到同一个后端服务器。<br>
适用业务场景：适用于后端服务器为缓存服务器时比较有效。<br>
upstream backendserver {<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
hash $request_uri;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux CentOS 7 非root用户安装源码版Docker]]></title>
        <id>https://newdy.cf/post/linux-centos-7-fei-root-yong-hu-an-zhuang-yuan-ma-ban-docker/</id>
        <link href="https://newdy.cf/post/linux-centos-7-fei-root-yong-hu-an-zhuang-yuan-ma-ban-docker/">
        </link>
        <updated>2020-02-19T04:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>注意:非root用户必须要有sudo权限</p>
<p>一、安装前的准备</p>
<p>1.查看当前主机是否有docker组</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582087080673.png" alt="" loading="lazy"></figure>
<p>若没有输出结果则新建</p>
<figure data-type="image" tabindex="2"><img src="https://newdy.cf/post-images/1582087086554.png" alt="" loading="lazy"></figure>
<p>再次查看,发现已经有了docker组</p>
<figure data-type="image" tabindex="3"><img src="https://newdy.cf/post-images/1582087091705.png" alt="" loading="lazy"></figure>
<p>2.新增拥有sudo权限的用户(若知道root和其他拥有sudo权限的系统用户密码,跳到3;若都没有,必做)</p>
<figure data-type="image" tabindex="4"><img src="https://newdy.cf/post-images/1582087133234.png" alt="" loading="lazy"></figure>
<p>修改该用户的密码<br>
<img src="https://newdy.cf/post-images/1582087138797.png" alt="" loading="lazy"></p>
<p>为新增的用户添加sudo权限</p>
<p>sudo vi /etc/sudoers<br>
　　在92行下一行添加<br>
　　test    　　ALL=(ALL)    　　ALL<br>
3.把当前用户加入到docker组 （此时用户并没有加入进docker组）</p>
<figure data-type="image" tabindex="5"><img src="https://newdy.cf/post-images/1582087165679.png" alt="" loading="lazy"></figure>
<p>切换至sudo权限用户，然后再切换回当前用户（此时可以看到用户已经加入docker组）</p>
<figure data-type="image" tabindex="6"><img src="https://newdy.cf/post-images/1582087175735.png" alt="" loading="lazy"></figure>
<p>3.删除新增的用户和它的sudo权限（第2步没做请忽略此步）</p>
<p>sudo vi /etc/sudoers<br>
　　在92行下一行添加<br>
　　test　　ALL=(ALL)  ALL<br>
两次退出，不然删除用户时会报错</p>
<figure data-type="image" tabindex="7"><img src="https://newdy.cf/post-images/1582087195961.png" alt="" loading="lazy"></figure>
<p>二、安装docker</p>
<p>1.下载docker源码包并上传至虚拟机</p>
<p>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz</p>
<p>2.解压源码包至指定目录下</p>
<figure data-type="image" tabindex="8"><img src="https://newdy.cf/post-images/1582087215827.png" alt="" loading="lazy"></figure>
<p>3.将解压出来的docker目录下的指令复制到 /usr/bin/ 目录下</p>
<p>sudo cp docker/* /usr/bin/<br>
4./usr/bin/目录下docker有关指令的所属用户和所属组(必做,不然非root用户使用docker指令报错:权限不够)</p>
<p>sudo chown root:docker /usr/bin/docker*<br>
sudo chown root:docker /usr/bin/containerd*<br>
sudo chown root:docker /usr/bin/runc<br>
sudo chown root:docker /usr/bin/ctr<br>
5.查看一下是否改变所属用户和所属组(得到和解压出来的docker目录下的一样的8个指令)</p>
<figure data-type="image" tabindex="9"><img src="https://newdy.cf/post-images/1582087235444.png" alt="" loading="lazy"></figure>
<p>6.将docker注册为service服务</p>
<p>新建该文件<br>
sudo vi /etc/systemd/system/docker.service<br>
加入以下内容：<br>
[Unit]<br>
Description=Docker Application Container Engine<br>
Documentation=https://docs.docker.com<br>
After=network-online.target firewalld.service<br>
Wants=network-online.target</p>
<p>[Service]<br>
Type=notify<br>
ExecStart=/usr/bin/dockerd<br>
ExecReload=/bin/kill -s HUP $MAINPID<br>
LimitNOFILE=infinity<br>
LimitNPROC=infinity<br>
LimitCORE=infinity<br>
TimeoutStartSec=0<br>
Delegate=yes<br>
KillMode=process<br>
Restart=on-failure<br>
StartLimitBurst=3<br>
StartLimitInterval=60s</p>
<p>[Install]<br>
WantedBy=multi-user.target<br>
7.添加执行权限并重新加载配置文件</p>
<p>sudo chmod a+x /etc/systemd/system/docker.service<br>
sudo systemctl daemon-reloa<br>
8.docker镜像加速(可以不做,但是docker pull会很慢,由于docker官网在海外)</p>
<p>新建该文件<br>
sudo vi /etc/docker/daemon.json<br>
加入以下内容<br>
{<br>
&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]<br>
}</p>
<p>9.启动docker</p>
<p>sudo systemctl start docker<br>
三、docker基础命令</p>
<p>docker启/停/重启/查看状态<br>
sudo systemctl  start/stop/restart/status</p>
<p>查看docker已有镜像<br>
docker images</p>
<p>在docker官网搜寻指定镜像<br>
docker search 镜像</p>
<p>下载镜像(不加标签默认下载最新版本的镜像)<br>
docker pull 镜像名字:tag(即标签)</p>
<p>启动容器(以xxx名字运行基于镜像的容器，并映射容器端口到本机端口，容器目录文件储存在本机目录)<br>
docker run -d -name xxx -p 本机端口:容器端口 -v 本机目录:容器目录 镜像name:tag(或ID)</p>
<p>进入正在运行的容器内部<br>
docker exec -it 容器name(或ID) /bin/bash</p>
<p>容器的启/停/重启/信息/删除<br>
docker start/stop/restart/inspect/rm 容器name(或ID)</p>
<p>查看正在运行的容器<br>
docker ps</p>
<p>查看所有容器(包括正在运行的、停止的,不包括删除的)<br>
docker ps -a</p>
<p>镜像的删除(删除镜像前请删除所有与该镜像有关的容器)<br>
docker rmi 镜像name:tag(或ID)</p>
<p>查看当前安装的docker有关信息<br>
docker info<br>
dd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows10下nginx的rtmp服务器搭建]]></title>
        <id>https://newdy.cf/post/windows10-xia-nginx-de-rtmp-fu-wu-qi-da-jian/</id>
        <link href="https://newdy.cf/post/windows10-xia-nginx-de-rtmp-fu-wu-qi-da-jian/">
        </link>
        <updated>2020-02-19T04:28:12.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>下载 nginx 1.7.11.3 Gryphon<br>
    下载链接: http://nginx-win.ecsds.eu/download/nginx 1.7.11.3 Gryphon.zip，下载完成后解压， 将解压后的目录命名为</li>
</ol>
<p>nginx-1.7.11.3-Gryphon<br>
2. 下载服务器状态检查程序 stat.xsl（注：直接clone到nginx-1.7.11.3-Gryphon目录下）</p>
<p>下载地址https://github.com/arut/nginx-rtmp-module/</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582086527036.png" alt="" loading="lazy"></figure>
<ol>
<li>配置文件 conf\nginx-win-rtmp.conf 内容如下:（注：用记事本打开直接复制粘贴，避免编码格式引起错误）</li>
</ol>
<p>#user  nobody;</p>
<h1 id="multiple-workers-works">multiple workers works !</h1>
<p>worker_processes  2;</p>
<p>#error_log  logs/error.log;<br>
#error_log  logs/error.log  notice;<br>
#error_log  logs/error.log  info;</p>
<p>#pid        logs/nginx.pid;</p>
<p>events {<br>
worker_connections  8192;<br>
# max value 32768, nginx recycling connections+registry optimization =<br>
#   this.value * 20 = max concurrent connections currently tested with one worker<br>
#   C1000K should be possible depending there is enough ram/cpu power<br>
# multi_accept on;<br>
}</p>
<p>rtmp {<br>
server {<br>
listen 1935;<br>
chunk_size 4000;<br>
application live {<br>
live on;</p>
<pre><code>         # record first 1K of stream
         record all;
         record_path /tmp/av;
         record_max_size 1K;

         # append current timestamp to each flv
         record_unique on;

         # publish only from localhost
         allow publish 127.0.0.1;
         deny publish all;

         #allow play all;
    }
}
</code></pre>
<p>}</p>
<p>http {<br>
#include      /nginx/conf/naxsi_core.rules;<br>
include       mime.types;<br>
default_type  application/octet-stream;</p>
<pre><code>#log_format  main  '$remote_addr:$remote_port - $remote_user [$time_local] &quot;$request&quot; '
#                  '$status $body_bytes_sent &quot;$http_referer&quot; '
#                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

#access_log  logs/access.log  main;
</code></pre>
<h1 id="loadbalancing-php"># loadbalancing PHP</h1>
<h1 id="upstream-myloadbalancer">upstream myLoadBalancer {</h1>
<h1 id="server-1270019001-weight1-fail_timeout5">server 127.0.0.1:9001 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019002-weight1-fail_timeout5">server 127.0.0.1:9002 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019003-weight1-fail_timeout5">server 127.0.0.1:9003 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019004-weight1-fail_timeout5">server 127.0.0.1:9004 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019005-weight1-fail_timeout5">server 127.0.0.1:9005 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019006-weight1-fail_timeout5">server 127.0.0.1:9006 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019007-weight1-fail_timeout5">server 127.0.0.1:9007 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019008-weight1-fail_timeout5">server 127.0.0.1:9008 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019009-weight1-fail_timeout5">server 127.0.0.1:9009 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019010-weight1-fail_timeout5">server 127.0.0.1:9010 weight=1 fail_timeout=5;</h1>
<h1 id="least_conn">least_conn;</h1>
<h1 id="">}</h1>
<pre><code>sendfile        off;
#tcp_nopush     on;

server_names_hash_bucket_size 128;
</code></pre>
<h2 id="start-timeouts">Start: Timeouts</h2>
<pre><code>client_body_timeout   10;
client_header_timeout 10;
keepalive_timeout     30;
send_timeout          10;
keepalive_requests    10;
</code></pre>
<h2 id="end-timeouts">End: Timeouts</h2>
<pre><code>#gzip  on;

server {
    listen       80;
    server_name  localhost;


    location /stat {
        rtmp_stat all;
        rtmp_stat_stylesheet stat.xsl;
    }
    location /stat.xsl {
        root nginx-rtmp-module/;
    }
    location /control {
        rtmp_control all;
    }

    #charset koi8-r;
    #access_log  logs/host.access.log  main;

    ## Caching Static Files, put before first location
    #location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
    #    expires 14d;
    #    add_header Vary Accept-Encoding;
    #}
</code></pre>
<h1 id="for-naxsi-remove-the-single-line-for-learn-mode-or-the-lines-for-full-waf-mode">For Naxsi remove the single # line for learn mode, or the ## lines for full WAF mode</h1>
<pre><code>    location / {
        #include    /nginx/conf/mysite.rules; # see also http block naxsi include line
        ##SecRulesEnabled;
     ##DeniedUrl &quot;/RequestDenied&quot;;
     ##CheckRule &quot;$SQL &gt;= 8&quot; BLOCK;
     ##CheckRule &quot;$RFI &gt;= 8&quot; BLOCK;
     ##CheckRule &quot;$TRAVERSAL &gt;= 4&quot; BLOCK;
     ##CheckRule &quot;$XSS &gt;= 8&quot; BLOCK;
        root   html;
        index  index.html index.htm;
    }
</code></pre>
<h1 id="for-naxsi-remove-the-lines-for-full-waf-mode-redirect-location-block-used-by-naxsi">For Naxsi remove the ## lines for full WAF mode, redirect location block used by naxsi</h1>
<pre><code>    ##location /RequestDenied {
    ##    return 412;
    ##}
</code></pre>
<h2 id="lua-examples">Lua examples !</h2>
<h1 id="location-robotstxt">location /robots.txt {</h1>
<h1 id="rewrite_by_lua">rewrite_by_lua '</h1>
<h1 id="if-ngxvarhttp_host-~-localhost-then">if ngx.var.http_host ~= &quot;localhost&quot; then</h1>
<h1 id="return-ngxexecrobots_disallowtxt">return ngx.exec(&quot;/robots_disallow.txt&quot;);</h1>
<h1 id="end">end</h1>
<h1 id="-2">';</h1>
<h1 id="-3">}</h1>
<pre><code>    #error_page  404              /404.html;
    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}
    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000; # single backend process
    #    fastcgi_pass   myLoadBalancer; # or multiple, see example above
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    #    include        fastcgi_params;
    #}
    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
# another virtual host using mix of IP-, name-, and port-based configuration
#
#server {
#    listen       8000;
#    listen       somename:8080;
#    server_name  somename  alias  another.alias;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
# HTTPS server
#
#server {
#    listen       443 ssl spdy;
#    server_name  localhost;
#    ssl                  on;
#    ssl_certificate      cert.pem;
#    ssl_certificate_key  cert.key;
#    ssl_session_timeout  5m;
#    ssl_prefer_server_ciphers On;
#    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
#    ssl_ciphers ECDH+AESGCM:ECDH+AES256:ECDH+AES128:ECDH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!eNULL:!MD5:!DSS:!EXP:!ADH:!LOW:!MEDIUM;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
</code></pre>
<p>}<br>
4. 启动服务器</p>
<p>nginx.exe -c conf\nginx-win-rtmp.conf<br>
5.使用ffmpeg、ffplay进行推流拉流验证（直接ffmpeg官方下载windows下的可执行文件）</p>
<p>5.1推流测试，使用ffmpeg命令完成即可</p>
<p>ffmpeg.exe -re -i inputfile.mp4 -vcodec libx264 -acodec aac -f flv rtmp://localhost:1935/live/home<br>
5.2拉流测试，使用ffplay命令完成即可<br>
—————————————<br>
ffplay.exe rtmp://localhost:1935/live/home<br>
<img src="https://newdy.cf/post-images/1582086643460.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx-rtmp+ FFmpeg +Docker + vue.js 直播系统搭建]]></title>
        <id>https://newdy.cf/post/nginx-rtmp-ffmpeg-docker-vuejs-zhi-bo-xi-tong-da-jian/</id>
        <link href="https://newdy.cf/post/nginx-rtmp-ffmpeg-docker-vuejs-zhi-bo-xi-tong-da-jian/">
        </link>
        <updated>2020-02-19T04:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>思路（如图）：<br>
<img src="https://newdy.cf/post-images/1582086243575.jpg" alt="" loading="lazy"><br>
1，开启推流服务器（这里我的Nginx-rtmp服务器搭建成功）</p>
<p>进入docker 开启推流服务器  docker run -it -p 1935:1935 -p 8000:80 --rm alfg/nginx-rtmp</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582086272172.jpg" alt="" loading="lazy"></figure>
<p>2，推流（两种方法）</p>
<p>命令推流：</p>
<p>查看本机摄像头及麦克风设备 ffmpeg -list_devices true -f dshow -i dummy</p>
<p>音视频推流： ffmpeg -f dshow -i video=&quot;VMware Virtual USB Video Device&quot;:audio=&quot;Microphone (High Definition Audio Device)&quot; -tune:v zerolatency -f flv &quot;rtmp://192.168.99.100:1935/stream/test&quot;</p>
<p>#推流视频文件<br>
ffmpeg -re -stream_loop -1 -i test.mp4 -f flv rtmp://192.168.99.100:1935/stream/test<br>
播放地址http://192.168.99.100:8000/live/test.m3u8</p>
<p>#将摄像头推流到hls<br>
ffmpeg -f vfwcap  -i &quot;0&quot; -c:v libx264 -preset ultrafast  -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1935/hls/home<br>
播放地址http://localhost:8080/hls/home.m3u8</p>
<p>#将屏幕推流到rtmp<br>
start ffmpeg -f gdigrab -i desktop -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv<br>
播放地址rtmp://localhost:1935/live/jing<br>
使用第三方软件推流：（例如：OBS Studio）</p>
<p>3，拉流</p>
<p>这里前端使用的是通过VUE</p>
<p>注意使用video需安装以下几个依赖</p>
<p>cnpm install video.js<br>
cnpm install aes-decrypter<br>
cnpm install m3u8-parser<br>
cnpm install mpd-parser<br>
cnpm install mux.js<br>
cnpm install url-toolkit<br>
cnpm install videojs-contrib-hls</p>
<video id="my-video" class="video-js vjs-default-skin" controls preload="auto" >
                                        <source src="http://192.168.99.100:8000/live/test.m3u8" type="application/x-mpegURL">
                                </video>
<script>
        //vue 的video插件
            import videojs from 'video.js'
            import 'videojs-contrib-hls'

    export default {
    mounted:function(){
                    //自动执行直播平台
                    videojs('my-video', {
                    bigPlayButton: false,
                    textTrackDisplay: false,
                    posterImage: true,
                    errorDisplay: false,
                    controlBar: true
            }, function () {
                    this.play()
            })
        }
    }
}



</script>
<p>效果如下：<br>
<img src="https://newdy.cf/post-images/1582086327475.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>