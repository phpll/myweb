<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newdy.cf</id>
    <title>Gridea</title>
    <updated>2020-02-19T09:38:38.802Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newdy.cf"/>
    <link rel="self" href="https://newdy.cf/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://newdy.cf/images/avatar.png</logo>
    <icon>https://newdy.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[黑群晖通过frps，实现quick connect功能]]></title>
        <id>https://newdy.cf/post/hei-qun-hui-tong-guo-frpsshi-xian-quick-connect-gong-neng/</id>
        <link href="https://newdy.cf/post/hei-qun-hui-tong-guo-frpsshi-xian-quick-connect-gong-neng/">
        </link>
        <updated>2020-02-19T08:35:45.000Z</updated>
        <content type="html"><![CDATA[<p>一、申请免费的vps：https://cloud.google.com/free/</p>
<p>二、申请完vps后， 安装frps服务端：</p>
<p>第一步：</p>
<p>1、获取root 权限<br>
sudo su -<br>
2、#安装git客户端<br>
yum install -y git<br>
3、获取一键安装frps脚本<br>
git clone https://github.com/clangcn/onekey-install-shell.git<br>
4、进去frps目录安装<br>
cd onekey-install-shell/frps<br>
sh version.sh<br>
sh install-frps.sh install</p>
<p>然后选择2，就可以一直往下按回车</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582101396279.jpg" alt="" loading="lazy"></figure>
<p>安装完后，会看到相关的账户密码信息，请记录下来。</p>
<p>第二步：</p>
<p>开通vps上的防火墙，在vpc网络–&gt; 防火墙策略下新建一条防火墙，放开所有端口和所有来源ip（假如要安全的话，按需开通端口）,如下图</p>
<figure data-type="image" tabindex="2"><img src="https://newdy.cf/post-images/1582101413068.jpg" alt="" loading="lazy"></figure>
<p>第三步：</p>
<p>启动frps</p>
<p>frps start</p>
<p>三、申请域名</p>
<p>1、在godaddy网站：https://www.godaddy.com/， 申请一级域名，如： nayfeng.com</p>
<p>2、新建一条A记录指向刚才新建vps的外网ip，如nas。那么我们访问nas.nafeng.com，就是指向刚才新建的vps上</p>
<p>四、在vps上配置frps 服务端</p>
<p>1、进入fprs的配置模式<br>
frps config<br>
2、新增配置信息，在配置文件最下面，新增subdomain_host = nayfeng.com，然后按esc，:，x 来保存配置信息</p>
<p>3、重启fprs服务使其生效<br>
frps restart<br>
如下图所示的配置信息，</p>
<figure data-type="image" tabindex="3"><img src="https://newdy.cf/post-images/1582101434713.jpg" alt="" loading="lazy"></figure>
<p>五、在群晖nas上配置frp 客户端</p>
<p>1、通过security crt 或者xshell的客户端，远程登录我们的nas</p>
<p>2、下载frps客户端 wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz<br>
3、解压<br>
tar zxvf frp_0.21.0_linux_amd64.tar.gz<br>
4、修改配置文件<br>
cd frp_0.20.0_linux_amd64<br>
vi frpc.ini</p>
<p>frpc.ini的参考配置信息如下，只要把我们的中文说明的两行根据实际情况填写就可以了，部分人发现配置文件有异常的话，请把中文的备注信息删除：</p>
<p>[common]<br>
server_addr = 1.1.1.1   #用个人vps公网ip代替<br>
server_port = 5443<br>
token = tian-xie-token    #填写自己vps上frps的token配置代替</p>
<p>admin_addr = 127.0.0.1<br>
admin_port = 7001<br>
admin_user = admin<br>
admin_pwd = admin</p>
<p>[ssh]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 22<br>
remote_port = 6000</p>
<p>[plex]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 32400<br>
remote_port = 32400</p>
<p>[nas_5000]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 5000<br>
remote_port = 5000</p>
<p>[nas_5001]<br>
type = tcp<br>
local_ip = 127.0.0.1<br>
local_port = 5001<br>
remote_port = 5001</p>
<p>[nas_web]<br>
type = http<br>
local_ip = 127.0.0.1<br>
local_port = 5000<br>
subdomain = nas</p>
<p>[nas_webs]<br>
type = https<br>
local_ip = 127.0.0.1<br>
local_port = 5001<br>
subdomain = nas<br>
5、启动frpc 客户端服务</p>
<p>nohup ./frpc -c frpc.ini &amp;<br>
在此你就可以在外网连你家的黑群晖了。</p>
<p>六、使其更完美。</p>
<p>1、在黑群晖上装一个dns server套件</p>
<p>2、在dns server 上添加刚申请的域名，并新建一条A记录，指向我们家里的nas ip</p>
<p>3、在路由器上设置分配dns server 的ip  为我们nas 存储的ip</p>
<p>4、黑群晖开机启动frps</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx SSL 双向认证]]></title>
        <id>https://newdy.cf/post/nginx-ssl-shuang-xiang-ren-zheng/</id>
        <link href="https://newdy.cf/post/nginx-ssl-shuang-xiang-ren-zheng/">
        </link>
        <updated>2020-02-19T08:34:51.000Z</updated>
        <content type="html"><![CDATA[<p>安装Nginx和OpenSSL</p>
<p>yum install nginx openssl -y<br>
SSL 服务器 / 客户端双向验证证书的生成<br>
创建一个新的 CA 根证书，在 nginx 安装目录下新建 ca 文件夹，进入 ca，创建几个子文件夹</p>
<p>$ mkdir ca &amp;&amp; cd ca<br>
$ mkdir newcerts private conf server</p>
<h1 id="newcerts-子目录将用于存放-ca-签署过的数字证书证书备份目录private-用于存放-ca-的私钥conf-目录用于存放一些简化参数用的配置文件server-存放服务器证书文件">newcerts 子目录将用于存放 CA 签署过的数字证书(证书备份目录)；private 用于存放 CA 的私钥；conf 目录用于存放一些简化参数用的配置文件；server 存放服务器证书文件。</h1>
<p>conf 目录新建 openssl.conf 文件</p>
<p>[ ca ]<br>
default_ca      = foo                   # The default ca section</p>
<p>[ foo ]<br>
dir            = ./         # top dir<br>
database       = ./index.txt          # index file.<br>
new_certs_dir  = ./newcerts           # new certs dir</p>
<p>certificate    = ./private/ca.crt         # The CA cert<br>
serial         = ./serial             # serial no file<br>
private_key    = ./private/ca.key  # CA private key<br>
RANDFILE       = ./private/.rand      # random number file</p>
<p>default_days   = 3650                     # how long to certify for<br>
default_crl_days= 30                     # how long before next CRL<br>
default_md     = sha256                     # message digest method to use<br>
unique_subject = no                      # Set to 'no' to allow creation of<br>
# several ctificates with same subject.<br>
policy         = policy_any              # default policy</p>
<p>[ policy_any ]<br>
countryName = match<br>
stateOrProvinceName = match<br>
organizationName = match<br>
organizationalUnitName = match<br>
localityName            = optional<br>
commonName              = supplied<br>
emailAddress            = optional<br>
生成私钥 key 文件</p>
<p>$ openssl genrsa -out private/ca.key 2048<br>
输出<br>
Generating RSA private key, 2048 bit long modulus<br>
.......+++<br>
.........................+++<br>
e is 65537 (0x10001)<br>
private 目录下有 ca.key 文件生成。<br>
生成证书请求 csr 文件</p>
<p>$ openssl req -new -key private/ca.key -out private/ca.csr<br>
生成凭证 crt 文件</p>
<p>$ openssl x509 -req -days 365 -in private/ca.csr -signkey private/ca.key -out private/ca.crt<br>
private 目录下有 ca.crt 文件生成。<br>
为我们的 key 设置起始序列号和创建 CA 键库</p>
<p>$ echo FACE &gt; serial<br>
#可以是任意四个字符<br>
$ touch index.txt<br>
为 &quot;用户证书&quot; 的移除创建一个证书撤销列表</p>
<p>$ openssl ca -gencrl -out ./private/ca.crl -crldays 7 -config &quot;./conf/openssl.conf&quot;</p>
<h1 id="输出">输出</h1>
<p>Using configuration from ./conf/openssl.conf<br>
private 目录下有 ca.crl 文件生成。<br>
服务器证书的生成</p>
<p>创建一个 key</p>
<p>$ openssl genrsa -out server/server.key 2048<br>
为我们的 key 创建一个证书签名请求 csr 文件<br>
$ openssl req -new -key server/server.key -out server/server.csr<br>
使用我们私有的 CA key 为刚才的 key 签名<br>
$ openssl ca -in server/server.csr -cert private/ca.crt -keyfile private/ca.key -out     server/server.crt -config &quot;./conf/openssl.conf&quot;</p>
<h1 id="输出-2">输出</h1>
<p>Using configuration from ./conf/openssl.conf<br>
Check that the request matches the signature<br>
Signature ok<br>
The Subject's Distinguished Name is as follows<br>
countryName           :PRINTABLE:'CN'<br>
stateOrProvinceName   :ASN.1 12:'GuangDong'<br>
localityName          :ASN.1 12:'XX'<br>
organizationName      :ASN.1 12:'<strong><strong>'<br>
organizationalUnitName:ASN.1 12:'<strong>'<br>
commonName            :ASN.1 12:'</strong>'<br>
emailAddress          :IA5STRING:'</strong></strong>'<br>
Certificate is to be certified until Mar 19 07:37:02 2017 GMT (365 days)<br>
Sign the certificate? [y/n]:y</p>
<p>1 out of 1 certificate requests certified, commit? [y/n]y<br>
Write out database with 1 new entries<br>
Data Base Updated<br>
注：签名信息每次必须输入一致</p>
<p>客户端证书的生成 * 创建存放 key 的目录 users</p>
<p>$ mkdir users</p>
<ul>
<li>为用户创建一个 key</li>
</ul>
<p>$ openssl genrsa -des3 -out ./users/client.key 2048<br>
输出：<br>
Enter pass phrase for ./users/client.key:123<br>
Verifying - Enter pass phrase for ./users/client.key:123<br>
#要求输入 pass phrase，这个是当前 key 的口令，以防止本密钥泄漏后被人盗用。两次输入同一个密码(比如我这里输入     123)，users 目录下有 client.key 文件生成。<br>
为 key 创建一个证书签名请求 csr 文件<br>
$ openssl req -new -key ./users/client.key -out ./users/client.csr<br>
#users 目录下有 client.csr 文件生成。<br>
使用我们私有的 CA key 为刚才的 key 签名</p>
<p>$ openssl ca -in ./users/client.csr -cert ./private/ca.crt -keyfile ./private/ca.key -out    ./users/client.crt -config &quot;./conf/openssl.conf&quot;<br>
将证书转换为大多数浏览器都能识别的 PKCS12 文件</p>
<p>$ openssl pkcs12 -export -clcerts -in ./users/client.crt -inkey ./users/client.key -out ./users/client.p12<br>
输出</p>
<p>Enter pass phrase for ./users/client.key:<br>
Enter Export Password:<br>
Verifying - Enter Export Password:<br>
输入密码后，users 目录下有 client.p12 文件生成。</p>
<p>Nginx配置<br>
vhosts.xxx.conf 在 server { }段输入如下代码</p>
<pre><code>listen       443; 
server_name  localhost; 
ssi on; 
ssi_silent_errors on; 
ssi_types text/shtml; 

ssl                  on; 
ssl_certificate      /usr/local/nginx/ca/server/server.crt; 
ssl_certificate_key  /usr/local/nginx/ca/server/server.key; 
ssl_client_certificate /usr/local/nginx/ca/private/ca.crt; 

ssl_session_timeout  5m; 
ssl_verify_client on;  #开户客户端证书验证 
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDH:AES:HIGH:!aNULL:!MD5:!ADH:!DH;


ssl_prefer_server_ciphers   on; 
</code></pre>
<p>重新启动Nginx</p>
<p>nginx -t<br>
nginx -s reload</p>
<p>作者：假装_很深沉<br>
链接：https://www.jianshu.com/p/40bfe7566254<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成Nginx服务器SSL证书和客户端证书]]></title>
        <id>https://newdy.cf/post/sheng-cheng-nginx-fu-wu-qi-ssl-zheng-shu-he-ke-hu-duan-zheng-shu/</id>
        <link href="https://newdy.cf/post/sheng-cheng-nginx-fu-wu-qi-ssl-zheng-shu-he-ke-hu-duan-zheng-shu/">
        </link>
        <updated>2020-02-19T04:54:59.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx服务器SSL证书<br>
生成pass key</p>
<p>下面的命令用于生成一个2048bit的pass key, -passout pass:111111 用于避免交互式输入密码</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:111111 -out server.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
...........+++<br>
.....................+++<br>
e is 65537 (0x10001)</p>
<p>生成key</p>
<p>下面的命令用于生成私钥, -passin pass:111111是和pass key的密码对应的, 用于避免交互式输入密码</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:111111 -in server.pass.key -out server.key<br>
writing RSA key</p>
<p>生成证书签发请求文件(CSR)</p>
<p>下面的命令用于生成csr文件, 这里需要填写机构相关信息. 其中CN务必填写为对应的服务器域名. 最后那个challenge password, 是这个csr的password</p>
<h2 id="tomcata02-tmp-openssl-req-new-sha256-key-serverkey-out-servercsryou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -sha256 -key server.key -out server.csr<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:iSomeone<br>
Common Name (eg, your name or your server's hostname) []:internal.someone.com<br>
Email Address []:</p>
<p>Please enter the following 'extra' attributes<br>
to be sent with your certificate request<br>
A challenge password []:222222<br>
An optional company name []:</p>
<p>发送CSR文件给CA服务商签发证书</p>
<p>如果是购买的CA服务商的SSL证书服务, 这一步把CSR发给服务商就可以了. 收到证书后将内容写入到 server.pem 文件</p>
<p>在Nginx上这样配置</p>
<p>server {<br>
listen      443;<br>
server_name  www.example.com;</p>
<pre><code>ssl                  on;
ssl_certificate      /path/to/ssl/server.pem;
ssl_certificate_key  /path/to/ssl/server.key;
ssl_protocols TLSv1.2 TLSv1.1 TLSv1;
ssl_session_cache shared:ssl_www_example_com:5m;
ssl_session_timeout  5m;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:DES-CBC3-SHA;
#...
location / {
    #...
}
#...
</code></pre>
<p>}</p>
<p>制作自签名证书</p>
<p>如果是打算制作自签名证书, 则进行如下的操作生成pem证书</p>
<p>[tomcat@a02 tmp]$ openssl x509 -req -sha256 -days 3655 -in server.csr -signkey server.key -out server.pem<br>
Signature ok<br>
subject=/C=CN/ST=Beijing/L=Chaoyang/O=HenSomeone/OU=iSomeone/CN=internal.someone.com<br>
Getting Private key</p>
<p>Nginx客户端验证证书<br>
Nginx客户端验证证书和服务端SSL证书其实是没关系的, 你可以一边使用CA签发的证书, 一边使用自己制作的客户端验证证书.</p>
<p>生成服务器端私钥</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:201906 -out ca.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
...............................................................................................................+++<br>
...................................+++<br>
e is 65537 (0x10001)</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:201906 -in ca.pass.key -out ca.key<br>
writing RSA key</p>
<p>生成服务器端证书</p>
<p>下面的命令会生成服务器证书ca.pem, 用于配制到nginx.</p>
<h2 id="tomcata02-tmp-openssl-req-new-x509-days-3655-key-cakey-out-capemyou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -x509 -days 3655 -key ca.key -out ca.pem<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:iSomeone<br>
Common Name (eg, your name or your server's hostname) []:internal.someone.com<br>
Email Address []:</p>
<p>生成客户端私钥</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:201906 -out client_01.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
..........................+++<br>
.....+++<br>
e is 65537 (0x10001)</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:201906 -in client_01.pass.key -out client_01.key<br>
writing RSA key</p>
<p>生成客户端证书签发请求CSR</p>
<h2 id="tomcata02-tmp-openssl-req-new-key-client_01key-out-client_01csryou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -key client_01.key -out client_01.csr<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:Staff<br>
Common Name (eg, your name or your server's hostname) []:Staff<br>
Email Address []:</p>
<p>Please enter the following 'extra' attributes<br>
to be sent with your certificate request<br>
A challenge password []:201907<br>
An optional company name []:</p>
<p>签发客户端证书</p>
<p>下面的命令, 用服务端的私钥和服务端的证书, 对客户端的CSR进行签发, 生成服务端证书. 这里有一个 -set_serial 01 的参数, 如果签发多个客户端证书, 这个数字不能重复</p>
<p>[tomcat@a02 tmp]$ openssl x509 -req -days 3655 -in client_01.csr -CA ca.pem -CAkey ca.key -set_serial 01 -out client_01.pem<br>
Signature ok<br>
subject=/C=CN/ST=Beijing/L=Chaoyang/O=HenSomeone/OU=Staff/CN=Staff<br>
Getting CA Private Key</p>
<p>客户端证书格式转换</p>
<p>前面生成的证书, 不能直接用于常见的应用, 需要转换成应用需要的格式</p>
<p>Full PEM:</p>
<p>[tomcat@a02 tmp]$ cat client_01.key client_01.pem ca.pem &gt; client_01.full.pem</p>
<p>PFX - 这里输入的export password, 就是应用导入PFX证书时需要输入的密码.</p>
<p>[tomcat@a02 tmp]$ openssl pkcs12 -export -out client_01.full.pfx -inkey client_01.key -in client_01.pem -certfile ca.pem<br>
Enter Export Password:<br>
Verifying - Enter Export Password:</p>
<p>配置Nginx的客户端验证证书</p>
<p>ssl_client_certificate /path/to/ca.pem;<br>
ssl_verify_client optional; # or <code>on</code> if you require client key</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx配置中location匹配规则详解]]></title>
        <id>https://newdy.cf/post/nginx-pei-zhi-zhong-location-pi-pei-gui-ze-xiang-jie/</id>
        <link href="https://newdy.cf/post/nginx-pei-zhi-zhong-location-pi-pei-gui-ze-xiang-jie/">
        </link>
        <updated>2020-02-19T04:48:02.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx 的语法形式是： location [=|<sub>|</sub><em>|^~|@] /uri/ { … } ，意思是可以以“ = ”或“ ~</em> ”或“ ~ ”或“ ^~ ”或“ @ ”符号为前缀，当然也可以没有前缀（因为 [A] 是表示可选的 A ； A|B 表示 A 和 B 选一个），紧接着是 /uri/ ，再接着是{…} 指令块，整个意思是对于满足这样条件的 /uri/ 适用指令块 {…} 的指令。</p>
<p>上述各种 location 可分两大类，分别是：“普通 location ”，官方英文说法是 location using   literal strings 和“正则 location ”，英文说法是 location using regular expressions 。其中“普通 location ”是以“ = ”或“ ^~ ”为前缀或者没有任何前缀的 /uri/ ；“正则 location ”是以“ ~ ”或“ ~* ”为前缀的 /uri/ 。</p>
<p>那么，当我们在一个 server 上下文编写了多个 location 的时候， Nginx 对于一个 HTTP 请求，是如何匹配到一个 location 做处理呢？用一句话简单概括 Nginx 的 location 匹配规则是：“正则 location ”让步 “普通 location”的严格精确匹配结果；但覆盖 “普通 location ”的最大前缀匹配结果。理解这句话，我想通过下面的实例来说明。</p>
<p>#1 先普通 location ，再正则 location<br>
周边不少童鞋告诉我， nginx 是“先匹配正则 location 再匹配普通 location ”，其实这是一个误区， nginx 其实是“先匹配普通 location ，再匹配正则 location ”，但是普通 location 的匹配结果又分两种：一种是“严格精确匹配”，官方英文说法是“ exact match ”；另一种是“最大前缀匹配”，官方英文说法是“ Literal strings match the beginning portion of the query – the most specific match will be used. ”。我们做个实验：</p>
<p>例题 1 ：假设 nginx 的配置如下</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>附录 nginx 的目录结构是： nginx-&gt;html-&gt;index.html</p>
<p>上述配置的意思是： location / {… deny all;} 普通 location 以“ / ”开始的 URI 请求（注意任何 HTTP 请求都必然以“/ ”开始，所以“ / ”的意思是所有的请求都能被匹配上），都拒绝访问； location ~.html$ {allow all;} 正则 location以 .html 结尾的 URI 请求，都允许访问。</p>
<p>测试结果：</p>
<p>[root@web108 ~]# curl http://localhost:9090/</p>
<html>
<head><title>403 Forbidden</title></head>
<body bgcolor=”white”>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]# curl http://localhost:9090/index.html</p>
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor=”white” text=”black”>
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
<p>[root@web108 ~]# curl http://localhost:9090/index_notfound.html</p>
<html>
<head><title>404 Not Found</title></head>
<body bgcolor=”white”>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>测试结果如下：</p>
<p>URI 请求	HTTP 响应<br>
curl http://localhost:9090/	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!<br>
curl http://localhost:9090/index_notfound.html	404 Not Found<br>
curl http://localhost:9090/ 的结果是“ 403 Forbidden ”，说明被匹配到“ location / {..deny all;} ”了，原因很简单HTTP 请求 GET / 被“严格精确”匹配到了普通 location / {} ，则会停止搜索正则 location ；</p>
<p>curl http://localhost:9090/index.html 结果是“ Welcome to nginx! ”，说明没有被“ location / {…deny all;} ”匹配，否则会 403 Forbidden ，但 /index.html 的确也是以“ / ”开头的，只不过此时的普通 location / 的匹配结果是“最大前缀”匹配，所以 Nginx 会继续搜索正则 location ， location ~ .html$ 表达了以 .html 结尾的都 allow all; 于是接着就访问到了实际存在的 index.html 页面。</p>
<p>curl http://localhost:9090/index_notfound.html   同样的道理先匹配 location / {} ，但属于“普通 location 的最大前缀匹配”，于是后面被“正则 location ” location ~ .html$ {} 覆盖了，最终 allow all ； 但的确目录下不存在index_notfound.html 页面，于是 404 Not Found 。</p>
<p>如果此时我们访问 http://localhost:9090/index.txt 会是什么结果呢？显然是 deny all ；因为先匹配上了 location / {..deny all;} 尽管属于“普通 location ”的最大前缀匹配结果，继续搜索正则 location ，但是 /index.txt 不是以 .html结尾的，正则 location 失败，最终采纳普通 location 的最大前缀匹配结果，于是 deny all 了。</p>
<p>[root@web108 ~]# curl http://localhost:9090/index.txt</p>
<html>
<head><title>403 Forbidden</title></head>
<body bgcolor=”white”>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>#2 普通 location 的“隐式”严格匹配<br>
例题 2 ：我们在例题 1 的基础上增加精确配置</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

              location / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>测试请求：</p>
<p>[root@web108 ~]# curl http://localhost:9090/exact/match.html</p>
<html>
<head><title>404 Not Found</title></head>
<body bgcolor=”white”>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>结果进一步验证了“普通 location ”的“严格精确”匹配会终止对正则 location 的搜索。这里我们小结下“普通 location”与“正则 location ”的匹配规则：先匹配普通 location ，再匹配正则 location ，但是如果普通 location 的匹配结果恰好是“严格精确（ exact match ）”的，则 nginx 不再尝试后面的正则 location ；如果普通 location 的匹配结果是“最大前缀”，则正则 location 的匹配覆盖普通 location 的匹配。也就是前面说的“正则 location 让步普通location 的严格精确匹配结果，但覆盖普通 location 的最大前缀匹配结果”。</p>
<p>#3 普通 location 的“显式”严格匹配和“ ^~ ” 前缀<br>
上面我们演示的普通 location 都是不加任何前缀的，其实普通 location 也可以加前缀：“ ^~ ”和“ = ”。其中“ ^~”的意思是“非正则，不需要继续正则匹配”，也就是通常我们的普通 location ，还会继续搜索正则 location （恰好严格精确匹配除外），但是 nginx 很人性化允许配置人员告诉 nginx 某条普通 location ，无论最大前缀匹配，还是严格精确匹配都终止继续搜索正则 location ；而“ = ”则表达的是普通 location 不允许“最大前缀”匹配结果，必须严格等于，严格精确匹配。</p>
<p>例题 3 ：“ ^~ ”前缀的使用</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

             location ^~ / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>把例题 2 中的 location / {} 修改成 location ^~ / {} ，再看看测试结果：</p>
<p>URI 请求	修改前	修改后<br>
curl http://localhost:9090/	403 Forbidden	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!	403 Forbidden<br>
curl http://localhost:9090/index_notfound.html	404 Not Found	403 Forbidden<br>
curl http://localhost:9090/exact/match.html	404 Not Found	404 Not Found<br>
除了 GET /exact/match.html 是 404 Not Found ，其余都是 403 Forbidden ，原因很简单所有请求都是以“ / ”开头，所以所有请求都能匹配上“ / ”普通 location ，但普通 location 的匹配原则是“最大前缀”，所以只有/exact/match.html 匹配到 location /exact/match.html {allow all;} ，其余都 location ^~ / {deny all;} 并终止正则搜索。</p>
<p>例题 4 ：“ = ”前缀的使用</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

             location = / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>例题 4 相对例题 2 把 location / {} 修改成了 location = / {} ，再次测试结果：</p>
<p>URI 请求	修改前	修改后<br>
curl http://localhost:9090/	403 Forbidden	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!	Welcome to nginx!<br>
curl http://localhost:9090/index_notfound.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/exact/match.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/test.jsp	403 Forbidden	404 Not Found<br>
最能说明问题的测试是 GET /test.jsp ，实际上 /test.jsp 没有匹配正则 location （ location ~.html$ ），也没有匹配 location = / {} ，如果按照 location / {} 的话，会“最大前缀”匹配到普通 location / {} ，结果是 deny all 。</p>
<p>#4 正则 location 与编辑顺序<br>
location 的指令与编辑顺序无关，这句话不全对。对于普通 location 指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀“ ^~ ”或“ = ”（符号“ = ”只能严格匹配，不能前缀匹配），则停止搜索正则 location ；但对于正则 location 的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</p>
<p>配置 3.1</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

   location ~ \.html$ {

       allow all; 

   } 

   location ~ ^/prefix/.*\.html$ {

       deny all; 

   } 
</code></pre>
<p>}</p>
<p>配置 3.2</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

 

   location ~ ^/prefix/.*\.html$ {

       deny all; 

   } 

             

              location ~ \.html$ {

       allow all; 

   } 
</code></pre>
<p>}</p>
<p>测试结果：</p>
<p>URI 请求	配置 3.1	配置 3.2<br>
curl http://localhost:9090/regextest.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/prefix/regextest.html	404 Not Found	403 Forbidden<br>
解释：</p>
<p>Location ~ ^/prefix/.*.html$ {deny all;} 表示正则 location 对于以 /prefix/ 开头， .html 结尾的所有 URI 请求，都拒绝访问；   location ~.html<span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\.&#039; in math mode at position 71: …实际上，prefix 的是 ~\̲.̲html'>{allow all;} 表示正则 location 对于以 .html 结尾的 URI 请求，都允许访问。 实际上，prefix 的是 ~\.html</span> 的子集。</p>
<p>在“配置 3.1 ”下，两个请求都匹配上 location ~.html$ {allow all;} ，并且停止后面的搜索，于是都允许访问， 404 Not Found ；在“配置 3.2 ”下， /regextest.html 无法匹配 prefix ，于是继续搜索 ~.html$ ，允许访问，于是 404 Not Found ；然而 /prefix/regextest.html 匹配到 prefix ，于是 deny all ， 403 Forbidden 。</p>
<p>配置 3.3</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

   location  /prefix/ {

           deny all; 

   } 

     

   location  /prefix/mid/ {

           allow all; 

   } 
</code></pre>
<p>}</p>
<p>配置 3.4</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

 

   location  /prefix/mid/ {

           allow all; 

   } 

              location  /prefix/ {

           deny all; 

   } 
</code></pre>
<p>}</p>
<p>测试结果：</p>
<p>URI 请求	配置 3.1	配置 3.2<br>
curl http://localhost:9090/prefix/t.html	  403 Forbidden    	403 Forbidden<br>
curl http://localhost:9090/prefix/mid/t.html	404 Not Found	404 Not Found<br>
测试结果表明：普通 location 的匹配规则是“最大前缀”匹配，而且与编辑顺序无关。</p>
<p>#5 “@” 前缀 Named Location 使用<br>
REFER:  http://wiki.nginx.org/HttpCoreModule#error_page</p>
<p>假设配置如下：</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

    location  / {

       root   html;

       index  index.html index.htm;

       allow all;

   }

   #error_page 404 http://www.baidu.com # 直接这样是不允许的

   error_page 404 = @fallback;

   location @fallback {

       proxy_pass http://www.baidu.com;

   }
</code></pre>
<p>}</p>
<p>上述配置文件的意思是：如果请求的 URI 存在，则本 nginx 返回对应的页面；如果不存在，则把请求代理到baidu.com 上去做个弥补（注： nginx 当发现 URI 对应的页面不存在， HTTP_StatusCode 会是 404 ，此时error_page 404 指令能捕获它）。</p>
<p>测试一：</p>
<p>[root@web108 ~]# curl http://localhost:9090/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:17:21 GMT</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<p>Location: http://localhost:9090/search/error.html</p>
<p>Connection: keep-alive</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:17:21 GMT</p>
<p>Content-Length: 222</p>
<!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href=”http://www.baidu.com/search/error.html”>here</a>.</p>
</body></html>
<p>[root@web108 ~]#</p>
<p>当我们 GET /nofound.html 发送给本 nginx ， nginx 找不到对应的页面，于是 error_page 404 = @fallback ，请求被代理到 http://www.baidu.com ，于是 nginx 给 http://www.baidu.com 发送了 GET /nofound.html ，但/nofound.html 页面在百度也不存在，百度 302 跳转到错误页。</p>
<p>直接访问 http://www.baidu.com/nofound.html 结果：</p>
<p>[root@web108 ~]# curl http://www.baidu.com/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Date: Sat, 06 Aug 2011 08:20:05 GMT</p>
<p>Server: Apache</p>
<p>Location: http://www.baidu.com/search/error.html</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:20:05 GMT</p>
<p>Content-Length: 222</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href=”http://www.baidu.com/search/error.html”>here</a>.</p>
</body></html>
<p>[root@web108 ~]#</p>
<p>测试二：访问一个 nginx 不存在，但 baidu 存在的页面</p>
<p>[root@web108 ~]# curl http://www.baidu.com/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Date: Sat, 06 Aug 2011 08:21:56 GMT</p>
<p>Server: Apache</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A0C88CA7075A6601A:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A2337F78F909CCB90:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: “d66-49913b8efe340″</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:21:56 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html</p>
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”

“http://www.w3.org/TR/html4/loose.dtd”>
<p>。。。。</p>
</body>
</html>
<p>显示，的确百度这个页面是存在的。</p>
<p>[root@web108 ~]# curl http://localhost:9090/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:23:23 GMT</p>
<p>Content-Type: text/html</p>
<p>Connection: keep-alive</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277DCB4CC5F80B7F457:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277B1F87691AFFD7440:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: “d66-49913b8efe340″</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:23:23 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”

“http://www.w3.org/TR/html4/loose.dtd”>
<html>
<p>。。。</p>
</body>
</html>
<p>当 curl http://localhost:9090/duty/ -i 时， nginx 没找到对应的页面，于是 error_page = @fallback ，把请求代理到 baidu.com 。注意这里的 error_page = @fallback 不是靠重定向实现的，而是所说的“ internally redirected （forward ）”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx七层负载均衡的几种调度算法]]></title>
        <id>https://newdy.cf/post/nginx-qi-ceng-fu-zai-jun-heng-de-ji-chong-diao-du-suan-fa/</id>
        <link href="https://newdy.cf/post/nginx-qi-ceng-fu-zai-jun-heng-de-ji-chong-diao-du-suan-fa/">
        </link>
        <updated>2020-02-19T04:44:25.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx是一款轻量级的高性能web服务器，同时也是一款非常优秀的负载均衡器和反向代理服务器。由于支持强大的正则匹配规则、动静分离、URLrewrite功能及安装配置简单且对网络稳定性依赖非常小等优点，所以常用来做为七层负载均衡使用。在硬件不差的情况下，通常可以稳定支持几万的并发连接，在硬件性能足够好，且对系统内核参数及Nginx配置进行优化甚至可以达到10万以上的并发。</p>
<p>以下是Nginx作为七层负载均衡常用的几种调度算法和适用的业务场景</p>
<p>1、轮询（默认调度算法）</p>
<p>特点：每个请求按时间顺序逐一分配到不同的后端服务器处理。<br>
适用业务场景：后端服务器硬件性能配置完全一致，业务无特殊要求时使用。<br>
upstream backendserver {<br>
server 192.168.0.14：80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15：80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>2、加权轮询</p>
<p>特点：指定轮询几率，weight值(权重)和访问比例成正比，用户请求按权重比例分配。<br>
适用业务场景：用于后端服务器硬件性处理能力不平均的情形。<br>
upstream backendserver {<br>
server 192.168.0.14:80 weight=5 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 weight=10 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>3、ip_hash</p>
<p>特点：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session会话保持问题。<br>
适用业务场景：适用于需要账号登录的系统，会话连接保持的业务。<br>
upstream backendserver {<br>
ip_hash;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>4、最少连接数 least_conn</p>
<p>特点：按nginx反向代理与后端服务器之间的连接数，连接数最少的优先分配。</p>
<p>适用业务场景：适用于客户端与后端服务器需要保持长连接的业务。<br>
upstream backendserver {<br>
least_conn;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>5、fair（需编译安装第三方模块 ngx_http_upstream_fair_module）</p>
<p>特点：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>
适用业务场景：对访问响应速度有一定要求的业务。<br>
upstream backendserver {<br>
fair;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>6、url_hash（需编译安装第三方模块 ngx_http_upstream_hash_module）</p>
<p>特点：按访问url的hash结果来分配请求，使同一个url访问到同一个后端服务器。<br>
适用业务场景：适用于后端服务器为缓存服务器时比较有效。<br>
upstream backendserver {<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
hash $request_uri;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux CentOS 7 非root用户安装源码版Docker]]></title>
        <id>https://newdy.cf/post/linux-centos-7-fei-root-yong-hu-an-zhuang-yuan-ma-ban-docker/</id>
        <link href="https://newdy.cf/post/linux-centos-7-fei-root-yong-hu-an-zhuang-yuan-ma-ban-docker/">
        </link>
        <updated>2020-02-19T04:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>注意:非root用户必须要有sudo权限</p>
<p>一、安装前的准备</p>
<p>1.查看当前主机是否有docker组</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582087080673.png" alt="" loading="lazy"></figure>
<p>若没有输出结果则新建</p>
<figure data-type="image" tabindex="2"><img src="https://newdy.cf/post-images/1582087086554.png" alt="" loading="lazy"></figure>
<p>再次查看,发现已经有了docker组</p>
<figure data-type="image" tabindex="3"><img src="https://newdy.cf/post-images/1582087091705.png" alt="" loading="lazy"></figure>
<p>2.新增拥有sudo权限的用户(若知道root和其他拥有sudo权限的系统用户密码,跳到3;若都没有,必做)</p>
<figure data-type="image" tabindex="4"><img src="https://newdy.cf/post-images/1582087133234.png" alt="" loading="lazy"></figure>
<p>修改该用户的密码<br>
<img src="https://newdy.cf/post-images/1582087138797.png" alt="" loading="lazy"></p>
<p>为新增的用户添加sudo权限</p>
<p>sudo vi /etc/sudoers<br>
　　在92行下一行添加<br>
　　test    　　ALL=(ALL)    　　ALL<br>
3.把当前用户加入到docker组 （此时用户并没有加入进docker组）</p>
<figure data-type="image" tabindex="5"><img src="https://newdy.cf/post-images/1582087165679.png" alt="" loading="lazy"></figure>
<p>切换至sudo权限用户，然后再切换回当前用户（此时可以看到用户已经加入docker组）</p>
<figure data-type="image" tabindex="6"><img src="https://newdy.cf/post-images/1582087175735.png" alt="" loading="lazy"></figure>
<p>3.删除新增的用户和它的sudo权限（第2步没做请忽略此步）</p>
<p>sudo vi /etc/sudoers<br>
　　在92行下一行添加<br>
　　test　　ALL=(ALL)  ALL<br>
两次退出，不然删除用户时会报错</p>
<figure data-type="image" tabindex="7"><img src="https://newdy.cf/post-images/1582087195961.png" alt="" loading="lazy"></figure>
<p>二、安装docker</p>
<p>1.下载docker源码包并上传至虚拟机</p>
<p>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz</p>
<p>2.解压源码包至指定目录下</p>
<figure data-type="image" tabindex="8"><img src="https://newdy.cf/post-images/1582087215827.png" alt="" loading="lazy"></figure>
<p>3.将解压出来的docker目录下的指令复制到 /usr/bin/ 目录下</p>
<p>sudo cp docker/* /usr/bin/<br>
4./usr/bin/目录下docker有关指令的所属用户和所属组(必做,不然非root用户使用docker指令报错:权限不够)</p>
<p>sudo chown root:docker /usr/bin/docker*<br>
sudo chown root:docker /usr/bin/containerd*<br>
sudo chown root:docker /usr/bin/runc<br>
sudo chown root:docker /usr/bin/ctr<br>
5.查看一下是否改变所属用户和所属组(得到和解压出来的docker目录下的一样的8个指令)</p>
<figure data-type="image" tabindex="9"><img src="https://newdy.cf/post-images/1582087235444.png" alt="" loading="lazy"></figure>
<p>6.将docker注册为service服务</p>
<p>新建该文件<br>
sudo vi /etc/systemd/system/docker.service<br>
加入以下内容：<br>
[Unit]<br>
Description=Docker Application Container Engine<br>
Documentation=https://docs.docker.com<br>
After=network-online.target firewalld.service<br>
Wants=network-online.target</p>
<p>[Service]<br>
Type=notify<br>
ExecStart=/usr/bin/dockerd<br>
ExecReload=/bin/kill -s HUP $MAINPID<br>
LimitNOFILE=infinity<br>
LimitNPROC=infinity<br>
LimitCORE=infinity<br>
TimeoutStartSec=0<br>
Delegate=yes<br>
KillMode=process<br>
Restart=on-failure<br>
StartLimitBurst=3<br>
StartLimitInterval=60s</p>
<p>[Install]<br>
WantedBy=multi-user.target<br>
7.添加执行权限并重新加载配置文件</p>
<p>sudo chmod a+x /etc/systemd/system/docker.service<br>
sudo systemctl daemon-reloa<br>
8.docker镜像加速(可以不做,但是docker pull会很慢,由于docker官网在海外)</p>
<p>新建该文件<br>
sudo vi /etc/docker/daemon.json<br>
加入以下内容<br>
{<br>
&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]<br>
}</p>
<p>9.启动docker</p>
<p>sudo systemctl start docker<br>
三、docker基础命令</p>
<p>docker启/停/重启/查看状态<br>
sudo systemctl  start/stop/restart/status</p>
<p>查看docker已有镜像<br>
docker images</p>
<p>在docker官网搜寻指定镜像<br>
docker search 镜像</p>
<p>下载镜像(不加标签默认下载最新版本的镜像)<br>
docker pull 镜像名字:tag(即标签)</p>
<p>启动容器(以xxx名字运行基于镜像的容器，并映射容器端口到本机端口，容器目录文件储存在本机目录)<br>
docker run -d -name xxx -p 本机端口:容器端口 -v 本机目录:容器目录 镜像name:tag(或ID)</p>
<p>进入正在运行的容器内部<br>
docker exec -it 容器name(或ID) /bin/bash</p>
<p>容器的启/停/重启/信息/删除<br>
docker start/stop/restart/inspect/rm 容器name(或ID)</p>
<p>查看正在运行的容器<br>
docker ps</p>
<p>查看所有容器(包括正在运行的、停止的,不包括删除的)<br>
docker ps -a</p>
<p>镜像的删除(删除镜像前请删除所有与该镜像有关的容器)<br>
docker rmi 镜像name:tag(或ID)</p>
<p>查看当前安装的docker有关信息<br>
docker info<br>
dd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows10下nginx的rtmp服务器搭建]]></title>
        <id>https://newdy.cf/post/windows10-xia-nginx-de-rtmp-fu-wu-qi-da-jian/</id>
        <link href="https://newdy.cf/post/windows10-xia-nginx-de-rtmp-fu-wu-qi-da-jian/">
        </link>
        <updated>2020-02-19T04:28:12.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>下载 nginx 1.7.11.3 Gryphon<br>
    下载链接: http://nginx-win.ecsds.eu/download/nginx 1.7.11.3 Gryphon.zip，下载完成后解压， 将解压后的目录命名为</li>
</ol>
<p>nginx-1.7.11.3-Gryphon<br>
2. 下载服务器状态检查程序 stat.xsl（注：直接clone到nginx-1.7.11.3-Gryphon目录下）</p>
<p>下载地址https://github.com/arut/nginx-rtmp-module/</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582086527036.png" alt="" loading="lazy"></figure>
<ol>
<li>配置文件 conf\nginx-win-rtmp.conf 内容如下:（注：用记事本打开直接复制粘贴，避免编码格式引起错误）</li>
</ol>
<p>#user  nobody;</p>
<h1 id="multiple-workers-works">multiple workers works !</h1>
<p>worker_processes  2;</p>
<p>#error_log  logs/error.log;<br>
#error_log  logs/error.log  notice;<br>
#error_log  logs/error.log  info;</p>
<p>#pid        logs/nginx.pid;</p>
<p>events {<br>
worker_connections  8192;<br>
# max value 32768, nginx recycling connections+registry optimization =<br>
#   this.value * 20 = max concurrent connections currently tested with one worker<br>
#   C1000K should be possible depending there is enough ram/cpu power<br>
# multi_accept on;<br>
}</p>
<p>rtmp {<br>
server {<br>
listen 1935;<br>
chunk_size 4000;<br>
application live {<br>
live on;</p>
<pre><code>         # record first 1K of stream
         record all;
         record_path /tmp/av;
         record_max_size 1K;

         # append current timestamp to each flv
         record_unique on;

         # publish only from localhost
         allow publish 127.0.0.1;
         deny publish all;

         #allow play all;
    }
}
</code></pre>
<p>}</p>
<p>http {<br>
#include      /nginx/conf/naxsi_core.rules;<br>
include       mime.types;<br>
default_type  application/octet-stream;</p>
<pre><code>#log_format  main  '$remote_addr:$remote_port - $remote_user [$time_local] &quot;$request&quot; '
#                  '$status $body_bytes_sent &quot;$http_referer&quot; '
#                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

#access_log  logs/access.log  main;
</code></pre>
<h1 id="loadbalancing-php"># loadbalancing PHP</h1>
<h1 id="upstream-myloadbalancer">upstream myLoadBalancer {</h1>
<h1 id="server-1270019001-weight1-fail_timeout5">server 127.0.0.1:9001 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019002-weight1-fail_timeout5">server 127.0.0.1:9002 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019003-weight1-fail_timeout5">server 127.0.0.1:9003 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019004-weight1-fail_timeout5">server 127.0.0.1:9004 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019005-weight1-fail_timeout5">server 127.0.0.1:9005 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019006-weight1-fail_timeout5">server 127.0.0.1:9006 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019007-weight1-fail_timeout5">server 127.0.0.1:9007 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019008-weight1-fail_timeout5">server 127.0.0.1:9008 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019009-weight1-fail_timeout5">server 127.0.0.1:9009 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019010-weight1-fail_timeout5">server 127.0.0.1:9010 weight=1 fail_timeout=5;</h1>
<h1 id="least_conn">least_conn;</h1>
<h1 id="">}</h1>
<pre><code>sendfile        off;
#tcp_nopush     on;

server_names_hash_bucket_size 128;
</code></pre>
<h2 id="start-timeouts">Start: Timeouts</h2>
<pre><code>client_body_timeout   10;
client_header_timeout 10;
keepalive_timeout     30;
send_timeout          10;
keepalive_requests    10;
</code></pre>
<h2 id="end-timeouts">End: Timeouts</h2>
<pre><code>#gzip  on;

server {
    listen       80;
    server_name  localhost;


    location /stat {
        rtmp_stat all;
        rtmp_stat_stylesheet stat.xsl;
    }
    location /stat.xsl {
        root nginx-rtmp-module/;
    }
    location /control {
        rtmp_control all;
    }

    #charset koi8-r;
    #access_log  logs/host.access.log  main;

    ## Caching Static Files, put before first location
    #location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
    #    expires 14d;
    #    add_header Vary Accept-Encoding;
    #}
</code></pre>
<h1 id="for-naxsi-remove-the-single-line-for-learn-mode-or-the-lines-for-full-waf-mode">For Naxsi remove the single # line for learn mode, or the ## lines for full WAF mode</h1>
<pre><code>    location / {
        #include    /nginx/conf/mysite.rules; # see also http block naxsi include line
        ##SecRulesEnabled;
     ##DeniedUrl &quot;/RequestDenied&quot;;
     ##CheckRule &quot;$SQL &gt;= 8&quot; BLOCK;
     ##CheckRule &quot;$RFI &gt;= 8&quot; BLOCK;
     ##CheckRule &quot;$TRAVERSAL &gt;= 4&quot; BLOCK;
     ##CheckRule &quot;$XSS &gt;= 8&quot; BLOCK;
        root   html;
        index  index.html index.htm;
    }
</code></pre>
<h1 id="for-naxsi-remove-the-lines-for-full-waf-mode-redirect-location-block-used-by-naxsi">For Naxsi remove the ## lines for full WAF mode, redirect location block used by naxsi</h1>
<pre><code>    ##location /RequestDenied {
    ##    return 412;
    ##}
</code></pre>
<h2 id="lua-examples">Lua examples !</h2>
<h1 id="location-robotstxt">location /robots.txt {</h1>
<h1 id="rewrite_by_lua">rewrite_by_lua '</h1>
<h1 id="if-ngxvarhttp_host-~-localhost-then">if ngx.var.http_host ~= &quot;localhost&quot; then</h1>
<h1 id="return-ngxexecrobots_disallowtxt">return ngx.exec(&quot;/robots_disallow.txt&quot;);</h1>
<h1 id="end">end</h1>
<h1 id="-2">';</h1>
<h1 id="-3">}</h1>
<pre><code>    #error_page  404              /404.html;
    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}
    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000; # single backend process
    #    fastcgi_pass   myLoadBalancer; # or multiple, see example above
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    #    include        fastcgi_params;
    #}
    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
# another virtual host using mix of IP-, name-, and port-based configuration
#
#server {
#    listen       8000;
#    listen       somename:8080;
#    server_name  somename  alias  another.alias;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
# HTTPS server
#
#server {
#    listen       443 ssl spdy;
#    server_name  localhost;
#    ssl                  on;
#    ssl_certificate      cert.pem;
#    ssl_certificate_key  cert.key;
#    ssl_session_timeout  5m;
#    ssl_prefer_server_ciphers On;
#    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
#    ssl_ciphers ECDH+AESGCM:ECDH+AES256:ECDH+AES128:ECDH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!eNULL:!MD5:!DSS:!EXP:!ADH:!LOW:!MEDIUM;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
</code></pre>
<p>}<br>
4. 启动服务器</p>
<p>nginx.exe -c conf\nginx-win-rtmp.conf<br>
5.使用ffmpeg、ffplay进行推流拉流验证（直接ffmpeg官方下载windows下的可执行文件）</p>
<p>5.1推流测试，使用ffmpeg命令完成即可</p>
<p>ffmpeg.exe -re -i inputfile.mp4 -vcodec libx264 -acodec aac -f flv rtmp://localhost:1935/live/home<br>
5.2拉流测试，使用ffplay命令完成即可<br>
—————————————<br>
ffplay.exe rtmp://localhost:1935/live/home<br>
<img src="https://newdy.cf/post-images/1582086643460.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx-rtmp+ FFmpeg +Docker + vue.js 直播系统搭建]]></title>
        <id>https://newdy.cf/post/nginx-rtmp-ffmpeg-docker-vuejs-zhi-bo-xi-tong-da-jian/</id>
        <link href="https://newdy.cf/post/nginx-rtmp-ffmpeg-docker-vuejs-zhi-bo-xi-tong-da-jian/">
        </link>
        <updated>2020-02-19T04:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>思路（如图）：<br>
<img src="https://newdy.cf/post-images/1582086243575.jpg" alt="" loading="lazy"><br>
1，开启推流服务器（这里我的Nginx-rtmp服务器搭建成功）</p>
<p>进入docker 开启推流服务器  docker run -it -p 1935:1935 -p 8000:80 --rm alfg/nginx-rtmp</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582086272172.jpg" alt="" loading="lazy"></figure>
<p>2，推流（两种方法）</p>
<p>命令推流：</p>
<p>查看本机摄像头及麦克风设备 ffmpeg -list_devices true -f dshow -i dummy</p>
<p>音视频推流： ffmpeg -f dshow -i video=&quot;VMware Virtual USB Video Device&quot;:audio=&quot;Microphone (High Definition Audio Device)&quot; -tune:v zerolatency -f flv &quot;rtmp://192.168.99.100:1935/stream/test&quot;</p>
<p>#推流视频文件<br>
ffmpeg -re -stream_loop -1 -i test.mp4 -f flv rtmp://192.168.99.100:1935/stream/test<br>
播放地址http://192.168.99.100:8000/live/test.m3u8</p>
<p>#将摄像头推流到hls<br>
ffmpeg -f vfwcap  -i &quot;0&quot; -c:v libx264 -preset ultrafast  -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1935/hls/home<br>
播放地址http://localhost:8080/hls/home.m3u8</p>
<p>#将屏幕推流到rtmp<br>
start ffmpeg -f gdigrab -i desktop -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv<br>
播放地址rtmp://localhost:1935/live/jing<br>
使用第三方软件推流：（例如：OBS Studio）</p>
<p>3，拉流</p>
<p>这里前端使用的是通过VUE</p>
<p>注意使用video需安装以下几个依赖</p>
<p>cnpm install video.js<br>
cnpm install aes-decrypter<br>
cnpm install m3u8-parser<br>
cnpm install mpd-parser<br>
cnpm install mux.js<br>
cnpm install url-toolkit<br>
cnpm install videojs-contrib-hls</p>
<video id="my-video" class="video-js vjs-default-skin" controls preload="auto" >
                                        <source src="http://192.168.99.100:8000/live/test.m3u8" type="application/x-mpegURL">
                                </video>
<script>
        //vue 的video插件
            import videojs from 'video.js'
            import 'videojs-contrib-hls'

    export default {
    mounted:function(){
                    //自动执行直播平台
                    videojs('my-video', {
                    bigPlayButton: false,
                    textTrackDisplay: false,
                    posterImage: true,
                    errorDisplay: false,
                    controlBar: true
            }, function () {
                    this.play()
            })
        }
    }
}



</script>
<p>效果如下：<br>
<img src="https://newdy.cf/post-images/1582086327475.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EasyProxy-又一款有管理面板的内网穿透代理服务器]]></title>
        <id>https://newdy.cf/post/easyproxy-you-yi-kuan-you-guan-li-mian-ban-de-nei-wang-chuan-tou-dai-li-fu-wu-qi/</id>
        <link href="https://newdy.cf/post/easyproxy-you-yi-kuan-you-guan-li-mian-ban-de-nei-wang-chuan-tou-dai-li-fu-wu-qi/">
        </link>
        <updated>2020-02-17T02:11:45.000Z</updated>
        <content type="html"><![CDATA[<p>easyProxy是一款轻量级、高性能、功能最为强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理，可实现在非内网环境下如同使用vpn一样访问内网资源和设备的效果，同时支持socks5验证，gzip、snnapy压缩（节省带宽和流量）。</p>
<p>目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。<br>
支持客户端与服务端连接中断自动重连，多路传输，大大的提高请求处理速度，go语言编写，无第三方依赖。<br>
<img src="https://newdy.cf/post-images/1581905568218.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1581905601275.png" alt="" loading="lazy"><br>
一、简介<br>
web管理模式，可配置多条tcp、udp隧道，多个域名代理等等—-&gt; web管理模式<br>
内网多站点配合代理。—-&gt; http反向代理请求<br>
想在外网通过ssh连接内网的机器，做云服务器到内网服务器端口的映射，或者做微信公众号开发、小程序开发等—-&gt;tcp隧道模式<br>
在非内网环境下使用内网dns，或者需要通过udp访问内网机器等—-&gt;udp隧道模式<br>
在外网使用HTTP代理访问内网站点—-&gt;http代理模式<br>
搭建一个内网穿透ss，在外网如同使用内网vpn一样访问内网资源或者设备—-&gt; socks5代理模式<br>
二、特点<br>
支持gzip、snappy压缩,减小传输过程流量消耗<br>
支持多站点配置,兼容多个内网网站，可处理相互之间的跳转包含关系<br>
断线自动重连<br>
支持多路传输,提高并发<br>
跨站自动匹配替换<br>
支持tcp隧道,提升访问效率<br>
支持udp隧道<br>
支持http代理<br>
支持内网穿透sock5代理，配合proxifer可达到vpn的效果，在外网访问内网资源或者设备，同时可以设置用户名和密码验证<br>
强大的web管理界面，可方便的设置的和管理隧道<br>
支持同时开多条tcp、udp隧道等等，且只需要开一个客户端和服务端<br>
支持一个服务端，多个客户端模式<br>
三、安装方法<br>
release安装<br>
https://github.com/cnlh/easyProxy/releases</p>
<p>下载对应的系统版本即可（目前linux和windows只编译了64位的），服务端和客户端共用一个程序，go语言开发，无需任何第三方依赖</p>
<p>源码安装<br>
安装源码<br>
go get github.com/cnlh/easyProxy</p>
<p>编译（无第三方模块）<br>
go build</p>
<p>四、使用方法<br>
有两种模式：</p>
<p>1、单客户端模式，所有的隧道流量均从这个单客户端转发。</p>
<p>服务端<br>
./easyProxy -mode=webServer -tcpport=8284 -vkey=DKibZF5TXvic1g3kY<br>
名称	含义<br>
mode	运行模式<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
配置<br>
进入web界面，公网ip:web界面端口（默认8080），密码为123</p>
<p>2、多客户端模式，不同的隧道流量均从不同的客户端转发。</p>
<p>服务端<br>
./easyProxy -mode=webServer -tcpport=8284<br>
名称	含义<br>
mode	运行模式<br>
tcpport	服务端与客户端通信端口<br>
客户端<br>
进入web管理界面，有详细的命令</p>
<p>配置<br>
进入web界面，公网ip:web界面端口（默认8080），密码为123</p>
<p>配置文件/conf/app.conf<br>
名称	含义<br>
httpport	web管理端口<br>
password	web界面管理密码<br>
hostPort	域名代理模式监听端口<br>
TCP隧道模式<br>
场景及原理<br>
较为适用于处理tcp连接，例如ssh，同时也适用于http等，访问服务端的8024端口相当于访问内网10.1.50.202机器的4000端口，构成如下所示的隧道。<br>
<img src="https://newdy.cf/post-images/1581905662220.jpg" alt="" loading="lazy"><br>
例如：</p>
<p>背景:</p>
<p>内网机器10.1.50.203提供了web服务80端口<br>
有VPS一个,公网IP:123.206.77.88<br>
需求:</p>
<p>在家里能够通过访问VPS的8024端口访问到内网机器A的80端口</p>
<p>使用<br>
服务端<br>
./easyProxy -mode=tunnelServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024 -target=10.1.50.203:80<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	外部访问端口<br>
target	目标地址，格式如上<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
udp隧道模式<br>
场景及原理<br>
背景</p>
<p>内网机器A提供了DNS解析服务,10.1.50.210:53端口<br>
有VPS一个,公网IP:123.206.77.88<br>
需求: 在家里能够通过设置本地dns为123.206.77.88,使用内网机器A进行域名解析服务.</p>
<p>访问vps的53端口相当于访问10.1.50.210的53端口，构成如下所示的隧道。<br>
<img src="https://newdy.cf/post-images/1581905725788.png" alt="" loading="lazy"><br>
使用<br>
服务端<br>
./easyProxy -mode=udpServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=53 -target=10.1.50.210:53<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	公网vps的访问端口<br>
target	目标地址，格式如上<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
HTTP代理请求<br>
场景及原理<br>
较为适用于http，也就是web站点的穿透，服务端与客户端之间建立连接，服务端收到http请求后，将请求发送到客户端，客户端再执行这个请求，并将结果返回给服务端，服务端收到后再返回。特点：支持同时代理多个站点，不同站点之间有联系还可以实现匹配替换<br>
<img src="https://newdy.cf/post-images/1581905766574.png" alt="" loading="lazy"><br>
最终效果：</p>
<p>访问a.server.com和访问10.1.50.203的80端口相同<br>
访问b.server.com和访问10.1.50.202的80端口相同<br>
访问c.server.com和访问10.1.50.201的80端口相同<br>
使用<br>
服务端<br>
./easyProxy -mode=httpServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	代理的http端口（与nginx配合使用）<br>
客户端<br>
建立配置文件 config.json<br>
./easyProxy -server=ip:port -config=config.json -vkey=DKibZF5TXvic1g3kY<br>
名称	含义<br>
config	配置文件路径<br>
配置文件config.json<br>
{<br>
&quot;SiteList&quot;: [<br>
{<br>
&quot;host&quot;: &quot;a.ourcauc.com&quot;,<br>
&quot;url&quot;: &quot;10.1.50.203&quot;,<br>
&quot;port&quot;: 80<br>
},<br>
{<br>
&quot;host&quot;: &quot;b.ourcauc.com&quot;,<br>
&quot;url&quot;: &quot;10.1.50.202&quot;,<br>
&quot;port&quot;: 80<br>
},<br>
{<br>
&quot;host&quot;: &quot;c.ourcauc.com&quot;,<br>
&quot;url&quot;: &quot;10.1.50.203&quot;,<br>
&quot;port&quot;: 80<br>
}<br>
],<br>
&quot;Replace&quot;: 0<br>
}<br>
名称	含义<br>
SiteList	本地解析的域名列表<br>
host	域名地址<br>
url	内网代理的地址<br>
port	内网代理的地址对应的端口<br>
Replace	是否自动匹配替换（查看场景）<br>
nginx代理配置示例<br>
upstream nodejs {<br>
server 127.0.0.1:8024;<br>
keepalive 64;<br>
}<br>
server {<br>
listen 80;<br>
server_name a.ourcauc.com b.ourcauc.com c.ourcauc.com ;<br>
location / {<br>
proxy_set_header X-Real-IP $remote_addr;<br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>
proxy_set_header Host  $http_host;<br>
proxy_set_header X-Nginx-Proxy true;<br>
proxy_set_header Connection &quot;&quot;;<br>
proxy_pass      http://nodejs;<br>
}<br>
}<br>
域名配置示例<br>
-a	A	123.206.77.88</p>
<p>-b	A	123.206.77.88</p>
<p>-c	A	123.206.77.88</p>
<p>跨站自动匹配替换说明<br>
例如，访问：a.ourcauc.com，该页面里面有一个超链接为10.1.50.202:80,将根据配置文件自动该将url替换为b.ourcauc.com，以达到跨站也可访问的效果，但需要提前在配置文件中配置这些站点。</p>
<p>如需开启，请加配置文件Replace值设置为1</p>
<p>注意：开启可能导致不应该被替换的内容被替换，请谨慎开启</p>
<p>socks5代理模式<br>
场景及原理<br>
原理</p>
<p>主要用于socks5代理，也就是和ss类似，不过是代理内网。使用此模式时，可在非内网环境下配置本机的socks5代理（服务器ip、sock5代理端口），即可实现socks5代理，达到访问内网的网站的效果，配合proxifer等全局代理软件，即可如同使用内网vpn一样，访问内网网站，通过ssh连接内网机器等等……。<br>
<img src="https://newdy.cf/post-images/1581905816245.png" alt="" loading="lazy"><br>
使用<br>
服务端<br>
./easyProxy -mode=sock5ServerServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	代理的http端口（socks5连接端口）<br>
u	验证的用户名<br>
p	验证的密码<br>
说明：用户名和密码验证模式，仅部分socks5客户端支持，例如proxifer。 如需验证，在服务端命令后加上</p>
<p>-u=user -p=password<br>
即可</p>
<p>客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
需要使用内网代理的机器<br>
配置sock5代理即可，ip为外网服务器ip，端口为httpport，即可在外网环境使用内网啦！也可使用proxifer等全局代理软件。<br>
如果设置了用户名和密码，记得填上用户名和密码</p>
<p>http代理模式<br>
场景及原理<br>
<img src="https://newdy.cf/post-images/1581905912887.png" alt="" loading="lazy"><br>
主要用于HTTP代理，区别也就是HTTP代理和sock5代理的区别。使用此模式时，可在非内网环境下配置本机的HTTP代理（服务器ip、HTTP代理端口），即可实现HTTP代理，达到访问内网的网站的效果。</p>
<p>使用<br>
服务端<br>
./easyProxy -mode=httpProxyServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	http代理连接端口<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
需要使用内网代理的机器<br>
配置HTTP代理即可，ip为外网服务器ip，端口为httpport，即可在外网环境访问内网啦！<br>
数据压缩支持<br>
场景及原理<br>
由于是内网穿透，内网客户端与服务端之间的隧道存在大量的数据交换，为节省流量，加快传输速度，由此本程序支持GZIP、SNNAPY两种形式的压缩，两者差异请自行选择。</p>
<p>注意点<br>
所有模式均支持数据压缩<br>
如何使用<br>
GZIP压缩</p>
<p>在server端加上参数 -compress=gzip，例如在TCP隧道模式<br>
./easyProxy -mode tunnelServer -vkey DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024 -target=10.1.50.203:80 -compress=gzip<br>
SNAPPY压缩</p>
<p>将参数修改为snappy即可</p>
<p>操作系统支持<br>
支持Windows、Linux、MacOSX等，无第三方依赖库。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 群晖上监控插件SurveillanceStation 破解255]]></title>
        <id>https://newdy.cf/post/surveillancestation-po-jie-255/</id>
        <link href="https://newdy.cf/post/surveillancestation-po-jie-255/">
        </link>
        <updated>2020-02-17T01:25:11.000Z</updated>
        <content type="html"><![CDATA[<p>安装好群晖的监控工具后！先不要启动把这三个附件解压后<br>
<img src="https://newdy.cf/post-images/1581902779887.jpg" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1581902848427.jpg" alt="" loading="lazy"><br>
sscored权限应该是 755</p>
<p>chmod 755 /var/packages/SurveillanceStation/target/sbin/sscored</p>
]]></content>
    </entry>
</feed>