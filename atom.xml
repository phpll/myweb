<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newdy.cf</id>
    <title>Gridea</title>
    <updated>2020-02-19T04:58:43.317Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newdy.cf"/>
    <link rel="self" href="https://newdy.cf/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://newdy.cf/images/avatar.png</logo>
    <icon>https://newdy.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[生成Nginx服务器SSL证书和客户端证书]]></title>
        <id>https://newdy.cf/post/sheng-cheng-nginx-fu-wu-qi-ssl-zheng-shu-he-ke-hu-duan-zheng-shu/</id>
        <link href="https://newdy.cf/post/sheng-cheng-nginx-fu-wu-qi-ssl-zheng-shu-he-ke-hu-duan-zheng-shu/">
        </link>
        <updated>2020-02-19T04:54:59.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx服务器SSL证书<br>
生成pass key</p>
<p>下面的命令用于生成一个2048bit的pass key, -passout pass:111111 用于避免交互式输入密码</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:111111 -out server.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
...........+++<br>
.....................+++<br>
e is 65537 (0x10001)</p>
<p>生成key</p>
<p>下面的命令用于生成私钥, -passin pass:111111是和pass key的密码对应的, 用于避免交互式输入密码</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:111111 -in server.pass.key -out server.key<br>
writing RSA key</p>
<p>生成证书签发请求文件(CSR)</p>
<p>下面的命令用于生成csr文件, 这里需要填写机构相关信息. 其中CN务必填写为对应的服务器域名. 最后那个challenge password, 是这个csr的password</p>
<h2 id="tomcata02-tmp-openssl-req-new-sha256-key-serverkey-out-servercsryou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -sha256 -key server.key -out server.csr<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:iSomeone<br>
Common Name (eg, your name or your server's hostname) []:internal.someone.com<br>
Email Address []:</p>
<p>Please enter the following 'extra' attributes<br>
to be sent with your certificate request<br>
A challenge password []:222222<br>
An optional company name []:</p>
<p>发送CSR文件给CA服务商签发证书</p>
<p>如果是购买的CA服务商的SSL证书服务, 这一步把CSR发给服务商就可以了. 收到证书后将内容写入到 server.pem 文件</p>
<p>在Nginx上这样配置</p>
<p>server {<br>
listen      443;<br>
server_name  www.example.com;</p>
<pre><code>ssl                  on;
ssl_certificate      /path/to/ssl/server.pem;
ssl_certificate_key  /path/to/ssl/server.key;
ssl_protocols TLSv1.2 TLSv1.1 TLSv1;
ssl_session_cache shared:ssl_www_example_com:5m;
ssl_session_timeout  5m;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:DES-CBC3-SHA;
#...
location / {
    #...
}
#...
</code></pre>
<p>}</p>
<p>制作自签名证书</p>
<p>如果是打算制作自签名证书, 则进行如下的操作生成pem证书</p>
<p>[tomcat@a02 tmp]$ openssl x509 -req -sha256 -days 3655 -in server.csr -signkey server.key -out server.pem<br>
Signature ok<br>
subject=/C=CN/ST=Beijing/L=Chaoyang/O=HenSomeone/OU=iSomeone/CN=internal.someone.com<br>
Getting Private key</p>
<p>Nginx客户端验证证书<br>
Nginx客户端验证证书和服务端SSL证书其实是没关系的, 你可以一边使用CA签发的证书, 一边使用自己制作的客户端验证证书.</p>
<p>生成服务器端私钥</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:201906 -out ca.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
...............................................................................................................+++<br>
...................................+++<br>
e is 65537 (0x10001)</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:201906 -in ca.pass.key -out ca.key<br>
writing RSA key</p>
<p>生成服务器端证书</p>
<p>下面的命令会生成服务器证书ca.pem, 用于配制到nginx.</p>
<h2 id="tomcata02-tmp-openssl-req-new-x509-days-3655-key-cakey-out-capemyou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -x509 -days 3655 -key ca.key -out ca.pem<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:iSomeone<br>
Common Name (eg, your name or your server's hostname) []:internal.someone.com<br>
Email Address []:</p>
<p>生成客户端私钥</p>
<p>[tomcat@a02 tmp]$ openssl genrsa -aes256 -passout pass:201906 -out client_01.pass.key 2048<br>
Generating RSA private key, 2048 bit long modulus<br>
..........................+++<br>
.....+++<br>
e is 65537 (0x10001)</p>
<p>[tomcat@a02 tmp]$ openssl rsa -passin pass:201906 -in client_01.pass.key -out client_01.key<br>
writing RSA key</p>
<p>生成客户端证书签发请求CSR</p>
<h2 id="tomcata02-tmp-openssl-req-new-key-client_01key-out-client_01csryou-are-about-to-be-asked-to-enter-information-that-will-be-incorporatedinto-your-certificate-requestwhat-you-are-about-to-enter-is-what-is-called-a-distinguished-name-or-a-dnthere-are-quite-a-few-fields-but-you-can-leave-some-blankfor-some-fields-there-will-be-a-default-valueif-you-enter-the-field-will-be-left-blank">[tomcat@a02 tmp]$ openssl req -new -key client_01.key -out client_01.csr<br>
You are about to be asked to enter information that will be incorporated<br>
into your certificate request.<br>
What you are about to enter is what is called a Distinguished Name or a DN.<br>
There are quite a few fields but you can leave some blank<br>
For some fields there will be a default value,<br>
If you enter '.', the field will be left blank.</h2>
<p>Country Name (2 letter code) [XX]:CN<br>
State or Province Name (full name) []:Beijing<br>
Locality Name (eg, city) [Default City]:Chaoyang<br>
Organization Name (eg, company) [Default Company Ltd]:HenSomeone<br>
Organizational Unit Name (eg, section) []:Staff<br>
Common Name (eg, your name or your server's hostname) []:Staff<br>
Email Address []:</p>
<p>Please enter the following 'extra' attributes<br>
to be sent with your certificate request<br>
A challenge password []:201907<br>
An optional company name []:</p>
<p>签发客户端证书</p>
<p>下面的命令, 用服务端的私钥和服务端的证书, 对客户端的CSR进行签发, 生成服务端证书. 这里有一个 -set_serial 01 的参数, 如果签发多个客户端证书, 这个数字不能重复</p>
<p>[tomcat@a02 tmp]$ openssl x509 -req -days 3655 -in client_01.csr -CA ca.pem -CAkey ca.key -set_serial 01 -out client_01.pem<br>
Signature ok<br>
subject=/C=CN/ST=Beijing/L=Chaoyang/O=HenSomeone/OU=Staff/CN=Staff<br>
Getting CA Private Key</p>
<p>客户端证书格式转换</p>
<p>前面生成的证书, 不能直接用于常见的应用, 需要转换成应用需要的格式</p>
<p>Full PEM:</p>
<p>[tomcat@a02 tmp]$ cat client_01.key client_01.pem ca.pem &gt; client_01.full.pem</p>
<p>PFX - 这里输入的export password, 就是应用导入PFX证书时需要输入的密码.</p>
<p>[tomcat@a02 tmp]$ openssl pkcs12 -export -out client_01.full.pfx -inkey client_01.key -in client_01.pem -certfile ca.pem<br>
Enter Export Password:<br>
Verifying - Enter Export Password:</p>
<p>配置Nginx的客户端验证证书</p>
<p>ssl_client_certificate /path/to/ca.pem;<br>
ssl_verify_client optional; # or <code>on</code> if you require client key</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx配置中location匹配规则详解]]></title>
        <id>https://newdy.cf/post/nginx-pei-zhi-zhong-location-pi-pei-gui-ze-xiang-jie/</id>
        <link href="https://newdy.cf/post/nginx-pei-zhi-zhong-location-pi-pei-gui-ze-xiang-jie/">
        </link>
        <updated>2020-02-19T04:48:02.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx 的语法形式是： location [=|<sub>|</sub><em>|^~|@] /uri/ { … } ，意思是可以以“ = ”或“ ~</em> ”或“ ~ ”或“ ^~ ”或“ @ ”符号为前缀，当然也可以没有前缀（因为 [A] 是表示可选的 A ； A|B 表示 A 和 B 选一个），紧接着是 /uri/ ，再接着是{…} 指令块，整个意思是对于满足这样条件的 /uri/ 适用指令块 {…} 的指令。</p>
<p>上述各种 location 可分两大类，分别是：“普通 location ”，官方英文说法是 location using   literal strings 和“正则 location ”，英文说法是 location using regular expressions 。其中“普通 location ”是以“ = ”或“ ^~ ”为前缀或者没有任何前缀的 /uri/ ；“正则 location ”是以“ ~ ”或“ ~* ”为前缀的 /uri/ 。</p>
<p>那么，当我们在一个 server 上下文编写了多个 location 的时候， Nginx 对于一个 HTTP 请求，是如何匹配到一个 location 做处理呢？用一句话简单概括 Nginx 的 location 匹配规则是：“正则 location ”让步 “普通 location”的严格精确匹配结果；但覆盖 “普通 location ”的最大前缀匹配结果。理解这句话，我想通过下面的实例来说明。</p>
<p>#1 先普通 location ，再正则 location<br>
周边不少童鞋告诉我， nginx 是“先匹配正则 location 再匹配普通 location ”，其实这是一个误区， nginx 其实是“先匹配普通 location ，再匹配正则 location ”，但是普通 location 的匹配结果又分两种：一种是“严格精确匹配”，官方英文说法是“ exact match ”；另一种是“最大前缀匹配”，官方英文说法是“ Literal strings match the beginning portion of the query – the most specific match will be used. ”。我们做个实验：</p>
<p>例题 1 ：假设 nginx 的配置如下</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>附录 nginx 的目录结构是： nginx-&gt;html-&gt;index.html</p>
<p>上述配置的意思是： location / {… deny all;} 普通 location 以“ / ”开始的 URI 请求（注意任何 HTTP 请求都必然以“/ ”开始，所以“ / ”的意思是所有的请求都能被匹配上），都拒绝访问； location ~.html$ {allow all;} 正则 location以 .html 结尾的 URI 请求，都允许访问。</p>
<p>测试结果：</p>
<p>[root@web108 ~]# curl http://localhost:9090/</p>
<html>
<head><title>403 Forbidden</title></head>
<body bgcolor=”white”>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]# curl http://localhost:9090/index.html</p>
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor=”white” text=”black”>
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
<p>[root@web108 ~]# curl http://localhost:9090/index_notfound.html</p>
<html>
<head><title>404 Not Found</title></head>
<body bgcolor=”white”>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>测试结果如下：</p>
<p>URI 请求	HTTP 响应<br>
curl http://localhost:9090/	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!<br>
curl http://localhost:9090/index_notfound.html	404 Not Found<br>
curl http://localhost:9090/ 的结果是“ 403 Forbidden ”，说明被匹配到“ location / {..deny all;} ”了，原因很简单HTTP 请求 GET / 被“严格精确”匹配到了普通 location / {} ，则会停止搜索正则 location ；</p>
<p>curl http://localhost:9090/index.html 结果是“ Welcome to nginx! ”，说明没有被“ location / {…deny all;} ”匹配，否则会 403 Forbidden ，但 /index.html 的确也是以“ / ”开头的，只不过此时的普通 location / 的匹配结果是“最大前缀”匹配，所以 Nginx 会继续搜索正则 location ， location ~ .html$ 表达了以 .html 结尾的都 allow all; 于是接着就访问到了实际存在的 index.html 页面。</p>
<p>curl http://localhost:9090/index_notfound.html   同样的道理先匹配 location / {} ，但属于“普通 location 的最大前缀匹配”，于是后面被“正则 location ” location ~ .html$ {} 覆盖了，最终 allow all ； 但的确目录下不存在index_notfound.html 页面，于是 404 Not Found 。</p>
<p>如果此时我们访问 http://localhost:9090/index.txt 会是什么结果呢？显然是 deny all ；因为先匹配上了 location / {..deny all;} 尽管属于“普通 location ”的最大前缀匹配结果，继续搜索正则 location ，但是 /index.txt 不是以 .html结尾的，正则 location 失败，最终采纳普通 location 的最大前缀匹配结果，于是 deny all 了。</p>
<p>[root@web108 ~]# curl http://localhost:9090/index.txt</p>
<html>
<head><title>403 Forbidden</title></head>
<body bgcolor=”white”>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>#2 普通 location 的“隐式”严格匹配<br>
例题 2 ：我们在例题 1 的基础上增加精确配置</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

              location / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>测试请求：</p>
<p>[root@web108 ~]# curl http://localhost:9090/exact/match.html</p>
<html>
<head><title>404 Not Found</title></head>
<body bgcolor=”white”>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.1.0</center>
</body>
</html>
<p>[root@web108 ~]#</p>
<p>结果进一步验证了“普通 location ”的“严格精确”匹配会终止对正则 location 的搜索。这里我们小结下“普通 location”与“正则 location ”的匹配规则：先匹配普通 location ，再匹配正则 location ，但是如果普通 location 的匹配结果恰好是“严格精确（ exact match ）”的，则 nginx 不再尝试后面的正则 location ；如果普通 location 的匹配结果是“最大前缀”，则正则 location 的匹配覆盖普通 location 的匹配。也就是前面说的“正则 location 让步普通location 的严格精确匹配结果，但覆盖普通 location 的最大前缀匹配结果”。</p>
<p>#3 普通 location 的“显式”严格匹配和“ ^~ ” 前缀<br>
上面我们演示的普通 location 都是不加任何前缀的，其实普通 location 也可以加前缀：“ ^~ ”和“ = ”。其中“ ^~”的意思是“非正则，不需要继续正则匹配”，也就是通常我们的普通 location ，还会继续搜索正则 location （恰好严格精确匹配除外），但是 nginx 很人性化允许配置人员告诉 nginx 某条普通 location ，无论最大前缀匹配，还是严格精确匹配都终止继续搜索正则 location ；而“ = ”则表达的是普通 location 不允许“最大前缀”匹配结果，必须严格等于，严格精确匹配。</p>
<p>例题 3 ：“ ^~ ”前缀的使用</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

             location ^~ / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>把例题 2 中的 location / {} 修改成 location ^~ / {} ，再看看测试结果：</p>
<p>URI 请求	修改前	修改后<br>
curl http://localhost:9090/	403 Forbidden	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!	403 Forbidden<br>
curl http://localhost:9090/index_notfound.html	404 Not Found	403 Forbidden<br>
curl http://localhost:9090/exact/match.html	404 Not Found	404 Not Found<br>
除了 GET /exact/match.html 是 404 Not Found ，其余都是 403 Forbidden ，原因很简单所有请求都是以“ / ”开头，所以所有请求都能匹配上“ / ”普通 location ，但普通 location 的匹配原则是“最大前缀”，所以只有/exact/match.html 匹配到 location /exact/match.html {allow all;} ，其余都 location ^~ / {deny all;} 并终止正则搜索。</p>
<p>例题 4 ：“ = ”前缀的使用</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

              location /exact/match.html {

       allow all;

   }

             location = / {

       root   html;

       index  index.html index.htm;

       deny all;

   }

   location ~ \.html$ {

       allow all;

   }
</code></pre>
<p>}</p>
<p>例题 4 相对例题 2 把 location / {} 修改成了 location = / {} ，再次测试结果：</p>
<p>URI 请求	修改前	修改后<br>
curl http://localhost:9090/	403 Forbidden	403 Forbidden<br>
curl http://localhost:9090/index.html	Welcome to nginx!	Welcome to nginx!<br>
curl http://localhost:9090/index_notfound.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/exact/match.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/test.jsp	403 Forbidden	404 Not Found<br>
最能说明问题的测试是 GET /test.jsp ，实际上 /test.jsp 没有匹配正则 location （ location ~.html$ ），也没有匹配 location = / {} ，如果按照 location / {} 的话，会“最大前缀”匹配到普通 location / {} ，结果是 deny all 。</p>
<p>#4 正则 location 与编辑顺序<br>
location 的指令与编辑顺序无关，这句话不全对。对于普通 location 指令，匹配规则是：最大前缀匹配（与顺序无关），如果恰好是严格精确匹配结果或者加有前缀“ ^~ ”或“ = ”（符号“ = ”只能严格匹配，不能前缀匹配），则停止搜索正则 location ；但对于正则 location 的匹配规则是：按编辑顺序逐个匹配（与顺序有关），只要匹配上，就立即停止后面的搜索。</p>
<p>配置 3.1</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

   location ~ \.html$ {

       allow all; 

   } 

   location ~ ^/prefix/.*\.html$ {

       deny all; 

   } 
</code></pre>
<p>}</p>
<p>配置 3.2</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

 

   location ~ ^/prefix/.*\.html$ {

       deny all; 

   } 

             

              location ~ \.html$ {

       allow all; 

   } 
</code></pre>
<p>}</p>
<p>测试结果：</p>
<p>URI 请求	配置 3.1	配置 3.2<br>
curl http://localhost:9090/regextest.html	404 Not Found	404 Not Found<br>
curl http://localhost:9090/prefix/regextest.html	404 Not Found	403 Forbidden<br>
解释：</p>
<p>Location ~ ^/prefix/.*.html$ {deny all;} 表示正则 location 对于以 /prefix/ 开头， .html 结尾的所有 URI 请求，都拒绝访问；   location ~.html<span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\.&#039; in math mode at position 71: …实际上，prefix 的是 ~\̲.̲html'>{allow all;} 表示正则 location 对于以 .html 结尾的 URI 请求，都允许访问。 实际上，prefix 的是 ~\.html</span> 的子集。</p>
<p>在“配置 3.1 ”下，两个请求都匹配上 location ~.html$ {allow all;} ，并且停止后面的搜索，于是都允许访问， 404 Not Found ；在“配置 3.2 ”下， /regextest.html 无法匹配 prefix ，于是继续搜索 ~.html$ ，允许访问，于是 404 Not Found ；然而 /prefix/regextest.html 匹配到 prefix ，于是 deny all ， 403 Forbidden 。</p>
<p>配置 3.3</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

   location  /prefix/ {

           deny all; 

   } 

     

   location  /prefix/mid/ {

           allow all; 

   } 
</code></pre>
<p>}</p>
<p>配置 3.4</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

 

   location  /prefix/mid/ {

           allow all; 

   } 

              location  /prefix/ {

           deny all; 

   } 
</code></pre>
<p>}</p>
<p>测试结果：</p>
<p>URI 请求	配置 3.1	配置 3.2<br>
curl http://localhost:9090/prefix/t.html	  403 Forbidden    	403 Forbidden<br>
curl http://localhost:9090/prefix/mid/t.html	404 Not Found	404 Not Found<br>
测试结果表明：普通 location 的匹配规则是“最大前缀”匹配，而且与编辑顺序无关。</p>
<p>#5 “@” 前缀 Named Location 使用<br>
REFER:  http://wiki.nginx.org/HttpCoreModule#error_page</p>
<p>假设配置如下：</p>
<p>server {</p>
<pre><code>   listen       9090;

   server_name  localhost;

    location  / {

       root   html;

       index  index.html index.htm;

       allow all;

   }

   #error_page 404 http://www.baidu.com # 直接这样是不允许的

   error_page 404 = @fallback;

   location @fallback {

       proxy_pass http://www.baidu.com;

   }
</code></pre>
<p>}</p>
<p>上述配置文件的意思是：如果请求的 URI 存在，则本 nginx 返回对应的页面；如果不存在，则把请求代理到baidu.com 上去做个弥补（注： nginx 当发现 URI 对应的页面不存在， HTTP_StatusCode 会是 404 ，此时error_page 404 指令能捕获它）。</p>
<p>测试一：</p>
<p>[root@web108 ~]# curl http://localhost:9090/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:17:21 GMT</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<p>Location: http://localhost:9090/search/error.html</p>
<p>Connection: keep-alive</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:17:21 GMT</p>
<p>Content-Length: 222</p>
<!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href=”http://www.baidu.com/search/error.html”>here</a>.</p>
</body></html>
<p>[root@web108 ~]#</p>
<p>当我们 GET /nofound.html 发送给本 nginx ， nginx 找不到对应的页面，于是 error_page 404 = @fallback ，请求被代理到 http://www.baidu.com ，于是 nginx 给 http://www.baidu.com 发送了 GET /nofound.html ，但/nofound.html 页面在百度也不存在，百度 302 跳转到错误页。</p>
<p>直接访问 http://www.baidu.com/nofound.html 结果：</p>
<p>[root@web108 ~]# curl http://www.baidu.com/nofound.html -i</p>
<p>HTTP/1.1 302 Found</p>
<p>Date: Sat, 06 Aug 2011 08:20:05 GMT</p>
<p>Server: Apache</p>
<p>Location: http://www.baidu.com/search/error.html</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:20:05 GMT</p>
<p>Content-Length: 222</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html; charset=iso-8859-1</p>
<!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”>
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved <a href=”http://www.baidu.com/search/error.html”>here</a>.</p>
</body></html>
<p>[root@web108 ~]#</p>
<p>测试二：访问一个 nginx 不存在，但 baidu 存在的页面</p>
<p>[root@web108 ~]# curl http://www.baidu.com/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Date: Sat, 06 Aug 2011 08:21:56 GMT</p>
<p>Server: Apache</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A0C88CA7075A6601A:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=5C5D2B2FD083737A2337F78F909CCB90:FG=1; expires=Sun, 05-Aug-12 08:21:56 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: “d66-49913b8efe340″</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:21:56 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<p>Connection: Keep-Alive</p>
<p>Content-Type: text/html</p>
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”

“http://www.w3.org/TR/html4/loose.dtd”>
<p>。。。。</p>
</body>
</html>
<p>显示，的确百度这个页面是存在的。</p>
<p>[root@web108 ~]# curl http://localhost:9090/duty/ -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: nginx/1.1.0</p>
<p>Date: Sat, 06 Aug 2011 08:23:23 GMT</p>
<p>Content-Type: text/html</p>
<p>Connection: keep-alive</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>P3P: CP=” OTI DSP COR IVA OUR IND COM ”</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277DCB4CC5F80B7F457:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Set-Cookie: BAIDUID=8FEF0A3A2C31D277B1F87691AFFD7440:FG=1; expires=Sun, 05-Aug-12 08:23:23 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1</p>
<p>Last-Modified: Wed, 05 Jan 2011 06:44:53 GMT</p>
<p>ETag: “d66-49913b8efe340″</p>
<p>Accept-Ranges: bytes</p>
<p>Content-Length: 3430</p>
<p>Cache-Control: max-age=86400</p>
<p>Expires: Sun, 07 Aug 2011 08:23:23 GMT</p>
<p>Vary: Accept-Encoding,User-Agent</p>
<!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”

“http://www.w3.org/TR/html4/loose.dtd”>
<html>
<p>。。。</p>
</body>
</html>
<p>当 curl http://localhost:9090/duty/ -i 时， nginx 没找到对应的页面，于是 error_page = @fallback ，把请求代理到 baidu.com 。注意这里的 error_page = @fallback 不是靠重定向实现的，而是所说的“ internally redirected （forward ）”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx七层负载均衡的几种调度算法]]></title>
        <id>https://newdy.cf/post/nginx-qi-ceng-fu-zai-jun-heng-de-ji-chong-diao-du-suan-fa/</id>
        <link href="https://newdy.cf/post/nginx-qi-ceng-fu-zai-jun-heng-de-ji-chong-diao-du-suan-fa/">
        </link>
        <updated>2020-02-19T04:44:25.000Z</updated>
        <content type="html"><![CDATA[<p>Nginx是一款轻量级的高性能web服务器，同时也是一款非常优秀的负载均衡器和反向代理服务器。由于支持强大的正则匹配规则、动静分离、URLrewrite功能及安装配置简单且对网络稳定性依赖非常小等优点，所以常用来做为七层负载均衡使用。在硬件不差的情况下，通常可以稳定支持几万的并发连接，在硬件性能足够好，且对系统内核参数及Nginx配置进行优化甚至可以达到10万以上的并发。</p>
<p>以下是Nginx作为七层负载均衡常用的几种调度算法和适用的业务场景</p>
<p>1、轮询（默认调度算法）</p>
<p>特点：每个请求按时间顺序逐一分配到不同的后端服务器处理。<br>
适用业务场景：后端服务器硬件性能配置完全一致，业务无特殊要求时使用。<br>
upstream backendserver {<br>
server 192.168.0.14：80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15：80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>2、加权轮询</p>
<p>特点：指定轮询几率，weight值(权重)和访问比例成正比，用户请求按权重比例分配。<br>
适用业务场景：用于后端服务器硬件性处理能力不平均的情形。<br>
upstream backendserver {<br>
server 192.168.0.14:80 weight=5 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 weight=10 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>3、ip_hash</p>
<p>特点：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session会话保持问题。<br>
适用业务场景：适用于需要账号登录的系统，会话连接保持的业务。<br>
upstream backendserver {<br>
ip_hash;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>4、最少连接数 least_conn</p>
<p>特点：按nginx反向代理与后端服务器之间的连接数，连接数最少的优先分配。</p>
<p>适用业务场景：适用于客户端与后端服务器需要保持长连接的业务。<br>
upstream backendserver {<br>
least_conn;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>5、fair（需编译安装第三方模块 ngx_http_upstream_fair_module）</p>
<p>特点：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>
适用业务场景：对访问响应速度有一定要求的业务。<br>
upstream backendserver {<br>
fair;<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
}</p>
<p>6、url_hash（需编译安装第三方模块 ngx_http_upstream_hash_module）</p>
<p>特点：按访问url的hash结果来分配请求，使同一个url访问到同一个后端服务器。<br>
适用业务场景：适用于后端服务器为缓存服务器时比较有效。<br>
upstream backendserver {<br>
server 192.168.0.14:80 max_fails=2 fail_timeout=10s;<br>
server 192.168.0.15:80 max_fails=2 fail_timeout=10s;<br>
hash $request_uri;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux CentOS 7 非root用户安装源码版Docker]]></title>
        <id>https://newdy.cf/post/linux-centos-7-fei-root-yong-hu-an-zhuang-yuan-ma-ban-docker/</id>
        <link href="https://newdy.cf/post/linux-centos-7-fei-root-yong-hu-an-zhuang-yuan-ma-ban-docker/">
        </link>
        <updated>2020-02-19T04:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>注意:非root用户必须要有sudo权限</p>
<p>一、安装前的准备</p>
<p>1.查看当前主机是否有docker组</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582087080673.png" alt="" loading="lazy"></figure>
<p>若没有输出结果则新建</p>
<figure data-type="image" tabindex="2"><img src="https://newdy.cf/post-images/1582087086554.png" alt="" loading="lazy"></figure>
<p>再次查看,发现已经有了docker组</p>
<figure data-type="image" tabindex="3"><img src="https://newdy.cf/post-images/1582087091705.png" alt="" loading="lazy"></figure>
<p>2.新增拥有sudo权限的用户(若知道root和其他拥有sudo权限的系统用户密码,跳到3;若都没有,必做)</p>
<figure data-type="image" tabindex="4"><img src="https://newdy.cf/post-images/1582087133234.png" alt="" loading="lazy"></figure>
<p>修改该用户的密码<br>
<img src="https://newdy.cf/post-images/1582087138797.png" alt="" loading="lazy"></p>
<p>为新增的用户添加sudo权限</p>
<p>sudo vi /etc/sudoers<br>
　　在92行下一行添加<br>
　　test    　　ALL=(ALL)    　　ALL<br>
3.把当前用户加入到docker组 （此时用户并没有加入进docker组）</p>
<figure data-type="image" tabindex="5"><img src="https://newdy.cf/post-images/1582087165679.png" alt="" loading="lazy"></figure>
<p>切换至sudo权限用户，然后再切换回当前用户（此时可以看到用户已经加入docker组）</p>
<figure data-type="image" tabindex="6"><img src="https://newdy.cf/post-images/1582087175735.png" alt="" loading="lazy"></figure>
<p>3.删除新增的用户和它的sudo权限（第2步没做请忽略此步）</p>
<p>sudo vi /etc/sudoers<br>
　　在92行下一行添加<br>
　　test　　ALL=(ALL)  ALL<br>
两次退出，不然删除用户时会报错</p>
<figure data-type="image" tabindex="7"><img src="https://newdy.cf/post-images/1582087195961.png" alt="" loading="lazy"></figure>
<p>二、安装docker</p>
<p>1.下载docker源码包并上传至虚拟机</p>
<p>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.09.0.tgz</p>
<p>2.解压源码包至指定目录下</p>
<figure data-type="image" tabindex="8"><img src="https://newdy.cf/post-images/1582087215827.png" alt="" loading="lazy"></figure>
<p>3.将解压出来的docker目录下的指令复制到 /usr/bin/ 目录下</p>
<p>sudo cp docker/* /usr/bin/<br>
4./usr/bin/目录下docker有关指令的所属用户和所属组(必做,不然非root用户使用docker指令报错:权限不够)</p>
<p>sudo chown root:docker /usr/bin/docker*<br>
sudo chown root:docker /usr/bin/containerd*<br>
sudo chown root:docker /usr/bin/runc<br>
sudo chown root:docker /usr/bin/ctr<br>
5.查看一下是否改变所属用户和所属组(得到和解压出来的docker目录下的一样的8个指令)</p>
<figure data-type="image" tabindex="9"><img src="https://newdy.cf/post-images/1582087235444.png" alt="" loading="lazy"></figure>
<p>6.将docker注册为service服务</p>
<p>新建该文件<br>
sudo vi /etc/systemd/system/docker.service<br>
加入以下内容：<br>
[Unit]<br>
Description=Docker Application Container Engine<br>
Documentation=https://docs.docker.com<br>
After=network-online.target firewalld.service<br>
Wants=network-online.target</p>
<p>[Service]<br>
Type=notify<br>
ExecStart=/usr/bin/dockerd<br>
ExecReload=/bin/kill -s HUP $MAINPID<br>
LimitNOFILE=infinity<br>
LimitNPROC=infinity<br>
LimitCORE=infinity<br>
TimeoutStartSec=0<br>
Delegate=yes<br>
KillMode=process<br>
Restart=on-failure<br>
StartLimitBurst=3<br>
StartLimitInterval=60s</p>
<p>[Install]<br>
WantedBy=multi-user.target<br>
7.添加执行权限并重新加载配置文件</p>
<p>sudo chmod a+x /etc/systemd/system/docker.service<br>
sudo systemctl daemon-reloa<br>
8.docker镜像加速(可以不做,但是docker pull会很慢,由于docker官网在海外)</p>
<p>新建该文件<br>
sudo vi /etc/docker/daemon.json<br>
加入以下内容<br>
{<br>
&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]<br>
}</p>
<p>9.启动docker</p>
<p>sudo systemctl start docker<br>
三、docker基础命令</p>
<p>docker启/停/重启/查看状态<br>
sudo systemctl  start/stop/restart/status</p>
<p>查看docker已有镜像<br>
docker images</p>
<p>在docker官网搜寻指定镜像<br>
docker search 镜像</p>
<p>下载镜像(不加标签默认下载最新版本的镜像)<br>
docker pull 镜像名字:tag(即标签)</p>
<p>启动容器(以xxx名字运行基于镜像的容器，并映射容器端口到本机端口，容器目录文件储存在本机目录)<br>
docker run -d -name xxx -p 本机端口:容器端口 -v 本机目录:容器目录 镜像name:tag(或ID)</p>
<p>进入正在运行的容器内部<br>
docker exec -it 容器name(或ID) /bin/bash</p>
<p>容器的启/停/重启/信息/删除<br>
docker start/stop/restart/inspect/rm 容器name(或ID)</p>
<p>查看正在运行的容器<br>
docker ps</p>
<p>查看所有容器(包括正在运行的、停止的,不包括删除的)<br>
docker ps -a</p>
<p>镜像的删除(删除镜像前请删除所有与该镜像有关的容器)<br>
docker rmi 镜像name:tag(或ID)</p>
<p>查看当前安装的docker有关信息<br>
docker info<br>
dd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows10下nginx的rtmp服务器搭建]]></title>
        <id>https://newdy.cf/post/windows10-xia-nginx-de-rtmp-fu-wu-qi-da-jian/</id>
        <link href="https://newdy.cf/post/windows10-xia-nginx-de-rtmp-fu-wu-qi-da-jian/">
        </link>
        <updated>2020-02-19T04:28:12.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>下载 nginx 1.7.11.3 Gryphon<br>
    下载链接: http://nginx-win.ecsds.eu/download/nginx 1.7.11.3 Gryphon.zip，下载完成后解压， 将解压后的目录命名为</li>
</ol>
<p>nginx-1.7.11.3-Gryphon<br>
2. 下载服务器状态检查程序 stat.xsl（注：直接clone到nginx-1.7.11.3-Gryphon目录下）</p>
<p>下载地址https://github.com/arut/nginx-rtmp-module/</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582086527036.png" alt="" loading="lazy"></figure>
<ol>
<li>配置文件 conf\nginx-win-rtmp.conf 内容如下:（注：用记事本打开直接复制粘贴，避免编码格式引起错误）</li>
</ol>
<p>#user  nobody;</p>
<h1 id="multiple-workers-works">multiple workers works !</h1>
<p>worker_processes  2;</p>
<p>#error_log  logs/error.log;<br>
#error_log  logs/error.log  notice;<br>
#error_log  logs/error.log  info;</p>
<p>#pid        logs/nginx.pid;</p>
<p>events {<br>
worker_connections  8192;<br>
# max value 32768, nginx recycling connections+registry optimization =<br>
#   this.value * 20 = max concurrent connections currently tested with one worker<br>
#   C1000K should be possible depending there is enough ram/cpu power<br>
# multi_accept on;<br>
}</p>
<p>rtmp {<br>
server {<br>
listen 1935;<br>
chunk_size 4000;<br>
application live {<br>
live on;</p>
<pre><code>         # record first 1K of stream
         record all;
         record_path /tmp/av;
         record_max_size 1K;

         # append current timestamp to each flv
         record_unique on;

         # publish only from localhost
         allow publish 127.0.0.1;
         deny publish all;

         #allow play all;
    }
}
</code></pre>
<p>}</p>
<p>http {<br>
#include      /nginx/conf/naxsi_core.rules;<br>
include       mime.types;<br>
default_type  application/octet-stream;</p>
<pre><code>#log_format  main  '$remote_addr:$remote_port - $remote_user [$time_local] &quot;$request&quot; '
#                  '$status $body_bytes_sent &quot;$http_referer&quot; '
#                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

#access_log  logs/access.log  main;
</code></pre>
<h1 id="loadbalancing-php"># loadbalancing PHP</h1>
<h1 id="upstream-myloadbalancer">upstream myLoadBalancer {</h1>
<h1 id="server-1270019001-weight1-fail_timeout5">server 127.0.0.1:9001 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019002-weight1-fail_timeout5">server 127.0.0.1:9002 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019003-weight1-fail_timeout5">server 127.0.0.1:9003 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019004-weight1-fail_timeout5">server 127.0.0.1:9004 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019005-weight1-fail_timeout5">server 127.0.0.1:9005 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019006-weight1-fail_timeout5">server 127.0.0.1:9006 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019007-weight1-fail_timeout5">server 127.0.0.1:9007 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019008-weight1-fail_timeout5">server 127.0.0.1:9008 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019009-weight1-fail_timeout5">server 127.0.0.1:9009 weight=1 fail_timeout=5;</h1>
<h1 id="server-1270019010-weight1-fail_timeout5">server 127.0.0.1:9010 weight=1 fail_timeout=5;</h1>
<h1 id="least_conn">least_conn;</h1>
<h1 id="">}</h1>
<pre><code>sendfile        off;
#tcp_nopush     on;

server_names_hash_bucket_size 128;
</code></pre>
<h2 id="start-timeouts">Start: Timeouts</h2>
<pre><code>client_body_timeout   10;
client_header_timeout 10;
keepalive_timeout     30;
send_timeout          10;
keepalive_requests    10;
</code></pre>
<h2 id="end-timeouts">End: Timeouts</h2>
<pre><code>#gzip  on;

server {
    listen       80;
    server_name  localhost;


    location /stat {
        rtmp_stat all;
        rtmp_stat_stylesheet stat.xsl;
    }
    location /stat.xsl {
        root nginx-rtmp-module/;
    }
    location /control {
        rtmp_control all;
    }

    #charset koi8-r;
    #access_log  logs/host.access.log  main;

    ## Caching Static Files, put before first location
    #location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
    #    expires 14d;
    #    add_header Vary Accept-Encoding;
    #}
</code></pre>
<h1 id="for-naxsi-remove-the-single-line-for-learn-mode-or-the-lines-for-full-waf-mode">For Naxsi remove the single # line for learn mode, or the ## lines for full WAF mode</h1>
<pre><code>    location / {
        #include    /nginx/conf/mysite.rules; # see also http block naxsi include line
        ##SecRulesEnabled;
     ##DeniedUrl &quot;/RequestDenied&quot;;
     ##CheckRule &quot;$SQL &gt;= 8&quot; BLOCK;
     ##CheckRule &quot;$RFI &gt;= 8&quot; BLOCK;
     ##CheckRule &quot;$TRAVERSAL &gt;= 4&quot; BLOCK;
     ##CheckRule &quot;$XSS &gt;= 8&quot; BLOCK;
        root   html;
        index  index.html index.htm;
    }
</code></pre>
<h1 id="for-naxsi-remove-the-lines-for-full-waf-mode-redirect-location-block-used-by-naxsi">For Naxsi remove the ## lines for full WAF mode, redirect location block used by naxsi</h1>
<pre><code>    ##location /RequestDenied {
    ##    return 412;
    ##}
</code></pre>
<h2 id="lua-examples">Lua examples !</h2>
<h1 id="location-robotstxt">location /robots.txt {</h1>
<h1 id="rewrite_by_lua">rewrite_by_lua '</h1>
<h1 id="if-ngxvarhttp_host-~-localhost-then">if ngx.var.http_host ~= &quot;localhost&quot; then</h1>
<h1 id="return-ngxexecrobots_disallowtxt">return ngx.exec(&quot;/robots_disallow.txt&quot;);</h1>
<h1 id="end">end</h1>
<h1 id="-2">';</h1>
<h1 id="-3">}</h1>
<pre><code>    #error_page  404              /404.html;
    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }
    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}
    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000; # single backend process
    #    fastcgi_pass   myLoadBalancer; # or multiple, see example above
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    #    include        fastcgi_params;
    #}
    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
# another virtual host using mix of IP-, name-, and port-based configuration
#
#server {
#    listen       8000;
#    listen       somename:8080;
#    server_name  somename  alias  another.alias;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
# HTTPS server
#
#server {
#    listen       443 ssl spdy;
#    server_name  localhost;
#    ssl                  on;
#    ssl_certificate      cert.pem;
#    ssl_certificate_key  cert.key;
#    ssl_session_timeout  5m;
#    ssl_prefer_server_ciphers On;
#    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
#    ssl_ciphers ECDH+AESGCM:ECDH+AES256:ECDH+AES128:ECDH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!eNULL:!MD5:!DSS:!EXP:!ADH:!LOW:!MEDIUM;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
</code></pre>
<p>}<br>
4. 启动服务器</p>
<p>nginx.exe -c conf\nginx-win-rtmp.conf<br>
5.使用ffmpeg、ffplay进行推流拉流验证（直接ffmpeg官方下载windows下的可执行文件）</p>
<p>5.1推流测试，使用ffmpeg命令完成即可</p>
<p>ffmpeg.exe -re -i inputfile.mp4 -vcodec libx264 -acodec aac -f flv rtmp://localhost:1935/live/home<br>
5.2拉流测试，使用ffplay命令完成即可<br>
—————————————<br>
ffplay.exe rtmp://localhost:1935/live/home<br>
<img src="https://newdy.cf/post-images/1582086643460.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx-rtmp+ FFmpeg +Docker + vue.js 直播系统搭建]]></title>
        <id>https://newdy.cf/post/nginx-rtmp-ffmpeg-docker-vuejs-zhi-bo-xi-tong-da-jian/</id>
        <link href="https://newdy.cf/post/nginx-rtmp-ffmpeg-docker-vuejs-zhi-bo-xi-tong-da-jian/">
        </link>
        <updated>2020-02-19T04:23:35.000Z</updated>
        <content type="html"><![CDATA[<p>思路（如图）：<br>
<img src="https://newdy.cf/post-images/1582086243575.jpg" alt="" loading="lazy"><br>
1，开启推流服务器（这里我的Nginx-rtmp服务器搭建成功）</p>
<p>进入docker 开启推流服务器  docker run -it -p 1935:1935 -p 8000:80 --rm alfg/nginx-rtmp</p>
<figure data-type="image" tabindex="1"><img src="https://newdy.cf/post-images/1582086272172.jpg" alt="" loading="lazy"></figure>
<p>2，推流（两种方法）</p>
<p>命令推流：</p>
<p>查看本机摄像头及麦克风设备 ffmpeg -list_devices true -f dshow -i dummy</p>
<p>音视频推流： ffmpeg -f dshow -i video=&quot;VMware Virtual USB Video Device&quot;:audio=&quot;Microphone (High Definition Audio Device)&quot; -tune:v zerolatency -f flv &quot;rtmp://192.168.99.100:1935/stream/test&quot;</p>
<p>#推流视频文件<br>
ffmpeg -re -stream_loop -1 -i test.mp4 -f flv rtmp://192.168.99.100:1935/stream/test<br>
播放地址http://192.168.99.100:8000/live/test.m3u8</p>
<p>#将摄像头推流到hls<br>
ffmpeg -f vfwcap  -i &quot;0&quot; -c:v libx264 -preset ultrafast  -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp://localhost:1935/hls/home<br>
播放地址http://localhost:8080/hls/home.m3u8</p>
<p>#将屏幕推流到rtmp<br>
start ffmpeg -f gdigrab -i desktop -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv<br>
播放地址rtmp://localhost:1935/live/jing<br>
使用第三方软件推流：（例如：OBS Studio）</p>
<p>3，拉流</p>
<p>这里前端使用的是通过VUE</p>
<p>注意使用video需安装以下几个依赖</p>
<p>cnpm install video.js<br>
cnpm install aes-decrypter<br>
cnpm install m3u8-parser<br>
cnpm install mpd-parser<br>
cnpm install mux.js<br>
cnpm install url-toolkit<br>
cnpm install videojs-contrib-hls</p>
<video id="my-video" class="video-js vjs-default-skin" controls preload="auto" >
                                        <source src="http://192.168.99.100:8000/live/test.m3u8" type="application/x-mpegURL">
                                </video>
<script>
        //vue 的video插件
            import videojs from 'video.js'
            import 'videojs-contrib-hls'

    export default {
    mounted:function(){
                    //自动执行直播平台
                    videojs('my-video', {
                    bigPlayButton: false,
                    textTrackDisplay: false,
                    posterImage: true,
                    errorDisplay: false,
                    controlBar: true
            }, function () {
                    this.play()
            })
        }
    }
}



</script>
<p>效果如下：<br>
<img src="https://newdy.cf/post-images/1582086327475.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EasyProxy-又一款有管理面板的内网穿透代理服务器]]></title>
        <id>https://newdy.cf/post/easyproxy-you-yi-kuan-you-guan-li-mian-ban-de-nei-wang-chuan-tou-dai-li-fu-wu-qi/</id>
        <link href="https://newdy.cf/post/easyproxy-you-yi-kuan-you-guan-li-mian-ban-de-nei-wang-chuan-tou-dai-li-fu-wu-qi/">
        </link>
        <updated>2020-02-17T02:11:45.000Z</updated>
        <content type="html"><![CDATA[<p>easyProxy是一款轻量级、高性能、功能最为强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理，可实现在非内网环境下如同使用vpn一样访问内网资源和设备的效果，同时支持socks5验证，gzip、snnapy压缩（节省带宽和流量）。</p>
<p>目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。<br>
支持客户端与服务端连接中断自动重连，多路传输，大大的提高请求处理速度，go语言编写，无第三方依赖。<br>
<img src="https://newdy.cf/post-images/1581905568218.png" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1581905601275.png" alt="" loading="lazy"><br>
一、简介<br>
web管理模式，可配置多条tcp、udp隧道，多个域名代理等等—-&gt; web管理模式<br>
内网多站点配合代理。—-&gt; http反向代理请求<br>
想在外网通过ssh连接内网的机器，做云服务器到内网服务器端口的映射，或者做微信公众号开发、小程序开发等—-&gt;tcp隧道模式<br>
在非内网环境下使用内网dns，或者需要通过udp访问内网机器等—-&gt;udp隧道模式<br>
在外网使用HTTP代理访问内网站点—-&gt;http代理模式<br>
搭建一个内网穿透ss，在外网如同使用内网vpn一样访问内网资源或者设备—-&gt; socks5代理模式<br>
二、特点<br>
支持gzip、snappy压缩,减小传输过程流量消耗<br>
支持多站点配置,兼容多个内网网站，可处理相互之间的跳转包含关系<br>
断线自动重连<br>
支持多路传输,提高并发<br>
跨站自动匹配替换<br>
支持tcp隧道,提升访问效率<br>
支持udp隧道<br>
支持http代理<br>
支持内网穿透sock5代理，配合proxifer可达到vpn的效果，在外网访问内网资源或者设备，同时可以设置用户名和密码验证<br>
强大的web管理界面，可方便的设置的和管理隧道<br>
支持同时开多条tcp、udp隧道等等，且只需要开一个客户端和服务端<br>
支持一个服务端，多个客户端模式<br>
三、安装方法<br>
release安装<br>
https://github.com/cnlh/easyProxy/releases</p>
<p>下载对应的系统版本即可（目前linux和windows只编译了64位的），服务端和客户端共用一个程序，go语言开发，无需任何第三方依赖</p>
<p>源码安装<br>
安装源码<br>
go get github.com/cnlh/easyProxy</p>
<p>编译（无第三方模块）<br>
go build</p>
<p>四、使用方法<br>
有两种模式：</p>
<p>1、单客户端模式，所有的隧道流量均从这个单客户端转发。</p>
<p>服务端<br>
./easyProxy -mode=webServer -tcpport=8284 -vkey=DKibZF5TXvic1g3kY<br>
名称	含义<br>
mode	运行模式<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
配置<br>
进入web界面，公网ip:web界面端口（默认8080），密码为123</p>
<p>2、多客户端模式，不同的隧道流量均从不同的客户端转发。</p>
<p>服务端<br>
./easyProxy -mode=webServer -tcpport=8284<br>
名称	含义<br>
mode	运行模式<br>
tcpport	服务端与客户端通信端口<br>
客户端<br>
进入web管理界面，有详细的命令</p>
<p>配置<br>
进入web界面，公网ip:web界面端口（默认8080），密码为123</p>
<p>配置文件/conf/app.conf<br>
名称	含义<br>
httpport	web管理端口<br>
password	web界面管理密码<br>
hostPort	域名代理模式监听端口<br>
TCP隧道模式<br>
场景及原理<br>
较为适用于处理tcp连接，例如ssh，同时也适用于http等，访问服务端的8024端口相当于访问内网10.1.50.202机器的4000端口，构成如下所示的隧道。<br>
<img src="https://newdy.cf/post-images/1581905662220.jpg" alt="" loading="lazy"><br>
例如：</p>
<p>背景:</p>
<p>内网机器10.1.50.203提供了web服务80端口<br>
有VPS一个,公网IP:123.206.77.88<br>
需求:</p>
<p>在家里能够通过访问VPS的8024端口访问到内网机器A的80端口</p>
<p>使用<br>
服务端<br>
./easyProxy -mode=tunnelServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024 -target=10.1.50.203:80<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	外部访问端口<br>
target	目标地址，格式如上<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
udp隧道模式<br>
场景及原理<br>
背景</p>
<p>内网机器A提供了DNS解析服务,10.1.50.210:53端口<br>
有VPS一个,公网IP:123.206.77.88<br>
需求: 在家里能够通过设置本地dns为123.206.77.88,使用内网机器A进行域名解析服务.</p>
<p>访问vps的53端口相当于访问10.1.50.210的53端口，构成如下所示的隧道。<br>
<img src="https://newdy.cf/post-images/1581905725788.png" alt="" loading="lazy"><br>
使用<br>
服务端<br>
./easyProxy -mode=udpServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=53 -target=10.1.50.210:53<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	公网vps的访问端口<br>
target	目标地址，格式如上<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
HTTP代理请求<br>
场景及原理<br>
较为适用于http，也就是web站点的穿透，服务端与客户端之间建立连接，服务端收到http请求后，将请求发送到客户端，客户端再执行这个请求，并将结果返回给服务端，服务端收到后再返回。特点：支持同时代理多个站点，不同站点之间有联系还可以实现匹配替换<br>
<img src="https://newdy.cf/post-images/1581905766574.png" alt="" loading="lazy"><br>
最终效果：</p>
<p>访问a.server.com和访问10.1.50.203的80端口相同<br>
访问b.server.com和访问10.1.50.202的80端口相同<br>
访问c.server.com和访问10.1.50.201的80端口相同<br>
使用<br>
服务端<br>
./easyProxy -mode=httpServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	代理的http端口（与nginx配合使用）<br>
客户端<br>
建立配置文件 config.json<br>
./easyProxy -server=ip:port -config=config.json -vkey=DKibZF5TXvic1g3kY<br>
名称	含义<br>
config	配置文件路径<br>
配置文件config.json<br>
{<br>
&quot;SiteList&quot;: [<br>
{<br>
&quot;host&quot;: &quot;a.ourcauc.com&quot;,<br>
&quot;url&quot;: &quot;10.1.50.203&quot;,<br>
&quot;port&quot;: 80<br>
},<br>
{<br>
&quot;host&quot;: &quot;b.ourcauc.com&quot;,<br>
&quot;url&quot;: &quot;10.1.50.202&quot;,<br>
&quot;port&quot;: 80<br>
},<br>
{<br>
&quot;host&quot;: &quot;c.ourcauc.com&quot;,<br>
&quot;url&quot;: &quot;10.1.50.203&quot;,<br>
&quot;port&quot;: 80<br>
}<br>
],<br>
&quot;Replace&quot;: 0<br>
}<br>
名称	含义<br>
SiteList	本地解析的域名列表<br>
host	域名地址<br>
url	内网代理的地址<br>
port	内网代理的地址对应的端口<br>
Replace	是否自动匹配替换（查看场景）<br>
nginx代理配置示例<br>
upstream nodejs {<br>
server 127.0.0.1:8024;<br>
keepalive 64;<br>
}<br>
server {<br>
listen 80;<br>
server_name a.ourcauc.com b.ourcauc.com c.ourcauc.com ;<br>
location / {<br>
proxy_set_header X-Real-IP $remote_addr;<br>
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>
proxy_set_header Host  $http_host;<br>
proxy_set_header X-Nginx-Proxy true;<br>
proxy_set_header Connection &quot;&quot;;<br>
proxy_pass      http://nodejs;<br>
}<br>
}<br>
域名配置示例<br>
-a	A	123.206.77.88</p>
<p>-b	A	123.206.77.88</p>
<p>-c	A	123.206.77.88</p>
<p>跨站自动匹配替换说明<br>
例如，访问：a.ourcauc.com，该页面里面有一个超链接为10.1.50.202:80,将根据配置文件自动该将url替换为b.ourcauc.com，以达到跨站也可访问的效果，但需要提前在配置文件中配置这些站点。</p>
<p>如需开启，请加配置文件Replace值设置为1</p>
<p>注意：开启可能导致不应该被替换的内容被替换，请谨慎开启</p>
<p>socks5代理模式<br>
场景及原理<br>
原理</p>
<p>主要用于socks5代理，也就是和ss类似，不过是代理内网。使用此模式时，可在非内网环境下配置本机的socks5代理（服务器ip、sock5代理端口），即可实现socks5代理，达到访问内网的网站的效果，配合proxifer等全局代理软件，即可如同使用内网vpn一样，访问内网网站，通过ssh连接内网机器等等……。<br>
<img src="https://newdy.cf/post-images/1581905816245.png" alt="" loading="lazy"><br>
使用<br>
服务端<br>
./easyProxy -mode=sock5ServerServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	代理的http端口（socks5连接端口）<br>
u	验证的用户名<br>
p	验证的密码<br>
说明：用户名和密码验证模式，仅部分socks5客户端支持，例如proxifer。 如需验证，在服务端命令后加上</p>
<p>-u=user -p=password<br>
即可</p>
<p>客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
需要使用内网代理的机器<br>
配置sock5代理即可，ip为外网服务器ip，端口为httpport，即可在外网环境使用内网啦！也可使用proxifer等全局代理软件。<br>
如果设置了用户名和密码，记得填上用户名和密码</p>
<p>http代理模式<br>
场景及原理<br>
<img src="https://newdy.cf/post-images/1581905912887.png" alt="" loading="lazy"><br>
主要用于HTTP代理，区别也就是HTTP代理和sock5代理的区别。使用此模式时，可在非内网环境下配置本机的HTTP代理（服务器ip、HTTP代理端口），即可实现HTTP代理，达到访问内网的网站的效果。</p>
<p>使用<br>
服务端<br>
./easyProxy -mode=httpProxyServer -vkey=DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024<br>
名称	含义<br>
mode	运行模式(client、server不写默认client)<br>
vkey	验证密钥<br>
tcpport	服务端与客户端通信端口<br>
httpport	http代理连接端口<br>
客户端<br>
./easyProxy -server=ip:port -vkey=DKibZF5TXvic1g3kY<br>
需要使用内网代理的机器<br>
配置HTTP代理即可，ip为外网服务器ip，端口为httpport，即可在外网环境访问内网啦！<br>
数据压缩支持<br>
场景及原理<br>
由于是内网穿透，内网客户端与服务端之间的隧道存在大量的数据交换，为节省流量，加快传输速度，由此本程序支持GZIP、SNNAPY两种形式的压缩，两者差异请自行选择。</p>
<p>注意点<br>
所有模式均支持数据压缩<br>
如何使用<br>
GZIP压缩</p>
<p>在server端加上参数 -compress=gzip，例如在TCP隧道模式<br>
./easyProxy -mode tunnelServer -vkey DKibZF5TXvic1g3kY -tcpport=8284 -httpport=8024 -target=10.1.50.203:80 -compress=gzip<br>
SNAPPY压缩</p>
<p>将参数修改为snappy即可</p>
<p>操作系统支持<br>
支持Windows、Linux、MacOSX等，无第三方依赖库。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 群晖上监控插件SurveillanceStation 破解255]]></title>
        <id>https://newdy.cf/post/surveillancestation-po-jie-255/</id>
        <link href="https://newdy.cf/post/surveillancestation-po-jie-255/">
        </link>
        <updated>2020-02-17T01:25:11.000Z</updated>
        <content type="html"><![CDATA[<p>安装好群晖的监控工具后！先不要启动把这三个附件解压后<br>
<img src="https://newdy.cf/post-images/1581902779887.jpg" alt="" loading="lazy"><br>
<img src="https://newdy.cf/post-images/1581902848427.jpg" alt="" loading="lazy"><br>
sscored权限应该是 755</p>
<p>chmod 755 /var/packages/SurveillanceStation/target/sbin/sscored</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[群晖存储空间损毁 Btrfs 数据恢复教程]]></title>
        <id>https://newdy.cf/post/qun-hui-cun-chu-kong-jian-sun-hui-btrfs-shu-ju-hui-fu-jiao-cheng/</id>
        <link href="https://newdy.cf/post/qun-hui-cun-chu-kong-jian-sun-hui-btrfs-shu-ju-hui-fu-jiao-cheng/">
        </link>
        <updated>2020-02-11T14:52:53.000Z</updated>
        <content type="html"><![CDATA[<p>由于囊中羞涩，reizhi 一直在使用黑群晖作为家庭存储方案。不知何故，几天前突然提示存储空间已损毁。这种情况下白群晖是可以直接联系技术支持的，无奈我只好自己想办法解决。而网络上搜索到的教程和案例都是使用 Ext4 作为文件系统，那么只需要用 UFS explorer 来修复就好了。偏偏我是用的是 Btrfs 文件系统，于是只好爬问研究。最终通过三天时间的反复尝试，成功将所有数据挽回，在此分享一下经历和经验供日后参考。</p>
<p>如果你也遇到了类似问题，完全不用急着慌张。虽然 Btrfs 相比于 Ext4 并没有任何稳定性上的优势，但经过多年的更新和改进文件系统已经比较完善，再加上 RAID 的数据保护，丢失文件的几率并不高。</p>
<p>如果你的群晖提示存储空间损毁，但 RAID 并没有异常，可以无需进行 RAID 清理。通过查看 S.M.A.R.T 状态，发现所有硬盘均处于健康状态，于是跳过这一步。接下来我们需要引导到 Ubuntu 系统并尝试挂载 RAID ，此时既可以使用原有机器，也可以将所有硬盘连接到其他机器中操作。在原机安装 Ubuntu 时请注意不要将系统安装至存有数据的硬盘。安装镜像以及教程可以直接在官网获取，这里便不再赘述了。另外由于恢复过程耗时较长，不建议使用 LiveCD 来操作。</p>
<p>安装完成后的第一件事是安装必要的工具包以及挂载 RAID，打开终端并以 root 身份（sudo -i）执行以下操作：</p>
<p>apt-get update<br>
apt-get install mdadm lvm2 btrfs-prog<br>
mdadm -Asf &amp;&amp; vgchange -ay<br>
正常完成后可以在磁盘管理中看到 RAID 阵列，但是由于文件系统损坏，此时是无法挂载的。这里会显示阵列的设备文件是 /dev/md/2 ，记住你的显示值，稍后会要用到。<br>
<img src="https://newdy.cf/post-images/1581432806246.png" alt="" loading="lazy"><br>
我们切换回终端，运行以下命令：</p>
<p>btrfs-find-root /dev/md/2 &amp;&gt; /tmp/root.txt<br>
运行过程可能需要10-30分钟，期间是没有任何回显的。等待运行完成后终端会返回命令提示符，这时我们打开 /tmp/root.txt 文件，可以看到如下内容：<br>
<img src="https://newdy.cf/post-images/1581432867060.png" alt="" loading="lazy"><br>
我们需要用到的数据是 Well block 后面的这一串数字，其后的 gen 数字越高，恢复的可能性越大。下一步使用找到的 tree root 来模拟修复，到目前为止的所有操作都不会对硬盘进行写入和修改，也不会破坏任何数据。</p>
<p>btrfs check --tree-root <block> --super <sup><br>
其中 <block> 为上一步中的数值，按 gen 数字从高到低依次尝试使用，<sup> 可以尝试0，1或2。如果 <block> 有效，运行结果末尾应当类似于以下图示：<br>
<img src="https://newdy.cf/post-images/1581432909952.png" alt="" loading="lazy"><br>
如果最后回显不是以上格式，表明这一条 <block> 无效，需要继续尝试下一条。在确认看到以上提示后，我们尝试将数据导出。</p>
<p>btrfs restore /dev/md/2 /tmp -D -v -F -i -t <sup><br>
此时仍然使用上一步中的 <block> 值，将 /tmp 改为导出目录，需要确保留有足够空间存储文件。如果文件名包含特殊符号可能导致导出中断，将目标分区格式化为 Ext3/4 即可。<br>
<img src="https://newdy.cf/post-images/1581432941261.png" alt="" loading="lazy"><br>
如果导出正常进行，会看到类似上图的提示，此处没有进度提示，可以自行前往导出目录查看。如果导出失败会给出其他提示，在确认导出分区是 Ext3/4 的情况下，则只能退回上一步尝试其他 <sup> 值。</p>
<p>到目前为止我们并没有对数据盘进行任何写入和修改操作，如果因为种种原因无法导出，或是导出过程异常中断，仍然可以通过修复原盘的方式来挽回数据。不过请注意，此步骤有可能会损坏数据，如果你不能接受任何风险，请停止执行并联系专业机构。</p>
<p>btrfs check --repair --tree-root <block> --super <sup><br>
使用之前步骤中正常回显的 <block> 及 <sup> 值进行正式修复，确认操作完成后执行：</p>
<p>btrfs rescue super-recover /dev/md/2<br>
<img src="https://newdy.cf/post-images/1581432991454.png" alt="" loading="lazy"></p>
<p>提示确认目标分区是 Btrfs 文件系统，否则会损坏数据，输入 y 确认操作。等待数秒后再次回到提示符，如果一切顺利，此时已经可以通过磁盘管理工具挂载 Btrfs 分区了。不过群晖很大几率不会识别修复后的文件系统，还是建议将数据导出后再将硬盘还原。😚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[群晖开启 SMB3 多通道叠加网卡速度]]></title>
        <id>https://newdy.cf/post/qun-hui-kai-qi-smb3-duo-tong-dao-die-jia-wang-qia-su-du/</id>
        <link href="https://newdy.cf/post/qun-hui-kai-qi-smb3-duo-tong-dao-die-jia-wang-qia-su-du/">
        </link>
        <updated>2020-02-11T14:47:10.000Z</updated>
        <content type="html"><![CDATA[<p>不少的群晖机型都带有2个甚至更多的网卡，为了突破 1Gbps 的局域网连接速度，我们以往需要在交换机、群晖和 PC 端配置链路聚合(link aggregation)。不仅配置较为繁琐，而且额外增加了 PC 端和交换机的成本，实际普及率并不高。而自 DSM 6.1-15047 之后，群晖为我们带来了 SMB3 多通道支持，使得我们能够以及其低廉的成本享受多网卡叠加带来的速度提升。</p>
<p>要使用 SMB3.0 的多通道来叠加网卡速度，需要以下几个条件：</p>
<p>群晖带有2个或以上的相同线速的网卡，并安装 DSM 6.1-15047 及更高版本<br>
普通交换机<br>
PC 端带有2个或以上的相同线速的网卡，并安装 Windows 8/Server 2012及更高版本 OS<br>
由于群晖目前没有开放相关设置项，所以我们部分操作需要通过 SSH 来完成：</p>
<p>1.打开控制面板，依次进入：文件服务-高级设置，将最大协议改为 SMB3，点击应用<br>
<img src="https://newdy.cf/post-images/1581432465559.png" alt="" loading="lazy"><br>
2.进入：终端机和 SNMP，勾选启动 SSH 功能，点击应用<br>
<img src="https://newdy.cf/post-images/1581432503103.png" alt="" loading="lazy"><br>
3.使用 PUTTY 等软件登入群晖 SSH，输入 sudo -i 临时提权，并输入密码回车。待命令提示符由 $ 变为 # 后，执行：vi /etc/samba/smb.conf<br>
<img src="https://newdy.cf/post-images/1581432535629.png" alt="" loading="lazy"><br>
4.在文件末尾添加以下内容，完成后按 ESC，并输入 :wq 保存退出</p>
<p>server multi channel support = yes<br>
aio read size = 1<br>
aio write size = 1<br>
5.重启群晖，PC 和交换机，所有设置完成。</p>
<p>在重启完成后，PC 端使用主机名（如\homeshare）或 ip 进入一次共享，即可自动启用 SMB3 多通道了。另外也可以用管理员权限运行 PowerShell ，执行： Get-SmbMultichannelConnection 确认。<br>
<img src="https://newdy.cf/post-images/1581432576355.png" alt="" loading="lazy"><br>
如上所示，目前 PC 已连接到服务器 192.168.199.189，并且分别通过本地 ip:192.168.199.99 192.168.199.100 与远端 ip: 192.168.199.188 192.168.199.189 建立了 SMB3 多通道连接。<br>
<img src="https://newdy.cf/post-images/1581432604857.png" alt="" loading="lazy"><br>
通过复制文件也可以看出，两张网卡均有流量，并且总和超过了 1Gbps 。</p>
<p>基于 RTL8111 的 PCIE x1 网卡目前均价不过20-30块，并且对于交换机并无特殊限制，故整套解决方案成本是非常低的。除了PCIE 网卡之外，也可以使用 USB 网卡，但需要确保所有网卡线速一致，才能够启用 SMB3 多通道。</p>
]]></content>
    </entry>
</feed>